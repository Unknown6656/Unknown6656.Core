///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2020-08-31 20:36:47.433585              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System;


namespace Unknown6656.Common
{

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, V>
    {
        private readonly Action<I1, V> _setter;
        private readonly Func<I1, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, V> getter, Action<I1, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, V> getter, WriteOnlyIndexer<I1, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, V> AsReadOnly() => new ReadOnlyIndexer<I1, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, V> AsWriteOnly() => new WriteOnlyIndexer<I1, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, V>(Indexer<I1, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, V>(Indexer<I1, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, V>
    {
        private readonly Func<I1, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, V>(ReadOnlyIndexer<I1, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, V>(Func<I1, V> func) => new ReadOnlyIndexer<I1, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, V>
    {
        private readonly Action<I1, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, V>(WriteOnlyIndexer<I1, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, V>(Action<I1, V> func) => new WriteOnlyIndexer<I1, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, V>(I1 i1);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, V>
    {
        private readonly RefFunc<I1, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, V> AsIndexer() => new Indexer<I1, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, V> AsReadOnly() => new ReadOnlyIndexer<I1, V>((I1 i1) => _func(i1));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, V> AsWriteOnly() => new WriteOnlyIndexer<I1, V>((I1 i1, V v) => _func(i1) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, V>(RefIndexer<I1, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, V>(RefIndexer<I1, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, V>(RefIndexer<I1, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, V>(RefIndexer<I1, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, V>(RefFunc<I1, V> func) => new RefIndexer<I1, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, V>
    {
        private readonly Action<I1, I2, V> _setter;
        private readonly Func<I1, I2, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, V> getter, Action<I1, I2, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, V> getter, WriteOnlyIndexer<I1, I2, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, V>(Indexer<I1, I2, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, V>(Indexer<I1, I2, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, V>
    {
        private readonly Func<I1, I2, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, V>(ReadOnlyIndexer<I1, I2, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, V>(Func<I1, I2, V> func) => new ReadOnlyIndexer<I1, I2, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, V>
    {
        private readonly Action<I1, I2, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, V>(WriteOnlyIndexer<I1, I2, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, V>(Action<I1, I2, V> func) => new WriteOnlyIndexer<I1, I2, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, V>(I1 i1, I2 i2);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, V>
    {
        private readonly RefFunc<I1, I2, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, V> AsIndexer() => new Indexer<I1, I2, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, V>((I1 i1, I2 i2) => _func(i1, i2));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, V>((I1 i1, I2 i2, V v) => _func(i1, i2) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, V>(RefIndexer<I1, I2, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, V>(RefIndexer<I1, I2, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, V>(RefIndexer<I1, I2, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, V>(RefIndexer<I1, I2, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, V>(RefFunc<I1, I2, V> func) => new RefIndexer<I1, I2, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, V>
    {
        private readonly Action<I1, I2, I3, V> _setter;
        private readonly Func<I1, I2, I3, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, V> getter, Action<I1, I2, I3, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, V> getter, WriteOnlyIndexer<I1, I2, I3, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, V>(Indexer<I1, I2, I3, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, V>(Indexer<I1, I2, I3, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, V>
    {
        private readonly Func<I1, I2, I3, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, V>(ReadOnlyIndexer<I1, I2, I3, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, V>(Func<I1, I2, I3, V> func) => new ReadOnlyIndexer<I1, I2, I3, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, V>
    {
        private readonly Action<I1, I2, I3, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, V>(WriteOnlyIndexer<I1, I2, I3, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, V>(Action<I1, I2, I3, V> func) => new WriteOnlyIndexer<I1, I2, I3, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, V>(I1 i1, I2 i2, I3 i3);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, V>
    {
        private readonly RefFunc<I1, I2, I3, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, V> AsIndexer() => new Indexer<I1, I2, I3, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, V>((I1 i1, I2 i2, I3 i3) => _func(i1, i2, i3));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, V>((I1 i1, I2 i2, I3 i3, V v) => _func(i1, i2, i3) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, V>(RefIndexer<I1, I2, I3, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, V>(RefIndexer<I1, I2, I3, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, V>(RefIndexer<I1, I2, I3, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, V>(RefIndexer<I1, I2, I3, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, V>(RefFunc<I1, I2, I3, V> func) => new RefIndexer<I1, I2, I3, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, V>
    {
        private readonly Action<I1, I2, I3, I4, V> _setter;
        private readonly Func<I1, I2, I3, I4, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, V> getter, Action<I1, I2, I3, I4, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, V>(Indexer<I1, I2, I3, I4, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, V>(Indexer<I1, I2, I3, I4, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, V>
    {
        private readonly Func<I1, I2, I3, I4, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, V>(ReadOnlyIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, V>(Func<I1, I2, I3, I4, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, V>
    {
        private readonly Action<I1, I2, I3, I4, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, V>(WriteOnlyIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, V>(Action<I1, I2, I3, I4, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, V>(I1 i1, I2 i2, I3 i3, I4 i4);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, V> AsIndexer() => new Indexer<I1, I2, I3, I4, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, V>((I1 i1, I2 i2, I3 i3, I4 i4) => _func(i1, i2, i3, i4));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, V>((I1 i1, I2 i2, I3 i3, I4 i4, V v) => _func(i1, i2, i3, i4) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, V>(RefIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, V>(RefIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, V>(RefIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, V>(RefIndexer<I1, I2, I3, I4, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, V>(RefFunc<I1, I2, I3, I4, V> func) => new RefIndexer<I1, I2, I3, I4, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, V> getter, Action<I1, I2, I3, I4, I5, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, V>(Indexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, V>(Indexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, V>(Func<I1, I2, I3, I4, I5, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, V>(Action<I1, I2, I3, I4, I5, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5) => _func(i1, i2, i3, i4, i5));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, V v) => _func(i1, i2, i3, i4, i5) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, V>(RefIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, V>(RefIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, V>(RefIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, V>(RefIndexer<I1, I2, I3, I4, I5, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, V>(RefFunc<I1, I2, I3, I4, I5, V> func) => new RefIndexer<I1, I2, I3, I4, I5, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, I6, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, I6, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, I6, V> getter, Action<I1, I2, I3, I4, I5, I6, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(Indexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(Indexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, I6, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, I6, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, I6, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, I6, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(Func<I1, I2, I3, I4, I5, I6, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, I6, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, I6, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, I6, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(Action<I1, I2, I3, I4, I5, I6, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5, I6 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, I6, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <param name="i6"><typeparamref name="I6"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, in I6, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, I6, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, I6, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5, i6);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, I6, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, I6, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, I6, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6) => _func(i1, i2, i3, i4, i5, i6));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, V v) => _func(i1, i2, i3, i4, i5, i6) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, I6, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, I6, V>(RefIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, I6, V>(RefIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(RefIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, V>(RefIndexer<I1, I2, I3, I4, I5, I6, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, I6, V>(RefFunc<I1, I2, I3, I4, I5, I6, V> func) => new RefIndexer<I1, I2, I3, I4, I5, I6, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, I6, I7, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, I6, I7, V> getter, Action<I1, I2, I3, I4, I5, I6, I7, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, I6, I7, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, I6, I7, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, I6, I7, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(Func<I1, I2, I3, I4, I5, I6, I7, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, I6, I7, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, I6, I7, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, I6, I7, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(Action<I1, I2, I3, I4, I5, I6, I7, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5, I6, I7 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, I6, I7, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> parameter type</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <param name="i6"><typeparamref name="I6"/> parameter</typeparam>
    /// <param name="i7"><typeparamref name="I7"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, in I6, in I7, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, I6, I7, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, I6, I7, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5, i6, i7);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, I6, I7, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, I6, I7, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, I6, I7, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7) => _func(i1, i2, i3, i4, i5, i6, i7));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, V v) => _func(i1, i2, i3, i4, i5, i6, i7) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, I6, I7, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, I6, I7, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, I6, I7, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, I6, I7, V>(RefFunc<I1, I2, I3, I4, I5, I6, I7, V> func) => new RefIndexer<I1, I2, I3, I4, I5, I6, I7, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, V> getter, Action<I1, I2, I3, I4, I5, I6, I7, I8, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, I6, I7, I8, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, I6, I7, I8, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(Func<I1, I2, I3, I4, I5, I6, I7, I8, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, I6, I7, I8, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, I6, I7, I8, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, I6, I7, I8, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(Action<I1, I2, I3, I4, I5, I6, I7, I8, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5, I6, I7, I8 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, I6, I7, I8, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> parameter type</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> parameter type</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <param name="i6"><typeparamref name="I6"/> parameter</typeparam>
    /// <param name="i7"><typeparamref name="I7"/> parameter</typeparam>
    /// <param name="i8"><typeparamref name="I8"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, in I6, in I7, in I8, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5, i6, i7, i8);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8) => _func(i1, i2, i3, i4, i5, i6, i7, i8));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, V v) => _func(i1, i2, i3, i4, i5, i6, i7, i8) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, V> func) => new RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, i9, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8, i9);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> getter, Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8, i9);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, i9, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5, I6, I7, I8, I9 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, I6, I7, I8, I9, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> parameter type</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> parameter type</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> parameter type</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <param name="i6"><typeparamref name="I6"/> parameter</typeparam>
    /// <param name="i7"><typeparamref name="I7"/> parameter</typeparam>
    /// <param name="i8"><typeparamref name="I8"/> parameter</typeparam>
    /// <param name="i9"><typeparamref name="I9"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, in I6, in I7, in I8, in I9, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5, i6, i7, i8, i9);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9) => _func(i1, i2, i3, i4, i5, i6, i7, i8, i9));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, V v) => _func(i1, i2, i3, i4, i5, i6, i7, i8, i9) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, V> func) => new RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, V>(func);
    }

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I10">Generic <typeparamref name="I10"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> _setter;
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <param name="i10">Index no. 10</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> getter, Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> getter, WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I10">Generic <typeparamref name="I10"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>
    {
        private readonly Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <param name="i10">Index no. 10</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(Func<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> func) => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I10">Generic <typeparamref name="I10"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>
    {
        private readonly Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <param name="i10">Index no. 10</typeparam>
        /// <returns>Value</returns>
        public V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(Action<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> func) => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "I1, I2, I3, I4, I5, I6, I7, I8, I9, I10 -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V}"/>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> parameter type</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> parameter type</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> parameter type</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> parameter type</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> parameter type</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> parameter type</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> parameter type</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> parameter type</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> parameter type</typeparam>
    /// <typeparam name="I10">Generic <typeparamref name="I10"/> parameter type</typeparam>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
    /// <param name="i1"><typeparamref name="I1"/> parameter</typeparam>
    /// <param name="i2"><typeparamref name="I2"/> parameter</typeparam>
    /// <param name="i3"><typeparamref name="I3"/> parameter</typeparam>
    /// <param name="i4"><typeparamref name="I4"/> parameter</typeparam>
    /// <param name="i5"><typeparamref name="I5"/> parameter</typeparam>
    /// <param name="i6"><typeparamref name="I6"/> parameter</typeparam>
    /// <param name="i7"><typeparamref name="I7"/> parameter</typeparam>
    /// <param name="i8"><typeparamref name="I8"/> parameter</typeparam>
    /// <param name="i9"><typeparamref name="I9"/> parameter</typeparam>
    /// <param name="i10"><typeparamref name="I10"/> parameter</typeparam>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<in I1, in I2, in I3, in I4, in I5, in I6, in I7, in I8, in I9, in I10, V>(I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
    /// <typeparam name="I1">Generic <typeparamref name="I1"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I2">Generic <typeparamref name="I2"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I3">Generic <typeparamref name="I3"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I4">Generic <typeparamref name="I4"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I5">Generic <typeparamref name="I5"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I6">Generic <typeparamref name="I6"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I7">Generic <typeparamref name="I7"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I8">Generic <typeparamref name="I8"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I9">Generic <typeparamref name="I9"/> indexing type (the key type)</typeparam>
    /// <typeparam name="I10">Generic <typeparamref name="I10"/> indexing type (the key type)</typeparam>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>
    {
        private readonly RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
        /// <param name="i1">Index no. 1</typeparam>
        /// <param name="i2">Index no. 2</typeparam>
        /// <param name="i3">Index no. 3</typeparam>
        /// <param name="i4">Index no. 4</typeparam>
        /// <param name="i5">Index no. 5</typeparam>
        /// <param name="i6">Index no. 6</typeparam>
        /// <param name="i7">Index no. 7</typeparam>
        /// <param name="i8">Index no. 8</typeparam>
        /// <param name="i9">Index no. 9</typeparam>
        /// <param name="i10">Index no. 10</typeparam>
        /// <returns>Value reference</returns>
        public ref V this[I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsIndexer() => new Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsReadOnly() => new ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10) => _func(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsWriteOnly() => new WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>((I1 i1, I2 i2, I3 i3, I4 i4, I5 i5, I6 i6, I7 i7, I8 i8, I9 i9, I10 i10, V v) => _func(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(RefFunc<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V> func) => new RefIndexer<I1, I2, I3, I4, I5, I6, I7, I8, I9, I10, V>(func);
    }
}
