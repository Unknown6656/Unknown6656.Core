<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System;


namespace Unknown6656.Common
{
<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 1; dim < maxdim; ++dim)
    {
        var pars_types = string.Join(", ", r(1, dim).Select(i => $"I{i}"));
        var pars_names = string.Join(", ", r(1, dim).Select(i => $"i{i}"));
        var pars_decls = string.Join(", ", r(1, dim).Select(i => $"I{i} i{i}"));
        var pars_dtypes = string.Join(", ", r(1, dim).Select(i => $"in I{i}"));
#>

    /// <summary>
    /// Represents a read/write indexer to be used for indexable properties.
    /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <typeparam name="I<#=i#>">Generic <typeparamref name="I<#=i#>"/> indexing type (the key type)</typeparam>
<#
        }
#>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class Indexer<<#=pars_types#>, V>
    {
        private readonly Action<<#=pars_types#>, V> _setter;
        private readonly Func<<#=pars_types#>, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
        /// <param name="i<#=i#>">Index no. <#=i#></typeparam>
<#
        }
#>
        /// <returns>Value</returns>
        public V this[<#=pars_decls#>]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(<#=pars_names#>, value);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(<#=pars_names#>);
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(Func<<#=pars_types#>, V> getter, Action<<#=pars_types#>, V> setter)
        {
            _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));
            _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));
        }

        /// <summary>
        /// Creates a new indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer(ReadOnlyIndexer<<#=pars_types#>, V> getter, WriteOnlyIndexer<<#=pars_types#>, V> setter)
            : this(getter.AsFunction(), setter.AsFunction())
        {
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<<#=pars_types#>, V> AsReadOnly() => new ReadOnlyIndexer<<#=pars_types#>, V>(_getter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<<#=pars_types#>, V> AsWriteOnly() => new WriteOnlyIndexer<<#=pars_types#>, V>(_setter);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<<#=pars_types#>, V>(Indexer<<#=pars_types#>, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<<#=pars_types#>, V>(Indexer<<#=pars_types#>, V> indexer) => indexer.AsWriteOnly();
    }

    /// <summary>
    /// Represents a read-only indexer to be used for indexable properties.
    /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <typeparam name="I<#=i#>">Generic <typeparamref name="I<#=i#>"/> indexing type (the key type)</typeparam>
<#
        }
#>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class ReadOnlyIndexer<<#=pars_types#>, V>
    {
        private readonly Func<<#=pars_types#>, V> _getter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
        /// <param name="i<#=i#>">Index no. <#=i#></typeparam>
<#
        }
#>
        /// <returns>Value</returns>
        public V this[<#=pars_decls#>]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => _getter(<#=pars_names#>);
        }

        /// <summary>
        /// Creates a new read-only indexer.
        /// </summary>
        /// <param name="getter">Getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer(Func<<#=pars_types#>, V> getter) => _getter = getter ?? throw new ArgumentException("The getter function must not be null.", nameof(getter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Func<<#=pars_types#>, V> AsFunction() => _getter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Func<<#=pars_types#>, V>(ReadOnlyIndexer<<#=pars_types#>, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<<#=pars_types#>, V>(Func<<#=pars_types#>, V> func) => new ReadOnlyIndexer<<#=pars_types#>, V>(func);
    }

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <typeparam name="I<#=i#>">Generic <typeparamref name="I<#=i#>"/> indexing type (the key type)</typeparam>
<#
        }
#>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class WriteOnlyIndexer<<#=pars_types#>, V>
    {
        private readonly Action<<#=pars_types#>, V> _setter;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
        /// <param name="i<#=i#>">Index no. <#=i#></typeparam>
<#
        }
#>
        /// <returns>Value</returns>
        public V this[<#=pars_decls#>]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => _setter(<#=pars_names#>, value);
        }

        /// <summary>
        /// Creates a new write-only indexer.
        /// </summary>
        /// <param name="setter">Setter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer(Action<<#=pars_types#>, V> setter) => _setter = setter ?? throw new ArgumentException("The setter function must not be null.", nameof(setter));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Action<<#=pars_types#>, V> AsFunction() => _setter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Action<<#=pars_types#>, V>(WriteOnlyIndexer<<#=pars_types#>, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<<#=pars_types#>, V>(Action<<#=pars_types#>, V> func) => new WriteOnlyIndexer<<#=pars_types#>, V>(func);
    }

    /// <summary>
    /// Represents a ref function of the form "<#=pars_types#> -> ref V"
    /// </summary>
    /// <inheritdoc cref="Func{<#=pars_types#>, V}"/>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <typeparam name="I<#=i#>">Generic <typeparamref name="I<#=i#>"/> parameter type</typeparam>
<#
        }
#>
    /// <typeparam name="V">Generic <typeparamref name="V"/> return type</typeparam>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <param name="i<#=i#>"><typeparamref name="I<#=i#>"/> parameter</typeparam>
<#
        }
#>
    /// <returns>ref V return value</returns>
    public delegate ref V RefFunc<<#=pars_dtypes#>, V>(<#=pars_decls#>);

    /// <summary>
    /// Represents a write-only indexer to be used for indexable properties.
    /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
    /// <typeparam name="I<#=i#>">Generic <typeparamref name="I<#=i#>"/> indexing type (the key type)</typeparam>
<#
        }
#>
    /// <typeparam name="V">Generic value type</typeparam>
    public sealed class RefIndexer<<#=pars_types#>, V>
    {
        private readonly RefFunc<<#=pars_types#>, V> _func;


        /// <summary>
        /// The indexer's accessor.
        /// </summary>
<#
        for (int i = 1; i <= dim; ++i)
        {
#>
        /// <param name="i<#=i#>">Index no. <#=i#></typeparam>
<#
        }
#>
        /// <returns>Value reference</returns>
        public ref V this[<#=pars_decls#>]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ref _func(<#=pars_names#>);
        }

        /// <summary>
        /// Creates a new ref indexer.
        /// </summary>
        /// <param name="func">Ref getter function</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefIndexer(RefFunc<<#=pars_types#>, V> func) => _func = func ?? throw new ArgumentException("The getter function must not be null.", nameof(func));
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Indexer<<#=pars_types#>, V> AsIndexer() => new Indexer<<#=pars_types#>, V>(AsReadOnly(), AsWriteOnly());

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public ReadOnlyIndexer<<#=pars_types#>, V> AsReadOnly() => new ReadOnlyIndexer<<#=pars_types#>, V>((<#=pars_decls#>) => _func(<#=pars_names#>));

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public WriteOnlyIndexer<<#=pars_types#>, V> AsWriteOnly() => new WriteOnlyIndexer<<#=pars_types#>, V>((<#=pars_decls#>, V v) => _func(<#=pars_names#>) = v);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RefFunc<<#=pars_types#>, V> AsFunction() => _func;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefFunc<<#=pars_types#>, V>(RefIndexer<<#=pars_types#>, V> indexer) => indexer.AsFunction();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator Indexer<<#=pars_types#>, V>(RefIndexer<<#=pars_types#>, V> indexer) => indexer.AsIndexer();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator ReadOnlyIndexer<<#=pars_types#>, V>(RefIndexer<<#=pars_types#>, V> indexer) => indexer.AsReadOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator WriteOnlyIndexer<<#=pars_types#>, V>(RefIndexer<<#=pars_types#>, V> indexer) => indexer.AsWriteOnly();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator RefIndexer<<#=pars_types#>, V>(RefFunc<<#=pars_types#>, V> func) => new RefIndexer<<#=pars_types#>, V>(func);
    }
<#
    }
#>
}
