<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

#nullable enable

using System;

using Unknown6656.Mathematics.LinearAlgebra;

namespace Unknown6656.Mathematics.Analysis;

<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim < maxdim; ++dim)
    {
        string typename = $"ImplicitScalarFunction{dim}D";
        string vecname = "Vector" + dim;
        string argdef = string.Join(", ", r(0, dim).Select(i => $"Scalar x{i}"));
        string vargs = string.Join(", ", r(0, dim).Select(i => $"v[{i}]"));
        string args = string.Join(", ", r(0, dim).Select(i => $"x{i}"));
#>

public partial class <#=typename#>
    : ImplicitFunction<<#=vecname#>>
{
    public bool this[<#=argdef#>] => Evaluate(<#=args#>);

    public bool this[<#=argdef#>, Scalar tolerance] => Evaluate(<#=args#>, tolerance);



    public <#=typename#>(Function<<#=vecname#>, Scalar> function)
        : this(function, ComparisonOperator.EqualTo, new(_ => Scalar.Zero))
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> function)
        : this(new Function<<#=vecname#>, Scalar>(function))
    {
    }

    public <#=typename#>(Func<<#=string.Join(", ", r(0, dim + 1).Select(_ => "Scalar"))#>> function)
        : this(v => function(<#=vargs#>))
    {
    }

    public <#=typename#>(Function<<#=vecname#>, Scalar> left, ComparisonOperator comparison, Function<<#=vecname#>, Scalar> right)
        : base(left, comparison, right)
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> left, ComparisonOperator comparison, Func<<#=vecname#>, Scalar> right)
        : base(left, comparison, right)
    {
    }

    public <#=typename#>(Func<<#=string.Join(", ", r(0, dim + 1).Select(_ => "Scalar"))#>> left, ComparisonOperator comparison, Func<<#=string.Join(", ", r(0, dim + 1).Select(_ => "Scalar"))#>> right)
        : base(v => left(<#=vargs#>), comparison, v => right(<#=vargs#>))
    {
    }

    public virtual bool Evaluate(<#=argdef#>) => Evaluate(<#=args#>, Scalar.ComputationalEpsilon);

    public virtual bool Evaluate(<#=argdef#>, Scalar tolerance) => base.Evaluate(new(<#=args#>), tolerance);

    public <#=typename#> Negate() => new(v => Left.Evaluate(-v), ComparisonOperator, v => Right.Evaluate(-v));

    public <#=typename#> Shift(<#=vecname#> offset) => new(v => Left.Evaluate(v - offset), ComparisonOperator, v => Right.Evaluate(v - offset));

    public <#=typename#> Scale(Scalar factor) => new(v => Left.Evaluate(v / factor), ComparisonOperator, v => Right.Evaluate(v - factor));

    public static <#=typename#> LinearInterpolate(<#=typename#> first, <#=typename#> second, Scalar factor)
    {
        ComparisonOperator op = ComparisonOperator.EqualTo;

        if (first.ComparisonOperator == second.ComparisonOperator)
            op = first.ComparisonOperator;
        else if (first.ComparisonOperator <= ComparisonOperator.EqualTo && second.ComparisonOperator <= ComparisonOperator.EqualTo)
            op = (ComparisonOperator)Math.Min((int)first.ComparisonOperator, (int)second.ComparisonOperator);
        else if (first.ComparisonOperator >= ComparisonOperator.EqualTo && second.ComparisonOperator >= ComparisonOperator.EqualTo)
            op = (ComparisonOperator)Math.Max((int)first.ComparisonOperator, (int)second.ComparisonOperator);

        factor = factor.Clamp();

        return new(
            xy => first.Left.Evaluate(xy) * (1 - factor) + second.Left.Evaluate(xy) * factor,
            op,
            xy => first.Right.Evaluate(xy) * (1 - factor) + second.Right.Evaluate(xy) * factor
        );
    }

    public static <#=typename#> operator +(<#=typename#> function) => function;

    public static <#=typename#> operator -(<#=typename#> function) => function.Negate();

    public static <#=typename#> operator +(<#=vecname#> offset, <#=typename#> function) => function.Shift(offset);

    public static <#=typename#> operator +(<#=typename#> function, <#=vecname#> offset) => function.Shift(offset);

    public static <#=typename#> operator -(<#=typename#> function, <#=vecname#> offset) => function.Shift(-offset);

    public static <#=typename#> operator *(Scalar scale, <#=typename#> function) => function.Scale(scale);

    public static <#=typename#> operator *(<#=typename#> function, Scalar scale) => function.Scale(scale);

    public static <#=typename#> operator /(<#=typename#> function, Scalar scale) => function.Scale(scale.MultiplicativeInverse);
}
<#
    }
#>