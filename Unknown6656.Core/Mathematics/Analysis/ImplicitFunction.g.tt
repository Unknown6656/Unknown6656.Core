<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System;

using Unknown6656.Mathematics.LinearAlgebra;

namespace Unknown6656.Mathematics.Analysis;

<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim < maxdim; ++dim)
    {
        string typename = $"ImplicitScalarFunction{dim}D";
        string vecname = "Vector" + dim;
        string fname = "Func<" + string.Join(", ", r(0, dim + 1).Select(_ => "Scalar")) + ">";
        string argdef = string.Join(", ", r(0, dim).Select(i => $"Scalar x{i}"));
        string vargs = string.Join(", ", r(0, dim).Select(i => $"v[{i}]"));
        string args = string.Join(", ", r(0, dim).Select(i => $"x{i}"));
#>

public partial class <#=typename#>
    : ImplicitFunction<<#=vecname#>>
{
    public bool this[<#=argdef#>] => Evaluate(<#=args#>);

    public bool this[<#=argdef#>, Scalar tolerance] => Evaluate(<#=args#>, tolerance);


    public <#=typename#>(ImplicitFunction<<#=vecname#>> function)
        : this(function.ExplicitFunction, function.ComparisonOperator)
    {
    }

    public <#=typename#>(Function<<#=vecname#>, Scalar> function)
        : this(function, ComparisonOperator.EqualTo)
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> function)
        : this(new Function<<#=vecname#>, Scalar>(function))
    {
    }

    public <#=typename#>(Function<<#=vecname#>, Scalar> function, ComparisonOperator comparison)
        : base(function, comparison)
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> function, ComparisonOperator comparison)
        : this(new Function<<#=vecname#>, Scalar>(function), comparison)
    {
    }

    public <#=typename#>(Function<<#=vecname#>, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(function.Subtract(value), comparison)
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> function, ComparisonOperator comparison, Scalar value)
        : this(new Function<<#=vecname#>, Scalar>(function), comparison, value)
    {
    }

    public <#=typename#>(Function<<#=vecname#>, Scalar> left, ComparisonOperator comparison, Function<<#=vecname#>, Scalar> right)
        : this(left.Subtract(right), comparison)
    {
    }

    public <#=typename#>(Func<<#=vecname#>, Scalar> left, ComparisonOperator comparison, Func<<#=vecname#>, Scalar> right)
        : this(new Function<<#=vecname#>, Scalar>(left), comparison, new Function<<#=vecname#>, Scalar>(right))
    {
    }

    public <#=typename#>(<#=fname#> function)
        : this(v => function(<#=vargs#>))
    {
    }

    public <#=typename#>(<#=fname#> function, ComparisonOperator comparison)
        : this(v => function(<#=vargs#>), comparison)
    {
    }

    public <#=typename#>(<#=fname#> function, ComparisonOperator comparison, Scalar value)
        : this(v => function(<#=vargs#>), comparison, value)
    {
    }

    public <#=typename#>(<#=fname#> left, ComparisonOperator comparison, <#=fname#> right)
        : this(v => left(<#=vargs#>), comparison, v => right(<#=vargs#>))
    {
    }

    public virtual bool Evaluate(<#=argdef#>) => Evaluate(<#=args#>, Scalar.ComputationalEpsilon);

    public virtual bool Evaluate(<#=argdef#>, Scalar tolerance) => base.Evaluate(new(<#=args#>), tolerance);

    public static <#=typename#> StretchBlend(<#=typename#> first, <#=typename#> second, Scalar blend_factor)
    {
        blend_factor = blend_factor.Clamp();

        return new(xy =>
            (1 - xy.Length.Multiply(blend_factor)).Max(Scalar.Zero).Multiply(first.ExplicitFunction.Evaluate(xy)) +
            xy.Length.Multiply(blend_factor).Min(Scalar.One).Multiply(second.ExplicitFunction.Evaluate(xy)),
            Combine(first.ComparisonOperator, second.ComparisonOperator)
        );
    }

    public <#=typename#> Negate() => new(v => ExplicitFunction.Evaluate(-v), ComparisonOperator);

    public <#=typename#> Shift(<#=vecname#> offset) => new(v => ExplicitFunction.Evaluate(v - offset), ComparisonOperator);

    public <#=typename#> Scale(Scalar factor) => new(v => ExplicitFunction.Evaluate(v / factor), ComparisonOperator);

    public static <#=typename#> operator +(<#=typename#> function) => function;

    public static <#=typename#> operator -(<#=typename#> function) => function.Negate();

    public static <#=typename#> operator +(<#=vecname#> offset, <#=typename#> function) => function.Shift(offset);

    public static <#=typename#> operator +(<#=typename#> function, <#=vecname#> offset) => function.Shift(offset);

    public static <#=typename#> operator -(<#=typename#> function, <#=vecname#> offset) => function.Shift(-offset);

    public static <#=typename#> operator *(Scalar scale, <#=typename#> function) => function.Scale(scale);

    public static <#=typename#> operator *(<#=typename#> function, Scalar scale) => function.Scale(scale);

    public static <#=typename#> operator /(<#=typename#> function, Scalar scale) => function.Scale(scale.MultiplicativeInverse);
}
<#
    }
#>