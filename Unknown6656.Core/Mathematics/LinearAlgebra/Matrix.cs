///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2022-09-05 10:58:46.393099              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System;

using Unknown6656.Mathematics.Analysis;
using Unknown6656.Generics;
using Unknown6656.Common;
using Unknown6656.IO;

using static System.Math;

namespace Unknown6656.Mathematics.LinearAlgebra;

// TODO: schatten-p-norm

#region Matrix2

/// <summary>
/// Represents a square 2x2 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix2
    : Algebra<Scalar>.IMatrix<Vector2, Matrix2>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix2, MatrixNM>
    , INative<Matrix2>
    , IEnumerable<Vector2>
    // , Function<Matrix2, Vector2>
    , IEnumerable<Scalar>
    , IComparable<Matrix2>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix2>
    , IModulusOperators<Matrix2, Scalar, Matrix2>
    , IMultiplyOperators<Matrix2, Matrix2, Matrix2>
    , IMultiplyOperators<Scalar, Matrix2, Matrix2>
    , IMultiplyOperators<Matrix2, Scalar, Matrix2>
    , IDivisionOperators<Matrix2, Scalar, Matrix2>
    , IMultiplyOperators<Vector2, Matrix2, Vector2>
    , IMultiplyOperators<Matrix2, Vector2, Vector2>
    , IDecrementOperators<Matrix2>
    , IAdditionOperators<Matrix2, Matrix2, Matrix2>
    , ISubtractionOperators<Matrix2, Matrix2, Matrix2>
    , IUnaryPlusOperators<Matrix2, Matrix2>
    , IUnaryNegationOperators<Matrix2, Matrix2>
    , IAdditiveIdentity<Matrix2, Matrix2>
    , IMultiplicativeIdentity<Matrix2, Matrix2>
    , IComparisonOperators<Matrix2, Matrix2>
    , IEqualityOperators<Matrix2, Matrix2>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector2 _c0;
    private readonly Vector2 _c1;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (2, 2);

    /// <summary>
    /// The 2x2 zero matrix
    /// </summary>
    public static Matrix2 Zero { get; } = new Matrix2(0);

    /// <summary>
    /// The 2x2 identity (unit) matrix
    /// </summary>
    public static Matrix2 Identity { get; } = new(1);

    static Matrix2 IRing<Matrix2>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix2"/>.
    /// </summary>
    public static Matrix2EqualityComparer EqualityComparer { get; } = new Matrix2EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix2"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix2);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector2 this[int column] => GetColumn(column);

    public readonly Vector2 this[Index column] => this[column.GetOffset(2)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix2 this[int column, in Vector2 value] => SetColumn(column, value);

    public readonly Matrix2 this[Index column, in Vector2 value] => this[column.GetOffset(2), value];

    public readonly Matrix2 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix2 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 2 || column < 0 || column >= 2)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 1.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix2(scalars);
        }
    }

    public readonly Matrix2 this[Index column, Index row, Scalar value] => this[column.GetOffset(2), row.GetOffset(2), value];

    public readonly Matrix2 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Scalar> Minors
    {
        get
        {
            Scalar[,] c = Coefficients;

            return new ReadOnlyIndexer<int, int, Scalar>((col, row) => (col, row) switch {
                (0, 0) => c[1, 1],
                (0, 1) => c[1, 0],
                (1, 0) => c[0, 1],
                (1, 1) => c[0, 0],
                _ => throw new ArgumentOutOfRangeException($"The indices ({col}, {row}) are invalid for this matrix: The indices must be values between (inclusive) zero and one.")
            });
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (2, 2);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[2, 2]
    {
        { _c0[0], _c0[1] },
        { _c1[0], _c1[1] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[4] { _c0[0], _c1[0], _c0[1], _c1[1] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector2 MainDiagonal => (_c0[0], _c1[1]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector2[] Columns => new[] { _c0, _c1 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector2[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix2 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix2 Transposed => (
        _c0[0], _c0[1],
        _c1[0], _c1[1]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix2::Inverse' instead.")]
    public readonly Matrix2 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix2 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix2 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector2[] vs = Columns;

            for (int i = 0; i < 2; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        _c0[0] * _c1[1] - _c1[0] * _c0[1];

    public readonly Matrix2 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix2 m = (
                    _c1[1], -_c0[1],
                -_c1[0],  _c0[0]
            );
            return m * det;
        }
    }

    public readonly Polynomial CharacteristicPolynomial => new Polynomial(Determinant, - _c0[0] - _c1[1], 1);

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector2[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector2.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 2x2 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector2[] rows = Rows;

            for (int i = 0; i < 2; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 2; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 2; ++c)
                for (int r = 0; r < 2; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 2; ++c)
                for (int r = c + 1; r < 2; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix2 ctc = Transposed * this;

            return (ctc - new Matrix2(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        Determinant > 0;

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 2x2-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix2(Scalar scale)
        : this(scale, 0,
               0, scale)
    {
    }

    /// <summary>
    /// Creates a new 2x2-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    public Matrix2(Scalar diag_0, Scalar diag_1)
        : this(diag_0, 0,
               0, diag_1)
    {
    }

    public Matrix2(Scalar s_0_0, Scalar s_1_0, Scalar s_0_1, Scalar s_1_1)
        : this(new Vector2(s_0_0, s_0_1),
               new Vector2(s_1_0, s_1_1))
    {
    }

    public Matrix2(Scalar[] values)
        : this(values[0], values[1],
               values[2], values[3])
    {
    }

    public Matrix2(Scalar[,] values)
        : this(values[0, 0], values[1, 0],
               values[0, 1], values[1, 1])
    {
    }

    public Matrix2(Scalar[][] values)
        : this(values[0][0], values[1][0],
               values[0][1], values[1][1])
    {
    }

    public Matrix2(in Matrix2 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix2(in Matrix3 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix4 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix5 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix6 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix7 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix8 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix9 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in Matrix10 matrix)
        : this(new Vector2(matrix[0]), new Vector2(matrix[1]))
    {
    }

    public Matrix2(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix2(Matrix2* matrix)
        : this(*matrix)
    {
    }

    public Matrix2(Scalar* values)
        : this(values[0], values[1],
               values[2], values[3])
    {
    }

    public Matrix2(Vector2* columns)
        : this(columns[0], columns[1])
    {
    }

    public Matrix2(IEnumerable<Vector2> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix2(Vector2[] columns)
        : this(columns[0], columns[1])
    {
    }

    public Matrix2(Vector2 v0, Vector2 v1)
    {
        _c0 = v0;
        _c1 = v1;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix2 Negate() => new(-_c0, -_c1);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix2 Add(in Matrix2 second) => new(_c0 + second._c0, _c1 + second._c1);

    public readonly Matrix2 Add(params Matrix2[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix2 Add(Scalar Scalar) => Add(new Matrix2(Scalar));

    public readonly Matrix2 Increment() => Add(1);

    public readonly Matrix2 Decrement() => Add(-1);

    public readonly Matrix2 Subtract(in Matrix2 second) => Add(second.Negate());

    public readonly Matrix2 Subtract(params Matrix2[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix2 Subtract(Scalar scalar) => Add(scalar.Negate());


    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix2 Multiply(in Matrix2 second)
    {
        Vector2[] A = Rows;
        Vector2[] B = second.Columns;
        Scalar[,] C = new Scalar[2, 2];

        for (int r = 0; r < 2; ++r)
            for (int c = 0; c < 2; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix2(C);
    }

    public readonly Matrix2 Multiply(params Matrix2[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector2 Multiply(in Vector2 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1],
        _c0[1] * vector[0] + _c1[1] * vector[1]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix2 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor);

    public readonly Matrix2 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix2 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix2 r = Identity;
        Matrix2 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix2 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix2 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor);

    public readonly Matrix2 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix2 result = this;
        Matrix2 exponent = this;
        Matrix2 squared = Multiply(this);
        Matrix2 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix2 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix2 result = Identity;
        Matrix2 exponent = this;
        Matrix2 squared = Multiply(this);
        Matrix2 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix2 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix2 result = Identity;
        Matrix2 exponent = this;
        Matrix2 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix2 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix2 ComponentwiseDivide(in Matrix2 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1));

    public readonly Matrix2 ComponentwiseMultiply(in Matrix2 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1));

    public readonly Matrix2 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function));

    public readonly Matrix2 ComponentwiseApply(Matrix2 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function));

    public readonly Matrix2 ComponentwiseApply(Matrix2 second, Matrix2 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function));

    public readonly Matrix2 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix2 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high));

    public readonly Matrix2 LinearInterpolate(in Matrix2 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix2 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 2; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 0 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
        => new Algebra<Scalar>.IMatrix[1] { _c0[0] };

    internal readonly Matrix2 GetLinearIndependentForm()
    {
        Matrix2 m = this;

        for (int row = 0; row < 2; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 2; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 2; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector2</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace2 Solve(Vector2 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector2 x = vector;

            for (int i = 0; i < 2; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 2; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector2 x = vector;

            for (int i = 1; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix2 P, Matrix2 L, Matrix2 U) = PLUDecompose();
        VectorSpace2 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace2(SolveCG(vector));
    }

    public readonly VectorSpace2 Solve(VectorSpace2 vectorspace)
    {
        VectorSpace2 result = VectorSpace2.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace2 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector2, Matrix2>.Solve(Vector2 vector, out Vector2 solution)
    {
        VectorSpace2 space = Solve(vector);
        solution = Vector2.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector2 SolveCG(Vector2 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector2 x = vector;
        Vector2 r = vector - Multiply(vector);
        Vector2 d = r;

        for (int i = 0; i < 2; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector2 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector2 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix2 m = this;
        Vector2 v = vector;

        for (int row = 0; row < 2; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 2; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 2; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 1; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector2[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector2 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector2[] vectors = pairs.Select(p => p.vec).Distinct(Vector2.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector2 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector2 vec, Scalar val)[] pairs = new (Vector2, Scalar)[2];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 2; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector2 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector2 v_old = default;
        Vector2 v_new = Vector2.GetRandomCartesianUnitVector();
        Vector2 v_init = v_new;
        Matrix2 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector2 w = default;

        while ((w * v_init).IsZero)
            w = Vector2.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace2 GetEigenspace(Scalar eigenvalue) => VectorSpace2.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix2 P, Matrix2 S, Matrix2 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector2 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix2 P = new Matrix2(pairs[0].v, pairs[1].v);
        Matrix2 S = new Matrix2(pairs[0].λ, pairs[1].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix2 P, Matrix2 L, Matrix2 U) PLUDecompose()
    {
        int[] perm = { 0, 1 };
        Matrix2 U = Identity;
        Matrix2 L = this;

        for (int i = 0; i < 1; ++i)
        {
            Vector2 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 2; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 2; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Scalar A, Scalar C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(1);

        return ((Scalar)A, (Scalar)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 2)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 2.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix2 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        var (a, _, b, c) = this;
        Scalar u = a.Sqrt();

        return (
            u, 0,
            (c - u).Sqrt(), b / u
        );
    }

    public readonly (Matrix2 Q, Matrix2 R) QRDecompose()
    {
        Matrix2 A = this;
        (Vector2 v0_0, Vector2 v0_1) = A;
        Vector2 v0 = v0_0 + new Vector2(v0_0[0].Sign * v0_0.Length, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;

        Matrix2 R = (
            v0_0[0], v0_1[0],
            0, v0_1[1]
        );
        Matrix2 Q = v0.HouseholderMatrix;


        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix2 Q, Matrix2 R) QRDecomposeUnstable()
    {
        Matrix2 H0;
        Matrix2 A0 = this;
        Vector2 v0 = A0[0];

        v0 += new Vector2(A0[0, 0].Sign * v0.Length, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Scalar A1 = -A0[1, 1]; // TODO : ????????
        Matrix2[] H = new Matrix2[2];

        H[0] = H0;
        H[1] = H[1][1, 1, -1];

        return (
            Q: H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed
        );
    }

    public readonly (Matrix2 U, Matrix2 D) IwasawaDecompose()
    {
        Matrix2 ONB = OrthonormalBasis;
        Matrix2 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace2 GetKrylovSpace(Vector2 vector) => VectorSpace2.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix2 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance);

    public readonly bool Is(Matrix2 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix2 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix2 v && Equals(v);

    public readonly bool Equals(Matrix2 other) => Is(other);

    public readonly int CompareTo(Matrix2 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix2 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix2)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 2x2-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 2x2-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Creates the homogeneous 3x3 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 3x3 transformation matrix.</returns>
    public readonly Matrix3 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        Vector3.UnitVectors[2]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector2> ToIsomorphism()
    {
        Matrix2 copy = this;

        return new Function<Vector2>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector2> GetEnumerator() => ((IEnumerable<Vector2>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_0_1, out Scalar x_1_1) =>
        (x_0_0, x_1_0, x_0_1, x_1_1) = (_c0[0], _c1[0], _c0[1], _c1[1]);

    public readonly void Deconstruct(out Vector2 v0, out Vector2 v1) =>
        (v0, v1) = (_c0, _c1);

    public readonly object Clone() => new Matrix2(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector2 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 1.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix2 SetColumn(int column, in Vector2 vector)
    {
        if (column < 0 || column >= 2)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 1.");

        Vector2[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..2);

    public readonly Matrix2 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..2, values);

    public readonly Matrix2 SwapColumns(int src_col, int dst_col)
    {
        Vector2 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix2 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix2 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix2 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector2 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix2 SetRow(int row, in Vector2 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..2, rows);

    public readonly Matrix2 SetRows(Range rows, in MatrixNM values) => SetRegion(0..2, rows, values);

    public readonly Matrix2 SwapRows(int src_row, int dst_row)
    {
        Vector2 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix2 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix2 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix2 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(2);
        int[] idx_r = rows.GetOffsets(2);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix2 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(2);
        int[] idx_r = rows.GetOffsets(2);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix2(t);
    }


    #endregion
    #region STATIC METHODS

    public static Matrix2 Add(Matrix2 m1, Matrix2 m2) => m1.Add(m2);

    public static Matrix2 Subtract(Matrix2 m1, Matrix2 m2) => m1.Subtract(m2);

    public static Matrix2 Multiply(Matrix2 m1, Matrix2 m2) => m1.Multiply(m2);

    public static Vector2 Multiply(Matrix2 m, Vector2 v) => m.Multiply(v);

    public static Matrix2 Multiply(Matrix2 m, Scalar s) => m.Multiply(s);

    public static Matrix2 Divide(Matrix2 m, Scalar s) => m.Divide(s);

    public static Matrix2 Exp(Matrix2 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix2 Sin(Matrix2 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix2 Cos(Matrix2 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix2 CracovianProduct(in Matrix2 first, in Matrix2 second) => second.Transposed.Multiply(in second);

    public static Matrix2 HadamardProduct(in Matrix2 first, in Matrix2 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix2 first, Matrix2 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix2 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[2, 2];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix2 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix2 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[2, 2];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix2 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix2 DiagonalMatrix(in Vector2 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1]);

    public static Matrix2 DiagonalMatrix(Scalar d0, Scalar d1) => (
        d0, 0,
        0, d1
    );
    
    public static Matrix2 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5,
        a.Power(1) * .5, 1
    );

    public static Matrix2 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix2 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 2))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 1.", nameof(column_indices));

        Vector2[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix2 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix2 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix2 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix2 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix2 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 2 || arr.GetLength(1) < 2 ? throw new ArgumentException("The array must have a minimum size of 2x2.", nameof(arr)) : new Matrix2(arr);

    public static Matrix2 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 4 => throw new ArgumentException("The array must have a minimum length of 4.", nameof(arr)),
        _ => new Matrix2(
            arr[ 0], arr[ 1],
            arr[ 2], arr[ 3]
        )
    };

    public static Matrix2 FromRows(in Vector2[] arr) => FromColumns(arr).Transposed;

    public static Matrix2 FromColumns(in Vector2[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 2 } => new Matrix2(
            arr[0][0], arr[1][0],
            arr[0][1], arr[1][1]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 2.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix2 m1, Matrix2 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix2 m1, Matrix2 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix2 operator +(in Matrix2 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix2 operator -(in Matrix2 m) => m.Negate();

    public static Matrix2 operator +(Scalar f, in Matrix2 m) => m.Add(f);

    public static Matrix2 operator +(in Matrix2 m, Scalar f) => m.Add(f);

    public static Matrix2 operator -(Scalar f, in Matrix2 m) => new Matrix2(f).Subtract(in m);

    public static Matrix2 operator -(in Matrix2 m, Scalar f) => m.Subtract(f);

    public static Matrix2 operator ++(in Matrix2 m) => m.Increment();

    public static Matrix2 operator --(in Matrix2 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix2 operator +(in Matrix2 m1, in Matrix2 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix2 operator -(in Matrix2 m1, in Matrix2 m2) => m1.Subtract(in m2);

    public static Vector2 operator *(in Matrix2 m, in Vector2 v) => m.Multiply(in v);

    public static Matrix2 operator *(in Matrix2 m1, in Matrix2 m2) => m1.Multiply(in m2);

    public static Matrix2 operator *(in Matrix2 m, Scalar f) => m.Multiply(f);

    public static Matrix2 operator *(Scalar f, in Matrix2 m) => m.Multiply(f);

    public static Matrix2 operator ^(in Matrix2 m, int c) => m.Power(c);

    public static Matrix2 operator ^(in Matrix2 m1, in Matrix2 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace2 operator |(Matrix2 A, Vector2 b) => A.Solve(b);

    public static VectorSpace2 operator |(Matrix2 A, VectorSpace2 b) => A.Solve(b);

    public static Matrix2 operator /(Matrix2 m1, Matrix2 m2) => m1.Multiply(m2.Inverse);

    public static Matrix2 operator /(in Matrix2 m, Scalar f) => m.Divide(f);

    public static Matrix2 operator %(in Matrix2 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector2 x0, Vector2 x1) (in Matrix2 m) => (m[0], m[1]);

    public static implicit operator Matrix2((Vector2 x0, Vector2 x1) t) => new(t.x0, t.x1);
/*
    public static explicit operator ((Scalar r0, Scalar r1) c0, (Scalar r0, Scalar r1) c1) (in Matrix2 m) => (m[0], m[1]);

    public static explicit operator Matrix2(in ((Scalar r0, Scalar r1) c0, (Scalar r0, Scalar r1) c1) t) => new(t.c0, t.c1);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_0_1, Scalar x_1_1) (in Matrix2 m) => (
        m._c0[0], m._c1[0],
        m._c0[1], m._c1[1]
    );

    public static implicit operator Matrix2(in (Scalar x_0_0, Scalar x_1_0, Scalar x_0_1, Scalar x_1_1) t) => new(
        t.x_0_0, t.x_1_0,
        t.x_0_1, t.x_1_1
    );

    public static explicit operator Matrix2(Scalar m) => new(m);

    public static implicit operator Matrix2(in Vector2[] arr) => new(arr);

    public static implicit operator Vector2[](in Matrix2 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix2 m) => m.ToArray();

    public static implicit operator Matrix2(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix2 m) => m.Coefficients;

    public static implicit operator Matrix2(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix2 m) => new(m.Coefficients);

    public static explicit operator Matrix2(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix2 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix2>(m);

    public static implicit operator Function<Vector2>(in Matrix2 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix2EqualityComparer
        : IEqualityComparer<Matrix2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix2 x, Matrix2 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix2 obj) => obj.GetHashCode();
    }
}

public static class Matrix2Extensions
{
    public static Matrix2 Sum(this IEnumerable<Matrix2> matrices) => Matrix2.Zero.Add(matrices.ToArray());

    public static Matrix2 Average(this IEnumerable<Matrix2> matrices)
    {
        Matrix2 mat = Matrix2.Zero;
        long count = 0;

        foreach (Matrix2 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix3

/// <summary>
/// Represents a square 3x3 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix3
    : Algebra<Scalar>.IMatrix<Vector3, Matrix3>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix3, MatrixNM>
    , INative<Matrix3>
    , IEnumerable<Vector3>
    // , Function<Matrix3, Vector3>
    , IEnumerable<Scalar>
    , IComparable<Matrix3>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix3>
    , IModulusOperators<Matrix3, Scalar, Matrix3>
    , IMultiplyOperators<Matrix3, Matrix3, Matrix3>
    , IMultiplyOperators<Scalar, Matrix3, Matrix3>
    , IMultiplyOperators<Matrix3, Scalar, Matrix3>
    , IDivisionOperators<Matrix3, Scalar, Matrix3>
    , IMultiplyOperators<Vector3, Matrix3, Vector3>
    , IMultiplyOperators<Matrix3, Vector3, Vector3>
    , IDecrementOperators<Matrix3>
    , IAdditionOperators<Matrix3, Matrix3, Matrix3>
    , ISubtractionOperators<Matrix3, Matrix3, Matrix3>
    , IUnaryPlusOperators<Matrix3, Matrix3>
    , IUnaryNegationOperators<Matrix3, Matrix3>
    , IAdditiveIdentity<Matrix3, Matrix3>
    , IMultiplicativeIdentity<Matrix3, Matrix3>
    , IComparisonOperators<Matrix3, Matrix3>
    , IEqualityOperators<Matrix3, Matrix3>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector3 _c0;
    private readonly Vector3 _c1;
    private readonly Vector3 _c2;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (3, 3);

    /// <summary>
    /// The 3x3 zero matrix
    /// </summary>
    public static Matrix3 Zero { get; } = new Matrix3(0);

    /// <summary>
    /// The 3x3 identity (unit) matrix
    /// </summary>
    public static Matrix3 Identity { get; } = new(1);

    static Matrix3 IRing<Matrix3>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix3"/>.
    /// </summary>
    public static Matrix3EqualityComparer EqualityComparer { get; } = new Matrix3EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix3"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix3);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector3 this[int column] => GetColumn(column);

    public readonly Vector3 this[Index column] => this[column.GetOffset(3)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix3 this[int column, in Vector3 value] => SetColumn(column, value);

    public readonly Matrix3 this[Index column, in Vector3 value] => this[column.GetOffset(3), value];

    public readonly Matrix3 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix3 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 3 || column < 0 || column >= 3)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 2.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix3(scalars);
        }
    }

    public readonly Matrix3 this[Index column, Index row, Scalar value] => this[column.GetOffset(3), row.GetOffset(3), value];

    public readonly Matrix3 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix2> Minors => new ReadOnlyIndexer<int, int, Matrix2>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (3, 3);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[3, 3]
    {
        { _c0[0], _c0[1], _c0[2] },
        { _c1[0], _c1[1], _c1[2] },
        { _c2[0], _c2[1], _c2[2] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[9] { _c0[0], _c1[0], _c2[0], _c0[1], _c1[1], _c2[1], _c0[2], _c1[2], _c2[2] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector3 MainDiagonal => (_c0[0], _c1[1], _c2[2]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector3[] Columns => new[] { _c0, _c1, _c2 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector3[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix3 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix3 Transposed => (
        _c0[0], _c0[1], _c0[2],
        _c1[0], _c1[1], _c1[2],
        _c2[0], _c2[1], _c2[2]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix3::Inverse' instead.")]
    public readonly Matrix3 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix3 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix3 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector3[] vs = Columns;

            for (int i = 0; i < 3; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        _c0[0] * (_c1[1] * _c2[2] - _c2[1] * _c1[2])
        - _c1[0] * (_c0[1] * _c2[2] - _c2[1] * _c0[2])
        + _c2[0] * (_c0[1] * _c1[2] - _c1[1] * _c0[2]);

    public readonly Matrix3 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix3 m = (
            // TODO : verify the following code
                + (_c1[1] * _c2[2] - _c2[1] * _c1[2]),
                - (_c1[0] * _c2[2] - _c2[0] * _c1[2]),
                + (_c1[0] * _c2[1] - _c2[0] * _c1[1]),
                - (_c0[1] * _c2[2] - _c2[1] * _c0[2]),
                + (_c0[0] * _c2[2] - _c2[0] * _c0[2]),
                - (_c0[0] * _c2[1] - _c2[0] * _c0[1]),
                + (_c0[1] * _c1[2] - _c1[1] * _c0[2]),
                - (_c0[0] * _c1[2] - _c1[0] * _c0[2]),
                + (_c0[0] * _c1[1] - _c1[0] * _c0[1])
            );
            return m * det;
        }
    }

    /*
             | a b c |                    | a-λ  b   c  |
        φ := | d e f |       CP_φ(λ) = det|  d  e-λ  f  | = (a-λ)[MINOR @ 0,0] - λ(gc + db) - gbf - gce - dbi + dhc
             | g h i |                    |  g   h  i-λ |
                                                          = - λ³
                                                            + λ²(a + e + i)
                                                            + λ(fh + cg + bd - ae - ai - ei)
                                                            + (-afh - ecg - ibd + aei + cdh + bfg)
    */
    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var (a, b, c,
                    d, e, f,
                    g, h, i) = this;

            return new Polynomial(
                - a * f * h
                - e * c * g
                - i * b * d
                + a * e * i
                + c * d * h
                + b * f * g,
                + f * h
                + c * g
                + b * d
                - a * e
                - a * i
                - e * i,
                a + e + i,
                -1
            );
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector3[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector3.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 3x3 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector3[] rows = Rows;

            for (int i = 0; i < 3; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 3; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 3; ++c)
                for (int r = 0; r < 3; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 3; ++c)
                for (int r = c + 1; r < 3; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix3 ctc = Transposed * this;

            return (ctc - new Matrix3(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 3x3-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix3(Scalar scale)
        : this(scale, 0, 0,
               0, scale, 0,
               0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 3x3-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    public Matrix3(Scalar diag_0, Scalar diag_1, Scalar diag_2)
        : this(diag_0, 0, 0,
               0, diag_1, 0,
               0, 0, diag_2)
    {
    }

    public Matrix3(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2)
        : this(new Vector3(s_0_0, s_0_1, s_0_2),
               new Vector3(s_1_0, s_1_1, s_1_2),
               new Vector3(s_2_0, s_2_1, s_2_2))
    {
    }

    public Matrix3(Scalar[] values)
        : this(values[0], values[1], values[2],
               values[3], values[4], values[5],
               values[6], values[7], values[8])
    {
    }

    public Matrix3(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0],
               values[0, 1], values[1, 1], values[2, 1],
               values[0, 2], values[1, 2], values[2, 2])
    {
    }

    public Matrix3(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0],
               values[0][1], values[1][1], values[2][1],
               values[0][2], values[1][2], values[2][2])
    {
    }

    public Matrix3(in Matrix2 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), Vector3.Zero)
    {
    }

    public Matrix3(in Matrix3 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix3(in Matrix4 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix5 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix6 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix7 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix8 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix9 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in Matrix10 matrix)
        : this(new Vector3(matrix[0]), new Vector3(matrix[1]), new Vector3(matrix[2]))
    {
    }

    public Matrix3(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix3(Matrix3* matrix)
        : this(*matrix)
    {
    }

    public Matrix3(Scalar* values)
        : this(values[0], values[1], values[2],
               values[3], values[4], values[5],
               values[6], values[7], values[8])
    {
    }

    public Matrix3(Vector3* columns)
        : this(columns[0], columns[1], columns[2])
    {
    }

    public Matrix3(IEnumerable<Vector3> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix3(Vector3[] columns)
        : this(columns[0], columns[1], columns[2])
    {
    }

    public Matrix3(Vector3 v0, Vector3 v1, Vector3 v2)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix3 Negate() => new(-_c0, -_c1, -_c2);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix3 Add(in Matrix3 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2);

    public readonly Matrix3 Add(params Matrix3[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix3 Add(Scalar Scalar) => Add(new Matrix3(Scalar));

    public readonly Matrix3 Increment() => Add(1);

    public readonly Matrix3 Decrement() => Add(-1);

    public readonly Matrix3 Subtract(in Matrix3 second) => Add(second.Negate());

    public readonly Matrix3 Subtract(params Matrix3[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix3 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector2 HomogeneousMultiply(in Vector2 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix3 Multiply(in Matrix3 second)
    {
        Vector3[] A = Rows;
        Vector3[] B = second.Columns;
        Scalar[,] C = new Scalar[3, 3];

        for (int r = 0; r < 3; ++r)
            for (int c = 0; c < 3; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix3(C);
    }

    public readonly Matrix3 Multiply(params Matrix3[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector3 Multiply(in Vector3 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix3 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor);

    public readonly Matrix3 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix3 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix3 r = Identity;
        Matrix3 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix3 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix3 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor);

    public readonly Matrix3 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix3 result = this;
        Matrix3 exponent = this;
        Matrix3 squared = Multiply(this);
        Matrix3 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix3 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix3 result = Identity;
        Matrix3 exponent = this;
        Matrix3 squared = Multiply(this);
        Matrix3 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix3 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix3 result = Identity;
        Matrix3 exponent = this;
        Matrix3 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix3 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix3 ComponentwiseDivide(in Matrix3 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2));

    public readonly Matrix3 ComponentwiseMultiply(in Matrix3 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2));

    public readonly Matrix3 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function));

    public readonly Matrix3 ComponentwiseApply(Matrix3 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function));

    public readonly Matrix3 ComponentwiseApply(Matrix3 second, Matrix3 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function));

    public readonly Matrix3 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix3 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high));

    public readonly Matrix3 LinearInterpolate(in Matrix3 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix3 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 3; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 1 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
        => new Algebra<Scalar>.IMatrix[] { _c0[0], ToMatrix2() };

    internal readonly Matrix3 GetLinearIndependentForm()
    {
        Matrix3 m = this;

        for (int row = 0; row < 3; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 3; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 3; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector3</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace3 Solve(Vector3 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector3 x = vector;

            for (int i = 0; i < 3; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 3; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector3 x = vector;

            for (int i = 2; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix3 P, Matrix3 L, Matrix3 U) = PLUDecompose();
        VectorSpace3 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace3(SolveCG(vector));
    }

    public readonly VectorSpace3 Solve(VectorSpace3 vectorspace)
    {
        VectorSpace3 result = VectorSpace3.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace3 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector3, Matrix3>.Solve(Vector3 vector, out Vector3 solution)
    {
        VectorSpace3 space = Solve(vector);
        solution = Vector3.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector3 SolveCG(Vector3 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector3 x = vector;
        Vector3 r = vector - Multiply(vector);
        Vector3 d = r;

        for (int i = 0; i < 3; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector3 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector3 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix3 m = this;
        Vector3 v = vector;

        for (int row = 0; row < 3; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 3; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 3; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 2; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector3[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector3 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector3[] vectors = pairs.Select(p => p.vec).Distinct(Vector3.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector3 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector3 vec, Scalar val)[] pairs = new (Vector3, Scalar)[3];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 3; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector3 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector3 v_old = default;
        Vector3 v_new = Vector3.GetRandomCartesianUnitVector();
        Vector3 v_init = v_new;
        Matrix3 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector3 w = default;

        while ((w * v_init).IsZero)
            w = Vector3.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace3 GetEigenspace(Scalar eigenvalue) => VectorSpace3.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix3 P, Matrix3 S, Matrix3 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector3 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix3 P = new Matrix3(pairs[0].v, pairs[1].v, pairs[2].v);
        Matrix3 S = new Matrix3(pairs[0].λ, pairs[1].λ, pairs[2].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix3 P, Matrix3 L, Matrix3 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2 };
        Matrix3 U = Identity;
        Matrix3 L = this;

        for (int i = 0; i < 2; ++i)
        {
            Vector3 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 3; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 3; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Scalar A, Matrix2 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(1);

        return ((Scalar)A, (Matrix2)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 3)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 3.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix3 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        var (
            a, _, _,
            b, c, _,
            d, e, f
        ) = this;
        Scalar u = a.Sqrt();
        Scalar v = b / u;
        Scalar x = d / u;
        Scalar w = (c - u).Sqrt();

        return (
            u, 0, 0,
            v, w, 0,
            x, (e - v * w) / x, (f - w).Sqrt()
        );
    }

    public readonly (Matrix3 Q, Matrix3 R) QRDecompose()
    {
        Matrix3 A = this;
        (Vector3 v0_0, Vector3 v0_1, Vector3 v0_2) = A;
        Vector3 v0 = v0_0 + new Vector3(v0_0[0].Sign * v0_0.Length, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;

        Vector2 v1_0 = (v0_1[1], v0_1[2]);
        Vector2 v1_1 = (v0_2[1], v0_2[2]);
        Vector2 v1 = v1_0 + new Vector2(v1_0[0].Sign * v1_0.Length, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;

        Matrix3 R = (
            v0_0[0], v0_1[0], v0_2[0],
            0, v1_0[0], v1_1[0],
            0, 0, v1_1[1]
        );
        Matrix3 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix3 Q, Matrix3 R) QRDecomposeUnstable()
    {
        Matrix3 H0;
        Matrix3 A0 = this;
        Vector3 v0 = A0[0];

        v0 += new Vector3(A0[0, 0].Sign * v0.Length, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix2 H1;
        Matrix2 A1 = A0.Minors[0, 0];
        Vector2 v1 = A1[0];

        v1 += new Vector2(A1[0, 0].Sign * v1.Length, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Scalar A2 = -A1[1, 1]; // TODO : ????????
        Matrix3[] H = new Matrix3[3];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2, 2, -1];

        return (
            Q: H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed
        );
    }

    public readonly (Matrix3 U, Matrix3 D) IwasawaDecompose()
    {
        Matrix3 ONB = OrthonormalBasis;
        Matrix3 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace3 GetKrylovSpace(Vector3 vector) => VectorSpace3.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix3 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance);

    public readonly bool Is(Matrix3 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix3 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix3 v && Equals(v);

    public readonly bool Equals(Matrix3 other) => Is(other);

    public readonly int CompareTo(Matrix3 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix3 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix3)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 3x3-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 3x3-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Creates the homogeneous 4x4 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 4x4 transformation matrix.</returns>
    public readonly Matrix4 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        Vector4.UnitVectors[3]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector3> ToIsomorphism()
    {
        Matrix3 copy = this;

        return new Function<Vector3>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector3> GetEnumerator() => ((IEnumerable<Vector3>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2) =>
        (x_0_0, x_1_0, x_2_0, x_0_1, x_1_1, x_2_1, x_0_2, x_1_2, x_2_2) = (_c0[0], _c1[0], _c2[0], _c0[1], _c1[1], _c2[1], _c0[2], _c1[2], _c2[2]);

    public readonly void Deconstruct(out Vector3 v0, out Vector3 v1, out Vector3 v2) =>
        (v0, v1, v2) = (_c0, _c1, _c2);

    public readonly object Clone() => new Matrix3(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector3 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 2.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix3 SetColumn(int column, in Vector3 vector)
    {
        if (column < 0 || column >= 3)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 2.");

        Vector3[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..3);

    public readonly Matrix3 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..3, values);

    public readonly Matrix3 SwapColumns(int src_col, int dst_col)
    {
        Vector3 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix3 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix3 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix3 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector3 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix3 SetRow(int row, in Vector3 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..3, rows);

    public readonly Matrix3 SetRows(Range rows, in MatrixNM values) => SetRegion(0..3, rows, values);

    public readonly Matrix3 SwapRows(int src_row, int dst_row)
    {
        Vector3 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix3 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix3 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix3 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(3);
        int[] idx_r = rows.GetOffsets(3);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix3 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(3);
        int[] idx_r = rows.GetOffsets(3);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix3(t);
    }

    /// <summary>
    /// Returns the matrix' 2x2-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>2x2-minor</returns>
    public readonly Matrix2 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector2(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix3 Add(Matrix3 m1, Matrix3 m2) => m1.Add(m2);

    public static Matrix3 Subtract(Matrix3 m1, Matrix3 m2) => m1.Subtract(m2);

    public static Matrix3 Multiply(Matrix3 m1, Matrix3 m2) => m1.Multiply(m2);

    public static Vector3 Multiply(Matrix3 m, Vector3 v) => m.Multiply(v);

    public static Matrix3 Multiply(Matrix3 m, Scalar s) => m.Multiply(s);

    public static Matrix3 Divide(Matrix3 m, Scalar s) => m.Divide(s);

    public static Matrix3 Exp(Matrix3 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix3 Sin(Matrix3 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix3 Cos(Matrix3 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix3 CracovianProduct(in Matrix3 first, in Matrix3 second) => second.Transposed.Multiply(in second);

    public static Matrix3 HadamardProduct(in Matrix3 first, in Matrix3 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix3 first, Matrix3 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix3 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[3, 3];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix3 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix3 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[3, 3];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix3 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix3 DiagonalMatrix(in Vector3 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2]);

    public static Matrix3 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2) => (
        d0, 0, 0,
        0, d1, 0,
        0, 0, d2
    );
    
    public static Matrix3 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix3 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix3 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 3))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 2.", nameof(column_indices));

        Vector3[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix3 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix3 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix3 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix3 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix3 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 3 || arr.GetLength(1) < 3 ? throw new ArgumentException("The array must have a minimum size of 3x3.", nameof(arr)) : new Matrix3(arr);

    public static Matrix3 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 9 => throw new ArgumentException("The array must have a minimum length of 9.", nameof(arr)),
        _ => new Matrix3(
            arr[ 0], arr[ 1], arr[ 2],
            arr[ 3], arr[ 4], arr[ 5],
            arr[ 6], arr[ 7], arr[ 8]
        )
    };

    public static Matrix3 FromRows(in Vector3[] arr) => FromColumns(arr).Transposed;

    public static Matrix3 FromColumns(in Vector3[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 3 } => new Matrix3(
            arr[0][0], arr[1][0], arr[2][0],
            arr[0][1], arr[1][1], arr[2][1],
            arr[0][2], arr[1][2], arr[2][2]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 3.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix3 m1, Matrix3 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix3 m1, Matrix3 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix3 operator +(in Matrix3 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix3 operator -(in Matrix3 m) => m.Negate();

    public static Matrix3 operator +(Scalar f, in Matrix3 m) => m.Add(f);

    public static Matrix3 operator +(in Matrix3 m, Scalar f) => m.Add(f);

    public static Matrix3 operator -(Scalar f, in Matrix3 m) => new Matrix3(f).Subtract(in m);

    public static Matrix3 operator -(in Matrix3 m, Scalar f) => m.Subtract(f);

    public static Matrix3 operator ++(in Matrix3 m) => m.Increment();

    public static Matrix3 operator --(in Matrix3 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix3 operator +(in Matrix3 m1, in Matrix3 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix3 operator -(in Matrix3 m1, in Matrix3 m2) => m1.Subtract(in m2);

    public static Vector3 operator *(in Matrix3 m, in Vector3 v) => m.Multiply(in v);

    public static Matrix3 operator *(in Matrix3 m1, in Matrix3 m2) => m1.Multiply(in m2);

    public static Matrix3 operator *(in Matrix3 m, Scalar f) => m.Multiply(f);

    public static Matrix3 operator *(Scalar f, in Matrix3 m) => m.Multiply(f);

    public static Matrix3 operator ^(in Matrix3 m, int c) => m.Power(c);

    public static Matrix3 operator ^(in Matrix3 m1, in Matrix3 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace3 operator |(Matrix3 A, Vector3 b) => A.Solve(b);

    public static VectorSpace3 operator |(Matrix3 A, VectorSpace3 b) => A.Solve(b);

    public static Matrix3 operator /(Matrix3 m1, Matrix3 m2) => m1.Multiply(m2.Inverse);

    public static Matrix3 operator /(in Matrix3 m, Scalar f) => m.Divide(f);

    public static Matrix3 operator %(in Matrix3 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector3 x0, Vector3 x1, Vector3 x2) (in Matrix3 m) => (m[0], m[1], m[2]);

    public static implicit operator Matrix3((Vector3 x0, Vector3 x1, Vector3 x2) t) => new(t.x0, t.x1, t.x2);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2) c0, (Scalar r0, Scalar r1, Scalar r2) c1, (Scalar r0, Scalar r1, Scalar r2) c2) (in Matrix3 m) => (m[0], m[1], m[2]);

    public static explicit operator Matrix3(in ((Scalar r0, Scalar r1, Scalar r2) c0, (Scalar r0, Scalar r1, Scalar r2) c1, (Scalar r0, Scalar r1, Scalar r2) c2) t) => new(t.c0, t.c1, t.c2);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2) (in Matrix3 m) => (
        m._c0[0], m._c1[0], m._c2[0],
        m._c0[1], m._c1[1], m._c2[1],
        m._c0[2], m._c1[2], m._c2[2]
    );

    public static implicit operator Matrix3(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0,
        t.x_0_1, t.x_1_1, t.x_2_1,
        t.x_0_2, t.x_1_2, t.x_2_2
    );

    public static explicit operator Matrix3(Scalar m) => new(m);

    public static implicit operator Matrix3(in Vector3[] arr) => new(arr);

    public static implicit operator Vector3[](in Matrix3 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix3 m) => m.ToArray();

    public static implicit operator Matrix3(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix3 m) => m.Coefficients;

    public static implicit operator Matrix3(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix3 m) => new(m.Coefficients);

    public static explicit operator Matrix3(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix3 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix3>(m);

    public static implicit operator Function<Vector3>(in Matrix3 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix3EqualityComparer
        : IEqualityComparer<Matrix3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix3 x, Matrix3 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix3 obj) => obj.GetHashCode();
    }
}

public static class Matrix3Extensions
{
    public static Matrix3 Sum(this IEnumerable<Matrix3> matrices) => Matrix3.Zero.Add(matrices.ToArray());

    public static Matrix3 Average(this IEnumerable<Matrix3> matrices)
    {
        Matrix3 mat = Matrix3.Zero;
        long count = 0;

        foreach (Matrix3 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix4

/// <summary>
/// Represents a square 4x4 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix4
    : Algebra<Scalar>.IMatrix<Vector4, Matrix4>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix4, MatrixNM>
    , INative<Matrix4>
    , IEnumerable<Vector4>
    // , Function<Matrix4, Vector4>
    , IEnumerable<Scalar>
    , IComparable<Matrix4>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix4>
    , IModulusOperators<Matrix4, Scalar, Matrix4>
    , IMultiplyOperators<Matrix4, Matrix4, Matrix4>
    , IMultiplyOperators<Scalar, Matrix4, Matrix4>
    , IMultiplyOperators<Matrix4, Scalar, Matrix4>
    , IDivisionOperators<Matrix4, Scalar, Matrix4>
    , IMultiplyOperators<Vector4, Matrix4, Vector4>
    , IMultiplyOperators<Matrix4, Vector4, Vector4>
    , IDecrementOperators<Matrix4>
    , IAdditionOperators<Matrix4, Matrix4, Matrix4>
    , ISubtractionOperators<Matrix4, Matrix4, Matrix4>
    , IUnaryPlusOperators<Matrix4, Matrix4>
    , IUnaryNegationOperators<Matrix4, Matrix4>
    , IAdditiveIdentity<Matrix4, Matrix4>
    , IMultiplicativeIdentity<Matrix4, Matrix4>
    , IComparisonOperators<Matrix4, Matrix4>
    , IEqualityOperators<Matrix4, Matrix4>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector4 _c0;
    private readonly Vector4 _c1;
    private readonly Vector4 _c2;
    private readonly Vector4 _c3;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (4, 4);

    /// <summary>
    /// The 4x4 zero matrix
    /// </summary>
    public static Matrix4 Zero { get; } = new Matrix4(0);

    /// <summary>
    /// The 4x4 identity (unit) matrix
    /// </summary>
    public static Matrix4 Identity { get; } = new(1);

    static Matrix4 IRing<Matrix4>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix4"/>.
    /// </summary>
    public static Matrix4EqualityComparer EqualityComparer { get; } = new Matrix4EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix4"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix4);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector4 this[int column] => GetColumn(column);

    public readonly Vector4 this[Index column] => this[column.GetOffset(4)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix4 this[int column, in Vector4 value] => SetColumn(column, value);

    public readonly Matrix4 this[Index column, in Vector4 value] => this[column.GetOffset(4), value];

    public readonly Matrix4 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix4 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 4 || column < 0 || column >= 4)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 3.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix4(scalars);
        }
    }

    public readonly Matrix4 this[Index column, Index row, Scalar value] => this[column.GetOffset(4), row.GetOffset(4), value];

    public readonly Matrix4 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix3> Minors => new ReadOnlyIndexer<int, int, Matrix3>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (4, 4);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[4, 4]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3] },
        { _c1[0], _c1[1], _c1[2], _c1[3] },
        { _c2[0], _c2[1], _c2[2], _c2[3] },
        { _c3[0], _c3[1], _c3[2], _c3[3] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[16] { _c0[0], _c1[0], _c2[0], _c3[0], _c0[1], _c1[1], _c2[1], _c3[1], _c0[2], _c1[2], _c2[2], _c3[2], _c0[3], _c1[3], _c2[3], _c3[3] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector4 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector4[] Columns => new[] { _c0, _c1, _c2, _c3 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector4[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix4 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 2 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix4 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3],
        _c1[0], _c1[1], _c1[2], _c1[3],
        _c2[0], _c2[1], _c2[2], _c2[3],
        _c3[0], _c3[1], _c3[2], _c3[3]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix4::Inverse' instead.")]
    public readonly Matrix4 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix4 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix4 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector4[] vs = Columns;

            for (int i = 0; i < 4; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant;

    public readonly Matrix4 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix4 m = Zero;
            var (m00, m10, m20, m30,
                 m01, m11, m21, m31,
                 m02, m12, m22, m32,
                 m03, m13, m23, m33) = this;

            // TODO : verify the following code
            m00 = (m12 * m23 * m31) - (m13 * m22 * m31) + (m13 * m21 * m32) - (m11 * m23 * m32) - (m12 * m21 * m33) + (m11 * m22 * m33);
            m01 = (m03 * m22 * m31) - (m02 * m23 * m31) - (m03 * m21 * m32) + (m01 * m23 * m32) + (m02 * m21 * m33) - (m01 * m22 * m33);
            m02 = (m02 * m13 * m31) - (m03 * m12 * m31) + (m03 * m11 * m32) - (m01 * m13 * m32) - (m02 * m11 * m33) + (m01 * m12 * m33);
            m03 = (m03 * m12 * m21) - (m02 * m13 * m21) - (m03 * m11 * m22) + (m01 * m13 * m22) + (m02 * m11 * m23) - (m01 * m12 * m23);
            m10 = (m13 * m22 * m30) - (m12 * m23 * m30) - (m13 * m20 * m32) + (m10 * m23 * m32) + (m12 * m20 * m33) - (m10 * m22 * m33);
            m11 = (m02 * m23 * m30) - (m03 * m22 * m30) + (m03 * m20 * m32) - (m00 * m23 * m32) - (m02 * m20 * m33) + (m00 * m22 * m33);
            m12 = (m03 * m12 * m30) - (m02 * m13 * m30) - (m03 * m10 * m32) + (m00 * m13 * m32) + (m02 * m10 * m33) - (m00 * m12 * m33);
            m13 = (m02 * m13 * m20) - (m03 * m12 * m20) + (m03 * m10 * m22) - (m00 * m13 * m22) - (m02 * m10 * m23) + (m00 * m12 * m23);
            m20 = (m11 * m23 * m30) - (m13 * m21 * m30) + (m13 * m20 * m31) - (m10 * m23 * m31) - (m11 * m20 * m33) + (m10 * m21 * m33);
            m21 = (m03 * m21 * m30) - (m01 * m23 * m30) - (m03 * m20 * m31) + (m00 * m23 * m31) + (m01 * m20 * m33) - (m00 * m21 * m33);
            m22 = (m01 * m13 * m30) - (m03 * m11 * m30) + (m03 * m10 * m31) - (m00 * m13 * m31) - (m01 * m10 * m33) + (m00 * m11 * m33);
            m23 = (m03 * m11 * m20) - (m01 * m13 * m20) - (m03 * m10 * m21) + (m00 * m13 * m21) + (m01 * m10 * m23) - (m00 * m11 * m23);
            m30 = (m12 * m21 * m30) - (m11 * m22 * m30) - (m12 * m20 * m31) + (m10 * m22 * m31) + (m11 * m20 * m32) - (m10 * m21 * m32);
            m31 = (m01 * m22 * m30) - (m02 * m21 * m30) + (m02 * m20 * m31) - (m00 * m22 * m31) - (m01 * m20 * m32) + (m00 * m21 * m32);
            m32 = (m02 * m11 * m30) - (m01 * m12 * m30) - (m02 * m10 * m31) + (m00 * m12 * m31) + (m01 * m10 * m32) - (m00 * m11 * m32);
            m33 = (m01 * m12 * m20) - (m02 * m11 * m20) + (m02 * m10 * m21) - (m00 * m12 * m21) - (m01 * m10 * m22) + (m00 * m11 * m22);

            m = (
                m00, m10, m20, m30,
                m01, m11, m21, m31,
                m02, m12, m22, m32,
                m03, m13, m23, m33
            );
            return m * det;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector4[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector4.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 4x4 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector4[] rows = Rows;

            for (int i = 0; i < 4; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 4; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 4; ++c)
                for (int r = 0; r < 4; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 4; ++c)
                for (int r = c + 1; r < 4; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix4 ctc = Transposed * this;

            return (ctc - new Matrix4(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 4x4-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix4(Scalar scale)
        : this(scale, 0, 0, 0,
               0, scale, 0, 0,
               0, 0, scale, 0,
               0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 4x4-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    public Matrix4(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3)
        : this(diag_0, 0, 0, 0,
               0, diag_1, 0, 0,
               0, 0, diag_2, 0,
               0, 0, 0, diag_3)
    {
    }

    public Matrix4(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3)
        : this(new Vector4(s_0_0, s_0_1, s_0_2, s_0_3),
               new Vector4(s_1_0, s_1_1, s_1_2, s_1_3),
               new Vector4(s_2_0, s_2_1, s_2_2, s_2_3),
               new Vector4(s_3_0, s_3_1, s_3_2, s_3_3))
    {
    }

    public Matrix4(Scalar[] values)
        : this(values[0], values[1], values[2], values[3],
               values[4], values[5], values[6], values[7],
               values[8], values[9], values[10], values[11],
               values[12], values[13], values[14], values[15])
    {
    }

    public Matrix4(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3])
    {
    }

    public Matrix4(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0],
               values[0][1], values[1][1], values[2][1], values[3][1],
               values[0][2], values[1][2], values[2][2], values[3][2],
               values[0][3], values[1][3], values[2][3], values[3][3])
    {
    }

    public Matrix4(in Matrix2 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), Vector4.Zero, Vector4.Zero)
    {
    }

    public Matrix4(in Matrix3 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), Vector4.Zero)
    {
    }

    public Matrix4(in Matrix4 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix4(in Matrix5 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in Matrix6 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in Matrix7 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in Matrix8 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in Matrix9 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in Matrix10 matrix)
        : this(new Vector4(matrix[0]), new Vector4(matrix[1]), new Vector4(matrix[2]), new Vector4(matrix[3]))
    {
    }

    public Matrix4(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix4(Matrix4* matrix)
        : this(*matrix)
    {
    }

    public Matrix4(Scalar* values)
        : this(values[0], values[1], values[2], values[3],
               values[4], values[5], values[6], values[7],
               values[8], values[9], values[10], values[11],
               values[12], values[13], values[14], values[15])
    {
    }

    public Matrix4(Vector4* columns)
        : this(columns[0], columns[1], columns[2], columns[3])
    {
    }

    public Matrix4(IEnumerable<Vector4> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix4(Vector4[] columns)
        : this(columns[0], columns[1], columns[2], columns[3])
    {
    }

    public Matrix4(Vector4 v0, Vector4 v1, Vector4 v2, Vector4 v3)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix4 Negate() => new(-_c0, -_c1, -_c2, -_c3);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix4 Add(in Matrix4 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3);

    public readonly Matrix4 Add(params Matrix4[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix4 Add(Scalar Scalar) => Add(new Matrix4(Scalar));

    public readonly Matrix4 Increment() => Add(1);

    public readonly Matrix4 Decrement() => Add(-1);

    public readonly Matrix4 Subtract(in Matrix4 second) => Add(second.Negate());

    public readonly Matrix4 Subtract(params Matrix4[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix4 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector3 HomogeneousMultiply(in Vector3 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix4 Multiply(in Matrix4 second)
    {
        Vector4[] A = Rows;
        Vector4[] B = second.Columns;
        Scalar[,] C = new Scalar[4, 4];

        for (int r = 0; r < 4; ++r)
            for (int c = 0; c < 4; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix4(C);
    }

    public readonly Matrix4 Multiply(params Matrix4[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector4 Multiply(in Vector4 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix4 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor);

    public readonly Matrix4 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix4 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix4 r = Identity;
        Matrix4 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix4 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix4 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor);

    public readonly Matrix4 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix4 result = this;
        Matrix4 exponent = this;
        Matrix4 squared = Multiply(this);
        Matrix4 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix4 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix4 result = Identity;
        Matrix4 exponent = this;
        Matrix4 squared = Multiply(this);
        Matrix4 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix4 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix4 result = Identity;
        Matrix4 exponent = this;
        Matrix4 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix4 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix4 ComponentwiseDivide(in Matrix4 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3));

    public readonly Matrix4 ComponentwiseMultiply(in Matrix4 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3));

    public readonly Matrix4 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function));

    public readonly Matrix4 ComponentwiseApply(Matrix4 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function));

    public readonly Matrix4 ComponentwiseApply(Matrix4 second, Matrix4 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function));

    public readonly Matrix4 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix4 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high));

    public readonly Matrix4 LinearInterpolate(in Matrix4 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix4 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 4; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 2 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3 };
    }

    internal readonly Matrix4 GetLinearIndependentForm()
    {
        Matrix4 m = this;

        for (int row = 0; row < 4; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 4; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 4; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector4</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace4 Solve(Vector4 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector4 x = vector;

            for (int i = 0; i < 4; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 4; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector4 x = vector;

            for (int i = 3; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix4 P, Matrix4 L, Matrix4 U) = PLUDecompose();
        VectorSpace4 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace4(SolveCG(vector));
    }

    public readonly VectorSpace4 Solve(VectorSpace4 vectorspace)
    {
        VectorSpace4 result = VectorSpace4.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace4 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector4, Matrix4>.Solve(Vector4 vector, out Vector4 solution)
    {
        VectorSpace4 space = Solve(vector);
        solution = Vector4.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector4 SolveCG(Vector4 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector4 x = vector;
        Vector4 r = vector - Multiply(vector);
        Vector4 d = r;

        for (int i = 0; i < 4; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector4 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector4 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix4 m = this;
        Vector4 v = vector;

        for (int row = 0; row < 4; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 4; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 4; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 3; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector4[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector4 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector4[] vectors = pairs.Select(p => p.vec).Distinct(Vector4.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector4 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector4 vec, Scalar val)[] pairs = new (Vector4, Scalar)[4];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 4; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector4 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector4 v_old = default;
        Vector4 v_new = Vector4.GetRandomCartesianUnitVector();
        Vector4 v_init = v_new;
        Matrix4 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector4 w = default;

        while ((w * v_init).IsZero)
            w = Vector4.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace4 GetEigenspace(Scalar eigenvalue) => VectorSpace4.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix4 P, Matrix4 S, Matrix4 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector4 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix4 P = new Matrix4(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v);
        Matrix4 S = new Matrix4(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix4 P, Matrix4 L, Matrix4 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3 };
        Matrix4 U = Identity;
        Matrix4 L = this;

        for (int i = 0; i < 3; ++i)
        {
            Vector4 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 4; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 4; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix2 A, Matrix2 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(2);

        return ((Matrix2)A, (Matrix2)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 4)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 4.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix4 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix4 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix4 Q, Matrix4 R) QRDecompose()
    {
        Matrix4 A = this;
        (Vector4 v0_0, Vector4 v0_1, Vector4 v0_2, Vector4 v0_3) = A;
        Vector4 v0 = v0_0 + new Vector4(v0_0[0].Sign * v0_0.Length, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;

        Vector3 v1_0 = (v0_1[1], v0_1[2], v0_1[3]);
        Vector3 v1_1 = (v0_2[1], v0_2[2], v0_2[3]);
        Vector3 v1_2 = (v0_3[1], v0_3[2], v0_3[3]);
        Vector3 v1 = v1_0 + new Vector3(v1_0[0].Sign * v1_0.Length, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;

        Vector2 v2_0 = (v1_1[1], v1_1[2]);
        Vector2 v2_1 = (v1_2[1], v1_2[2]);
        Vector2 v2 = v2_0 + new Vector2(v2_0[0].Sign * v2_0.Length, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;

        Matrix4 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0],
            0, v1_0[0], v1_1[0], v1_2[0],
            0, 0, v2_0[0], v2_1[0],
            0, 0, 0, v2_1[1]
        );
        Matrix4 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix4 Q, Matrix4 R) QRDecomposeUnstable()
    {
        Matrix4 H0;
        Matrix4 A0 = this;
        Vector4 v0 = A0[0];

        v0 += new Vector4(A0[0, 0].Sign * v0.Length, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix3 H1;
        Matrix3 A1 = A0.Minors[0, 0];
        Vector3 v1 = A1[0];

        v1 += new Vector3(A1[0, 0].Sign * v1.Length, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix2 H2;
        Matrix2 A2 = A1.Minors[0, 0];
        Vector2 v2 = A2[0];

        v2 += new Vector2(A2[0, 0].Sign * v2.Length, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Scalar A3 = -A2[1, 1]; // TODO : ????????
        Matrix4[] H = new Matrix4[4];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3, 3, -1];

        return (
            Q: H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed
        );
    }

    public readonly (Matrix4 U, Matrix4 D) IwasawaDecompose()
    {
        Matrix4 ONB = OrthonormalBasis;
        Matrix4 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace4 GetKrylovSpace(Vector4 vector) => VectorSpace4.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix4 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance);

    public readonly bool Is(Matrix4 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix4 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix4 v && Equals(v);

    public readonly bool Equals(Matrix4 other) => Is(other);

    public readonly int CompareTo(Matrix4 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix4 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix4)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 4x4-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 4x4-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Creates the homogeneous 5x5 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 5x5 transformation matrix.</returns>
    public readonly Matrix5 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        Vector5.UnitVectors[4]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector4> ToIsomorphism()
    {
        Matrix4 copy = this;

        return new Function<Vector4>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector4> GetEnumerator() => ((IEnumerable<Vector4>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_0_1, x_1_1, x_2_1, x_3_1, x_0_2, x_1_2, x_2_2, x_3_2, x_0_3, x_1_3, x_2_3, x_3_3) = (_c0[0], _c1[0], _c2[0], _c3[0], _c0[1], _c1[1], _c2[1], _c3[1], _c0[2], _c1[2], _c2[2], _c3[2], _c0[3], _c1[3], _c2[3], _c3[3]);

    public readonly void Deconstruct(out Vector4 v0, out Vector4 v1, out Vector4 v2, out Vector4 v3) =>
        (v0, v1, v2, v3) = (_c0, _c1, _c2, _c3);

    public readonly object Clone() => new Matrix4(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector4 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 3.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix4 SetColumn(int column, in Vector4 vector)
    {
        if (column < 0 || column >= 4)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 3.");

        Vector4[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..4);

    public readonly Matrix4 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..4, values);

    public readonly Matrix4 SwapColumns(int src_col, int dst_col)
    {
        Vector4 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix4 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix4 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix4 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector4 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix4 SetRow(int row, in Vector4 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..4, rows);

    public readonly Matrix4 SetRows(Range rows, in MatrixNM values) => SetRegion(0..4, rows, values);

    public readonly Matrix4 SwapRows(int src_row, int dst_row)
    {
        Vector4 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix4 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix4 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix4 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(4);
        int[] idx_r = rows.GetOffsets(4);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix4 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(4);
        int[] idx_r = rows.GetOffsets(4);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix4(t);
    }

    /// <summary>
    /// Returns the matrix' 3x3-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>3x3-minor</returns>
    public readonly Matrix3 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector3(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix4 Add(Matrix4 m1, Matrix4 m2) => m1.Add(m2);

    public static Matrix4 Subtract(Matrix4 m1, Matrix4 m2) => m1.Subtract(m2);

    public static Matrix4 Multiply(Matrix4 m1, Matrix4 m2) => m1.Multiply(m2);

    public static Vector4 Multiply(Matrix4 m, Vector4 v) => m.Multiply(v);

    public static Matrix4 Multiply(Matrix4 m, Scalar s) => m.Multiply(s);

    public static Matrix4 Divide(Matrix4 m, Scalar s) => m.Divide(s);

    public static Matrix4 Exp(Matrix4 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix4 Sin(Matrix4 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix4 Cos(Matrix4 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix4 CracovianProduct(in Matrix4 first, in Matrix4 second) => second.Transposed.Multiply(in second);

    public static Matrix4 HadamardProduct(in Matrix4 first, in Matrix4 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix4 first, Matrix4 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix4 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[4, 4];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix4 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix4 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[4, 4];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix4 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix4 DiagonalMatrix(in Vector4 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3]);

    public static Matrix4 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3) => (
        d0, 0, 0, 0,
        0, d1, 0, 0,
        0, 0, d2, 0,
        0, 0, 0, d3
    );
    
    public static Matrix4 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix4 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix4 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 4))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 3.", nameof(column_indices));

        Vector4[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix4 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix4 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix4 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix4 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix4 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 4 || arr.GetLength(1) < 4 ? throw new ArgumentException("The array must have a minimum size of 4x4.", nameof(arr)) : new Matrix4(arr);

    public static Matrix4 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 16 => throw new ArgumentException("The array must have a minimum length of 16.", nameof(arr)),
        _ => new Matrix4(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3],
            arr[ 4], arr[ 5], arr[ 6], arr[ 7],
            arr[ 8], arr[ 9], arr[10], arr[11],
            arr[12], arr[13], arr[14], arr[15]
        )
    };

    public static Matrix4 FromRows(in Vector4[] arr) => FromColumns(arr).Transposed;

    public static Matrix4 FromColumns(in Vector4[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 4 } => new Matrix4(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 4.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix4 m1, Matrix4 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix4 m1, Matrix4 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix4 operator +(in Matrix4 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix4 operator -(in Matrix4 m) => m.Negate();

    public static Matrix4 operator +(Scalar f, in Matrix4 m) => m.Add(f);

    public static Matrix4 operator +(in Matrix4 m, Scalar f) => m.Add(f);

    public static Matrix4 operator -(Scalar f, in Matrix4 m) => new Matrix4(f).Subtract(in m);

    public static Matrix4 operator -(in Matrix4 m, Scalar f) => m.Subtract(f);

    public static Matrix4 operator ++(in Matrix4 m) => m.Increment();

    public static Matrix4 operator --(in Matrix4 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix4 operator +(in Matrix4 m1, in Matrix4 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix4 operator -(in Matrix4 m1, in Matrix4 m2) => m1.Subtract(in m2);

    public static Vector4 operator *(in Matrix4 m, in Vector4 v) => m.Multiply(in v);

    public static Matrix4 operator *(in Matrix4 m1, in Matrix4 m2) => m1.Multiply(in m2);

    public static Matrix4 operator *(in Matrix4 m, Scalar f) => m.Multiply(f);

    public static Matrix4 operator *(Scalar f, in Matrix4 m) => m.Multiply(f);

    public static Matrix4 operator ^(in Matrix4 m, int c) => m.Power(c);

    public static Matrix4 operator ^(in Matrix4 m1, in Matrix4 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace4 operator |(Matrix4 A, Vector4 b) => A.Solve(b);

    public static VectorSpace4 operator |(Matrix4 A, VectorSpace4 b) => A.Solve(b);

    public static Matrix4 operator /(Matrix4 m1, Matrix4 m2) => m1.Multiply(m2.Inverse);

    public static Matrix4 operator /(in Matrix4 m, Scalar f) => m.Divide(f);

    public static Matrix4 operator %(in Matrix4 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector4 x0, Vector4 x1, Vector4 x2, Vector4 x3) (in Matrix4 m) => (m[0], m[1], m[2], m[3]);

    public static implicit operator Matrix4((Vector4 x0, Vector4 x1, Vector4 x2, Vector4 x3) t) => new(t.x0, t.x1, t.x2, t.x3);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c3) (in Matrix4 m) => (m[0], m[1], m[2], m[3]);

    public static explicit operator Matrix4(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3) c3) t) => new(t.c0, t.c1, t.c2, t.c3);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3) (in Matrix4 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3]
    );

    public static implicit operator Matrix4(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3
    );

    public static explicit operator Matrix4(Scalar m) => new(m);

    public static implicit operator Matrix4(in Vector4[] arr) => new(arr);

    public static implicit operator Vector4[](in Matrix4 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix4 m) => m.ToArray();

    public static implicit operator Matrix4(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix4 m) => m.Coefficients;

    public static implicit operator Matrix4(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix4 m) => new(m.Coefficients);

    public static explicit operator Matrix4(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix4 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix4>(m);

    public static implicit operator Function<Vector4>(in Matrix4 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix4EqualityComparer
        : IEqualityComparer<Matrix4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix4 x, Matrix4 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix4 obj) => obj.GetHashCode();
    }
}

public static class Matrix4Extensions
{
    public static Matrix4 Sum(this IEnumerable<Matrix4> matrices) => Matrix4.Zero.Add(matrices.ToArray());

    public static Matrix4 Average(this IEnumerable<Matrix4> matrices)
    {
        Matrix4 mat = Matrix4.Zero;
        long count = 0;

        foreach (Matrix4 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix5

/// <summary>
/// Represents a square 5x5 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix5
    : Algebra<Scalar>.IMatrix<Vector5, Matrix5>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix5, MatrixNM>
    , INative<Matrix5>
    , IEnumerable<Vector5>
    // , Function<Matrix5, Vector5>
    , IEnumerable<Scalar>
    , IComparable<Matrix5>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix5>
    , IModulusOperators<Matrix5, Scalar, Matrix5>
    , IMultiplyOperators<Matrix5, Matrix5, Matrix5>
    , IMultiplyOperators<Scalar, Matrix5, Matrix5>
    , IMultiplyOperators<Matrix5, Scalar, Matrix5>
    , IDivisionOperators<Matrix5, Scalar, Matrix5>
    , IMultiplyOperators<Vector5, Matrix5, Vector5>
    , IMultiplyOperators<Matrix5, Vector5, Vector5>
    , IDecrementOperators<Matrix5>
    , IAdditionOperators<Matrix5, Matrix5, Matrix5>
    , ISubtractionOperators<Matrix5, Matrix5, Matrix5>
    , IUnaryPlusOperators<Matrix5, Matrix5>
    , IUnaryNegationOperators<Matrix5, Matrix5>
    , IAdditiveIdentity<Matrix5, Matrix5>
    , IMultiplicativeIdentity<Matrix5, Matrix5>
    , IComparisonOperators<Matrix5, Matrix5>
    , IEqualityOperators<Matrix5, Matrix5>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector5 _c0;
    private readonly Vector5 _c1;
    private readonly Vector5 _c2;
    private readonly Vector5 _c3;
    private readonly Vector5 _c4;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (5, 5);

    /// <summary>
    /// The 5x5 zero matrix
    /// </summary>
    public static Matrix5 Zero { get; } = new Matrix5(0);

    /// <summary>
    /// The 5x5 identity (unit) matrix
    /// </summary>
    public static Matrix5 Identity { get; } = new(1);

    static Matrix5 IRing<Matrix5>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix5"/>.
    /// </summary>
    public static Matrix5EqualityComparer EqualityComparer { get; } = new Matrix5EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix5"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix5);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector5 this[int column] => GetColumn(column);

    public readonly Vector5 this[Index column] => this[column.GetOffset(5)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix5 this[int column, in Vector5 value] => SetColumn(column, value);

    public readonly Matrix5 this[Index column, in Vector5 value] => this[column.GetOffset(5), value];

    public readonly Matrix5 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix5 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 5 || column < 0 || column >= 5)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 4.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix5(scalars);
        }
    }

    public readonly Matrix5 this[Index column, Index row, Scalar value] => this[column.GetOffset(5), row.GetOffset(5), value];

    public readonly Matrix5 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix4> Minors => new ReadOnlyIndexer<int, int, Matrix4>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (5, 5);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[5, 5]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[25] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector5 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector5[] Columns => new[] { _c0, _c1, _c2, _c3, _c4 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector5[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix5 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 3 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix5 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix5::Inverse' instead.")]
    public readonly Matrix5 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix5 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix5 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector5[] vs = Columns;

            for (int i = 0; i < 5; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant;

    public readonly Matrix5 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix5 m = this;
            // TODO : verify the following code
            Matrix5 u = Identity;

            for (int i = 0; i < 5; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 5; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 5; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 5 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector5[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector5.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 5x5 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector5[] rows = Rows;

            for (int i = 0; i < 5; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 5; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 5; ++c)
                for (int r = 0; r < 5; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 5; ++c)
                for (int r = c + 1; r < 5; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix5 ctc = Transposed * this;

            return (ctc - new Matrix5(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 5x5-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix5(Scalar scale)
        : this(scale, 0, 0, 0, 0,
               0, scale, 0, 0, 0,
               0, 0, scale, 0, 0,
               0, 0, 0, scale, 0,
               0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 5x5-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    public Matrix5(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4)
        : this(diag_0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0,
               0, 0, diag_2, 0, 0,
               0, 0, 0, diag_3, 0,
               0, 0, 0, 0, diag_4)
    {
    }

    public Matrix5(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4)
        : this(new Vector5(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4),
               new Vector5(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4),
               new Vector5(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4),
               new Vector5(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4),
               new Vector5(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4))
    {
    }

    public Matrix5(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4],
               values[5], values[6], values[7], values[8], values[9],
               values[10], values[11], values[12], values[13], values[14],
               values[15], values[16], values[17], values[18], values[19],
               values[20], values[21], values[22], values[23], values[24])
    {
    }

    public Matrix5(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4])
    {
    }

    public Matrix5(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4])
    {
    }

    public Matrix5(in Matrix2 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), Vector5.Zero, Vector5.Zero, Vector5.Zero)
    {
    }

    public Matrix5(in Matrix3 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), Vector5.Zero, Vector5.Zero)
    {
    }

    public Matrix5(in Matrix4 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), Vector5.Zero)
    {
    }

    public Matrix5(in Matrix5 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix5(in Matrix6 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), new Vector5(matrix[4]))
    {
    }

    public Matrix5(in Matrix7 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), new Vector5(matrix[4]))
    {
    }

    public Matrix5(in Matrix8 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), new Vector5(matrix[4]))
    {
    }

    public Matrix5(in Matrix9 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), new Vector5(matrix[4]))
    {
    }

    public Matrix5(in Matrix10 matrix)
        : this(new Vector5(matrix[0]), new Vector5(matrix[1]), new Vector5(matrix[2]), new Vector5(matrix[3]), new Vector5(matrix[4]))
    {
    }

    public Matrix5(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix5(Matrix5* matrix)
        : this(*matrix)
    {
    }

    public Matrix5(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4],
               values[5], values[6], values[7], values[8], values[9],
               values[10], values[11], values[12], values[13], values[14],
               values[15], values[16], values[17], values[18], values[19],
               values[20], values[21], values[22], values[23], values[24])
    {
    }

    public Matrix5(Vector5* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4])
    {
    }

    public Matrix5(IEnumerable<Vector5> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix5(Vector5[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4])
    {
    }

    public Matrix5(Vector5 v0, Vector5 v1, Vector5 v2, Vector5 v3, Vector5 v4)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix5 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix5 Add(in Matrix5 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4);

    public readonly Matrix5 Add(params Matrix5[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix5 Add(Scalar Scalar) => Add(new Matrix5(Scalar));

    public readonly Matrix5 Increment() => Add(1);

    public readonly Matrix5 Decrement() => Add(-1);

    public readonly Matrix5 Subtract(in Matrix5 second) => Add(second.Negate());

    public readonly Matrix5 Subtract(params Matrix5[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix5 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector4 HomogeneousMultiply(in Vector4 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix5 Multiply(in Matrix5 second)
    {
        Vector5[] A = Rows;
        Vector5[] B = second.Columns;
        Scalar[,] C = new Scalar[5, 5];

        for (int r = 0; r < 5; ++r)
            for (int c = 0; c < 5; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix5(C);
    }

    public readonly Matrix5 Multiply(params Matrix5[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector5 Multiply(in Vector5 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix5 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor);

    public readonly Matrix5 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix5 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix5 r = Identity;
        Matrix5 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix5 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix5 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor);

    public readonly Matrix5 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix5 result = this;
        Matrix5 exponent = this;
        Matrix5 squared = Multiply(this);
        Matrix5 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix5 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix5 result = Identity;
        Matrix5 exponent = this;
        Matrix5 squared = Multiply(this);
        Matrix5 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix5 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix5 result = Identity;
        Matrix5 exponent = this;
        Matrix5 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix5 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix5 ComponentwiseDivide(in Matrix5 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4));

    public readonly Matrix5 ComponentwiseMultiply(in Matrix5 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4));

    public readonly Matrix5 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function));

    public readonly Matrix5 ComponentwiseApply(Matrix5 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function));

    public readonly Matrix5 ComponentwiseApply(Matrix5 second, Matrix5 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function));

    public readonly Matrix5 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix5 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high));

    public readonly Matrix5 LinearInterpolate(in Matrix5 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix5 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 5; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 3 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4 };
    }

    internal readonly Matrix5 GetLinearIndependentForm()
    {
        Matrix5 m = this;

        for (int row = 0; row < 5; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 5; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 5; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector5</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace5 Solve(Vector5 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector5 x = vector;

            for (int i = 0; i < 5; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 5; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector5 x = vector;

            for (int i = 4; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix5 P, Matrix5 L, Matrix5 U) = PLUDecompose();
        VectorSpace5 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace5(SolveCG(vector));
    }

    public readonly VectorSpace5 Solve(VectorSpace5 vectorspace)
    {
        VectorSpace5 result = VectorSpace5.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace5 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector5, Matrix5>.Solve(Vector5 vector, out Vector5 solution)
    {
        VectorSpace5 space = Solve(vector);
        solution = Vector5.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector5 SolveCG(Vector5 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector5 x = vector;
        Vector5 r = vector - Multiply(vector);
        Vector5 d = r;

        for (int i = 0; i < 5; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector5 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector5 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix5 m = this;
        Vector5 v = vector;

        for (int row = 0; row < 5; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 5; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 5; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 4; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector5[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector5 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector5[] vectors = pairs.Select(p => p.vec).Distinct(Vector5.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector5 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector5 vec, Scalar val)[] pairs = new (Vector5, Scalar)[5];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 5; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector5 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector5 v_old = default;
        Vector5 v_new = Vector5.GetRandomCartesianUnitVector();
        Vector5 v_init = v_new;
        Matrix5 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector5 w = default;

        while ((w * v_init).IsZero)
            w = Vector5.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace5 GetEigenspace(Scalar eigenvalue) => VectorSpace5.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix5 P, Matrix5 S, Matrix5 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector5 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix5 P = new Matrix5(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v);
        Matrix5 S = new Matrix5(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix5 P, Matrix5 L, Matrix5 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4 };
        Matrix5 U = Identity;
        Matrix5 L = this;

        for (int i = 0; i < 4; ++i)
        {
            Vector5 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 5; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 5; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix2 A, Matrix3 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(2);

        return ((Matrix2)A, (Matrix3)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 5)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 5.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix5 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix5 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix5 Q, Matrix5 R) QRDecompose()
    {
        Matrix5 A = this;
        (Vector5 v0_0, Vector5 v0_1, Vector5 v0_2, Vector5 v0_3, Vector5 v0_4) = A;
        Vector5 v0 = v0_0 + new Vector5(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;

        Vector4 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4]);
        Vector4 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4]);
        Vector4 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4]);
        Vector4 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4]);
        Vector4 v1 = v1_0 + new Vector4(v1_0[0].Sign * v1_0.Length, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;

        Vector3 v2_0 = (v1_1[1], v1_1[2], v1_1[3]);
        Vector3 v2_1 = (v1_2[1], v1_2[2], v1_2[3]);
        Vector3 v2_2 = (v1_3[1], v1_3[2], v1_3[3]);
        Vector3 v2 = v2_0 + new Vector3(v2_0[0].Sign * v2_0.Length, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;

        Vector2 v3_0 = (v2_1[1], v2_1[2]);
        Vector2 v3_1 = (v2_2[1], v2_2[2]);
        Vector2 v3 = v3_0 + new Vector2(v3_0[0].Sign * v3_0.Length, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;

        Matrix5 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0],
            0, 0, 0, v3_0[0], v3_1[0],
            0, 0, 0, 0, v3_1[1]
        );
        Matrix5 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix5 Q, Matrix5 R) QRDecomposeUnstable()
    {
        Matrix5 H0;
        Matrix5 A0 = this;
        Vector5 v0 = A0[0];

        v0 += new Vector5(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix4 H1;
        Matrix4 A1 = A0.Minors[0, 0];
        Vector4 v1 = A1[0];

        v1 += new Vector4(A1[0, 0].Sign * v1.Length, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix3 H2;
        Matrix3 A2 = A1.Minors[0, 0];
        Vector3 v2 = A2[0];

        v2 += new Vector3(A2[0, 0].Sign * v2.Length, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix2 H3;
        Matrix2 A3 = A2.Minors[0, 0];
        Vector2 v3 = A3[0];

        v3 += new Vector2(A3[0, 0].Sign * v3.Length, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Scalar A4 = -A3[1, 1]; // TODO : ????????
        Matrix5[] H = new Matrix5[5];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4, 4, -1];

        return (
            Q: H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed
        );
    }

    public readonly (Matrix5 U, Matrix5 D) IwasawaDecompose()
    {
        Matrix5 ONB = OrthonormalBasis;
        Matrix5 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace5 GetKrylovSpace(Vector5 vector) => VectorSpace5.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix5 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance);

    public readonly bool Is(Matrix5 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix5 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix5 v && Equals(v);

    public readonly bool Equals(Matrix5 other) => Is(other);

    public readonly int CompareTo(Matrix5 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix5 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix5)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 5x5-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 5x5-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Creates the homogeneous 6x6 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 6x6 transformation matrix.</returns>
    public readonly Matrix6 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        _c4.ToHomogeneousCoordinates(),
        Vector6.UnitVectors[5]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector5> ToIsomorphism()
    {
        Matrix5 copy = this;

        return new Function<Vector5>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector5> GetEnumerator() => ((IEnumerable<Vector5>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]);

    public readonly void Deconstruct(out Vector5 v0, out Vector5 v1, out Vector5 v2, out Vector5 v3, out Vector5 v4) =>
        (v0, v1, v2, v3, v4) = (_c0, _c1, _c2, _c3, _c4);

    public readonly object Clone() => new Matrix5(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector5 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 4.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix5 SetColumn(int column, in Vector5 vector)
    {
        if (column < 0 || column >= 5)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 4.");

        Vector5[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..5);

    public readonly Matrix5 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..5, values);

    public readonly Matrix5 SwapColumns(int src_col, int dst_col)
    {
        Vector5 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix5 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix5 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix5 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector5 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix5 SetRow(int row, in Vector5 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..5, rows);

    public readonly Matrix5 SetRows(Range rows, in MatrixNM values) => SetRegion(0..5, rows, values);

    public readonly Matrix5 SwapRows(int src_row, int dst_row)
    {
        Vector5 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix5 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix5 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix5 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(5);
        int[] idx_r = rows.GetOffsets(5);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix5 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(5);
        int[] idx_r = rows.GetOffsets(5);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix5(t);
    }

    /// <summary>
    /// Returns the matrix' 4x4-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>4x4-minor</returns>
    public readonly Matrix4 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector4(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix5 Add(Matrix5 m1, Matrix5 m2) => m1.Add(m2);

    public static Matrix5 Subtract(Matrix5 m1, Matrix5 m2) => m1.Subtract(m2);

    public static Matrix5 Multiply(Matrix5 m1, Matrix5 m2) => m1.Multiply(m2);

    public static Vector5 Multiply(Matrix5 m, Vector5 v) => m.Multiply(v);

    public static Matrix5 Multiply(Matrix5 m, Scalar s) => m.Multiply(s);

    public static Matrix5 Divide(Matrix5 m, Scalar s) => m.Divide(s);

    public static Matrix5 Exp(Matrix5 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix5 Sin(Matrix5 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix5 Cos(Matrix5 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix5 CracovianProduct(in Matrix5 first, in Matrix5 second) => second.Transposed.Multiply(in second);

    public static Matrix5 HadamardProduct(in Matrix5 first, in Matrix5 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix5 first, Matrix5 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix5 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[5, 5];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix5 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix5 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[5, 5];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix5 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix5 DiagonalMatrix(in Vector5 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4]);

    public static Matrix5 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4) => (
        d0, 0, 0, 0, 0,
        0, d1, 0, 0, 0,
        0, 0, d2, 0, 0,
        0, 0, 0, d3, 0,
        0, 0, 0, 0, d4
    );
    
    public static Matrix5 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix5 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix5 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 5))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 4.", nameof(column_indices));

        Vector5[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix5 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix5 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix5 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix5 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix5 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 5 || arr.GetLength(1) < 5 ? throw new ArgumentException("The array must have a minimum size of 5x5.", nameof(arr)) : new Matrix5(arr);

    public static Matrix5 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 25 => throw new ArgumentException("The array must have a minimum length of 25.", nameof(arr)),
        _ => new Matrix5(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4],
            arr[ 5], arr[ 6], arr[ 7], arr[ 8], arr[ 9],
            arr[10], arr[11], arr[12], arr[13], arr[14],
            arr[15], arr[16], arr[17], arr[18], arr[19],
            arr[20], arr[21], arr[22], arr[23], arr[24]
        )
    };

    public static Matrix5 FromRows(in Vector5[] arr) => FromColumns(arr).Transposed;

    public static Matrix5 FromColumns(in Vector5[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 5 } => new Matrix5(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 5.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix5 m1, Matrix5 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix5 m1, Matrix5 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix5 operator +(in Matrix5 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix5 operator -(in Matrix5 m) => m.Negate();

    public static Matrix5 operator +(Scalar f, in Matrix5 m) => m.Add(f);

    public static Matrix5 operator +(in Matrix5 m, Scalar f) => m.Add(f);

    public static Matrix5 operator -(Scalar f, in Matrix5 m) => new Matrix5(f).Subtract(in m);

    public static Matrix5 operator -(in Matrix5 m, Scalar f) => m.Subtract(f);

    public static Matrix5 operator ++(in Matrix5 m) => m.Increment();

    public static Matrix5 operator --(in Matrix5 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix5 operator +(in Matrix5 m1, in Matrix5 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix5 operator -(in Matrix5 m1, in Matrix5 m2) => m1.Subtract(in m2);

    public static Vector5 operator *(in Matrix5 m, in Vector5 v) => m.Multiply(in v);

    public static Matrix5 operator *(in Matrix5 m1, in Matrix5 m2) => m1.Multiply(in m2);

    public static Matrix5 operator *(in Matrix5 m, Scalar f) => m.Multiply(f);

    public static Matrix5 operator *(Scalar f, in Matrix5 m) => m.Multiply(f);

    public static Matrix5 operator ^(in Matrix5 m, int c) => m.Power(c);

    public static Matrix5 operator ^(in Matrix5 m1, in Matrix5 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace5 operator |(Matrix5 A, Vector5 b) => A.Solve(b);

    public static VectorSpace5 operator |(Matrix5 A, VectorSpace5 b) => A.Solve(b);

    public static Matrix5 operator /(Matrix5 m1, Matrix5 m2) => m1.Multiply(m2.Inverse);

    public static Matrix5 operator /(in Matrix5 m, Scalar f) => m.Divide(f);

    public static Matrix5 operator %(in Matrix5 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector5 x0, Vector5 x1, Vector5 x2, Vector5 x3, Vector5 x4) (in Matrix5 m) => (m[0], m[1], m[2], m[3], m[4]);

    public static implicit operator Matrix5((Vector5 x0, Vector5 x1, Vector5 x2, Vector5 x3, Vector5 x4) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c4) (in Matrix5 m) => (m[0], m[1], m[2], m[3], m[4]);

    public static explicit operator Matrix5(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4) c4) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4) (in Matrix5 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4]
    );

    public static implicit operator Matrix5(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4
    );

    public static explicit operator Matrix5(Scalar m) => new(m);

    public static implicit operator Matrix5(in Vector5[] arr) => new(arr);

    public static implicit operator Vector5[](in Matrix5 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix5 m) => m.ToArray();

    public static implicit operator Matrix5(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix5 m) => m.Coefficients;

    public static implicit operator Matrix5(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix5 m) => new(m.Coefficients);

    public static explicit operator Matrix5(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix5 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix5>(m);

    public static implicit operator Function<Vector5>(in Matrix5 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix5EqualityComparer
        : IEqualityComparer<Matrix5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix5 x, Matrix5 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix5 obj) => obj.GetHashCode();
    }
}

public static class Matrix5Extensions
{
    public static Matrix5 Sum(this IEnumerable<Matrix5> matrices) => Matrix5.Zero.Add(matrices.ToArray());

    public static Matrix5 Average(this IEnumerable<Matrix5> matrices)
    {
        Matrix5 mat = Matrix5.Zero;
        long count = 0;

        foreach (Matrix5 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix6

/// <summary>
/// Represents a square 6x6 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix6
    : Algebra<Scalar>.IMatrix<Vector6, Matrix6>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix6, MatrixNM>
    , INative<Matrix6>
    , IEnumerable<Vector6>
    // , Function<Matrix6, Vector6>
    , IEnumerable<Scalar>
    , IComparable<Matrix6>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix6>
    , IModulusOperators<Matrix6, Scalar, Matrix6>
    , IMultiplyOperators<Matrix6, Matrix6, Matrix6>
    , IMultiplyOperators<Scalar, Matrix6, Matrix6>
    , IMultiplyOperators<Matrix6, Scalar, Matrix6>
    , IDivisionOperators<Matrix6, Scalar, Matrix6>
    , IMultiplyOperators<Vector6, Matrix6, Vector6>
    , IMultiplyOperators<Matrix6, Vector6, Vector6>
    , IDecrementOperators<Matrix6>
    , IAdditionOperators<Matrix6, Matrix6, Matrix6>
    , ISubtractionOperators<Matrix6, Matrix6, Matrix6>
    , IUnaryPlusOperators<Matrix6, Matrix6>
    , IUnaryNegationOperators<Matrix6, Matrix6>
    , IAdditiveIdentity<Matrix6, Matrix6>
    , IMultiplicativeIdentity<Matrix6, Matrix6>
    , IComparisonOperators<Matrix6, Matrix6>
    , IEqualityOperators<Matrix6, Matrix6>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector6 _c0;
    private readonly Vector6 _c1;
    private readonly Vector6 _c2;
    private readonly Vector6 _c3;
    private readonly Vector6 _c4;
    private readonly Vector6 _c5;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (6, 6);

    /// <summary>
    /// The 6x6 zero matrix
    /// </summary>
    public static Matrix6 Zero { get; } = new Matrix6(0);

    /// <summary>
    /// The 6x6 identity (unit) matrix
    /// </summary>
    public static Matrix6 Identity { get; } = new(1);

    static Matrix6 IRing<Matrix6>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix6"/>.
    /// </summary>
    public static Matrix6EqualityComparer EqualityComparer { get; } = new Matrix6EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix6"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix6);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector6 this[int column] => GetColumn(column);

    public readonly Vector6 this[Index column] => this[column.GetOffset(6)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix6 this[int column, in Vector6 value] => SetColumn(column, value);

    public readonly Matrix6 this[Index column, in Vector6 value] => this[column.GetOffset(6), value];

    public readonly Matrix6 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix6 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 6 || column < 0 || column >= 6)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 5.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix6(scalars);
        }
    }

    public readonly Matrix6 this[Index column, Index row, Scalar value] => this[column.GetOffset(6), row.GetOffset(6), value];

    public readonly Matrix6 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix5> Minors => new ReadOnlyIndexer<int, int, Matrix5>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (6, 6);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[6, 6]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5] },
        { _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[36] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector6 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4], _c5[5]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector6[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector6[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix6 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 4 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4(), ToMatrix5());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix6 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5],
        _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix6::Inverse' instead.")]
    public readonly Matrix6 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix6 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix6 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector6[] vs = Columns;

            for (int i = 0; i < 6; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant
        - GetMinor(0, 5).Determinant;

    public readonly Matrix6 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix6 m = this;
            // TODO : verify the following code
            Matrix6 u = Identity;

            for (int i = 0; i < 6; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 6; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 6; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 6 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector6[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector6.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 6x6 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary && _c5.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector6[] rows = Rows;

            for (int i = 0; i < 6; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 6; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 6; ++c)
                for (int r = 0; r < 6; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 6; ++c)
                for (int r = c + 1; r < 6; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix6 ctc = Transposed * this;

            return (ctc - new Matrix6(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 6x6-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix6(Scalar scale)
        : this(scale, 0, 0, 0, 0, 0,
               0, scale, 0, 0, 0, 0,
               0, 0, scale, 0, 0, 0,
               0, 0, 0, scale, 0, 0,
               0, 0, 0, 0, scale, 0,
               0, 0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 6x6-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    /// <param name="diag_5">The diagonal element at the position (5, 5).</param>
    public Matrix6(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4, Scalar diag_5)
        : this(diag_0, 0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0, 0,
               0, 0, diag_2, 0, 0, 0,
               0, 0, 0, diag_3, 0, 0,
               0, 0, 0, 0, diag_4, 0,
               0, 0, 0, 0, 0, diag_5)
    {
    }

    public Matrix6(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_5_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_5_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_5_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_5_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4, Scalar s_5_4, Scalar s_0_5, Scalar s_1_5, Scalar s_2_5, Scalar s_3_5, Scalar s_4_5, Scalar s_5_5)
        : this(new Vector6(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4, s_0_5),
               new Vector6(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4, s_1_5),
               new Vector6(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4, s_2_5),
               new Vector6(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4, s_3_5),
               new Vector6(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4, s_4_5),
               new Vector6(s_5_0, s_5_1, s_5_2, s_5_3, s_5_4, s_5_5))
    {
    }

    public Matrix6(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5],
               values[6], values[7], values[8], values[9], values[10], values[11],
               values[12], values[13], values[14], values[15], values[16], values[17],
               values[18], values[19], values[20], values[21], values[22], values[23],
               values[24], values[25], values[26], values[27], values[28], values[29],
               values[30], values[31], values[32], values[33], values[34], values[35])
    {
    }

    public Matrix6(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0], values[5, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1], values[5, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2], values[5, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3], values[5, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4], values[5, 4],
               values[0, 5], values[1, 5], values[2, 5], values[3, 5], values[4, 5], values[5, 5])
    {
    }

    public Matrix6(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0], values[5][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1], values[5][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2], values[5][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3], values[5][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4], values[5][4],
               values[0][5], values[1][5], values[2][5], values[3][5], values[4][5], values[5][5])
    {
    }

    public Matrix6(in Matrix2 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), Vector6.Zero, Vector6.Zero, Vector6.Zero, Vector6.Zero)
    {
    }

    public Matrix6(in Matrix3 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), Vector6.Zero, Vector6.Zero, Vector6.Zero)
    {
    }

    public Matrix6(in Matrix4 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), Vector6.Zero, Vector6.Zero)
    {
    }

    public Matrix6(in Matrix5 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), new Vector6(matrix[4]), Vector6.Zero)
    {
    }

    public Matrix6(in Matrix6 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix6(in Matrix7 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), new Vector6(matrix[4]), new Vector6(matrix[5]))
    {
    }

    public Matrix6(in Matrix8 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), new Vector6(matrix[4]), new Vector6(matrix[5]))
    {
    }

    public Matrix6(in Matrix9 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), new Vector6(matrix[4]), new Vector6(matrix[5]))
    {
    }

    public Matrix6(in Matrix10 matrix)
        : this(new Vector6(matrix[0]), new Vector6(matrix[1]), new Vector6(matrix[2]), new Vector6(matrix[3]), new Vector6(matrix[4]), new Vector6(matrix[5]))
    {
    }

    public Matrix6(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix6(Matrix6* matrix)
        : this(*matrix)
    {
    }

    public Matrix6(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5],
               values[6], values[7], values[8], values[9], values[10], values[11],
               values[12], values[13], values[14], values[15], values[16], values[17],
               values[18], values[19], values[20], values[21], values[22], values[23],
               values[24], values[25], values[26], values[27], values[28], values[29],
               values[30], values[31], values[32], values[33], values[34], values[35])
    {
    }

    public Matrix6(Vector6* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5])
    {
    }

    public Matrix6(IEnumerable<Vector6> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix6(Vector6[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5])
    {
    }

    public Matrix6(Vector6 v0, Vector6 v1, Vector6 v2, Vector6 v3, Vector6 v4, Vector6 v5)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
        _c5 = v5;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix6 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4, -_c5);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix6 Add(in Matrix6 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4, _c5 + second._c5);

    public readonly Matrix6 Add(params Matrix6[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix6 Add(Scalar Scalar) => Add(new Matrix6(Scalar));

    public readonly Matrix6 Increment() => Add(1);

    public readonly Matrix6 Decrement() => Add(-1);

    public readonly Matrix6 Subtract(in Matrix6 second) => Add(second.Negate());

    public readonly Matrix6 Subtract(params Matrix6[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix6 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector5 HomogeneousMultiply(in Vector5 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix6 Multiply(in Matrix6 second)
    {
        Vector6[] A = Rows;
        Vector6[] B = second.Columns;
        Scalar[,] C = new Scalar[6, 6];

        for (int r = 0; r < 6; ++r)
            for (int c = 0; c < 6; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix6(C);
    }

    public readonly Matrix6 Multiply(params Matrix6[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector6 Multiply(in Vector6 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4] + _c5[0] * vector[5],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4] + _c5[1] * vector[5],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4] + _c5[2] * vector[5],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4] + _c5[3] * vector[5],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4] + _c5[4] * vector[5],
        _c0[5] * vector[0] + _c1[5] * vector[1] + _c2[5] * vector[2] + _c3[5] * vector[3] + _c4[5] * vector[4] + _c5[5] * vector[5]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix6 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor, _c5 * factor);

    public readonly Matrix6 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix6 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix6 r = Identity;
        Matrix6 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix6 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix6 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor, _c5 % factor);

    public readonly Matrix6 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix6 result = this;
        Matrix6 exponent = this;
        Matrix6 squared = Multiply(this);
        Matrix6 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix6 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix6 result = Identity;
        Matrix6 exponent = this;
        Matrix6 squared = Multiply(this);
        Matrix6 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix6 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix6 result = Identity;
        Matrix6 exponent = this;
        Matrix6 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix6 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix6 ComponentwiseDivide(in Matrix6 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4), _c5.ComponentwiseDivide(second._c5));

    public readonly Matrix6 ComponentwiseMultiply(in Matrix6 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4), _c5.ComponentwiseMultiply(second._c5));

    public readonly Matrix6 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function), _c5.ComponentwiseApply(function));

    public readonly Matrix6 ComponentwiseApply(Matrix6 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function), _c5.ComponentwiseApply(second._c5, function));

    public readonly Matrix6 ComponentwiseApply(Matrix6 second, Matrix6 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function), _c5.ComponentwiseApply(second._c5, third._c5, function));

    public readonly Matrix6 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix6 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high), _c5.Clamp(low, high));

    public readonly Matrix6 LinearInterpolate(in Matrix6 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix6 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 6; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 4 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4, Sub5 };
    }

    internal readonly Matrix6 GetLinearIndependentForm()
    {
        Matrix6 m = this;

        for (int row = 0; row < 6; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 6; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 6; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector6</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace6 Solve(Vector6 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector6 x = vector;

            for (int i = 0; i < 6; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 6; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector6 x = vector;

            for (int i = 5; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix6 P, Matrix6 L, Matrix6 U) = PLUDecompose();
        VectorSpace6 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace6(SolveCG(vector));
    }

    public readonly VectorSpace6 Solve(VectorSpace6 vectorspace)
    {
        VectorSpace6 result = VectorSpace6.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace6 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector6, Matrix6>.Solve(Vector6 vector, out Vector6 solution)
    {
        VectorSpace6 space = Solve(vector);
        solution = Vector6.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector6 SolveCG(Vector6 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector6 x = vector;
        Vector6 r = vector - Multiply(vector);
        Vector6 d = r;

        for (int i = 0; i < 6; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector6 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector6 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix6 m = this;
        Vector6 v = vector;

        for (int row = 0; row < 6; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 6; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 6; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 5; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector6[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector6 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector6[] vectors = pairs.Select(p => p.vec).Distinct(Vector6.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector6 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector6 vec, Scalar val)[] pairs = new (Vector6, Scalar)[6];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 6; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector6 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector6 v_old = default;
        Vector6 v_new = Vector6.GetRandomCartesianUnitVector();
        Vector6 v_init = v_new;
        Matrix6 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector6 w = default;

        while ((w * v_init).IsZero)
            w = Vector6.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace6 GetEigenspace(Scalar eigenvalue) => VectorSpace6.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix6 P, Matrix6 S, Matrix6 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector6 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix6 P = new Matrix6(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v, pairs[5].v);
        Matrix6 S = new Matrix6(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ, pairs[5].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix6 P, Matrix6 L, Matrix6 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4, 5 };
        Matrix6 U = Identity;
        Matrix6 L = this;

        for (int i = 0; i < 5; ++i)
        {
            Vector6 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 6; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 6; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix3 A, Matrix3 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(3);

        return ((Matrix3)A, (Matrix3)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 6)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 6.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix6 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix6 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix6 Q, Matrix6 R) QRDecompose()
    {
        Matrix6 A = this;
        (Vector6 v0_0, Vector6 v0_1, Vector6 v0_2, Vector6 v0_3, Vector6 v0_4, Vector6 v0_5) = A;
        Vector6 v0 = v0_0 + new Vector6(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;
        v0_5 -= (2 * (v0 * v0_5)) * v0;

        Vector5 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4], v0_1[5]);
        Vector5 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4], v0_2[5]);
        Vector5 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4], v0_3[5]);
        Vector5 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4], v0_4[5]);
        Vector5 v1_4 = (v0_5[1], v0_5[2], v0_5[3], v0_5[4], v0_5[5]);
        Vector5 v1 = v1_0 + new Vector5(v1_0[0].Sign * v1_0.Length, 0, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;
        v1_4 -= (2 * (v1 * v1_4)) * v1;

        Vector4 v2_0 = (v1_1[1], v1_1[2], v1_1[3], v1_1[4]);
        Vector4 v2_1 = (v1_2[1], v1_2[2], v1_2[3], v1_2[4]);
        Vector4 v2_2 = (v1_3[1], v1_3[2], v1_3[3], v1_3[4]);
        Vector4 v2_3 = (v1_4[1], v1_4[2], v1_4[3], v1_4[4]);
        Vector4 v2 = v2_0 + new Vector4(v2_0[0].Sign * v2_0.Length, 0, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;
        v2_3 -= (2 * (v2 * v2_3)) * v2;

        Vector3 v3_0 = (v2_1[1], v2_1[2], v2_1[3]);
        Vector3 v3_1 = (v2_2[1], v2_2[2], v2_2[3]);
        Vector3 v3_2 = (v2_3[1], v2_3[2], v2_3[3]);
        Vector3 v3 = v3_0 + new Vector3(v3_0[0].Sign * v3_0.Length, 0, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;
        v3_2 -= (2 * (v3 * v3_2)) * v3;

        Vector2 v4_0 = (v3_1[1], v3_1[2]);
        Vector2 v4_1 = (v3_2[1], v3_2[2]);
        Vector2 v4 = v4_0 + new Vector2(v4_0[0].Sign * v4_0.Length, 0);

        v4 = ~v4;
        v4_0 -= (2 * (v4 * v4_0)) * v4;
        v4_1 -= (2 * (v4 * v4_1)) * v4;

        Matrix6 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0], v0_5[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0], v1_4[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0], v2_3[0],
            0, 0, 0, v3_0[0], v3_1[0], v3_2[0],
            0, 0, 0, 0, v4_0[0], v4_1[0],
            0, 0, 0, 0, 0, v4_1[1]
        );
        Matrix6 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];
        Q *= Identity[4.., 4.., v4.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix6 Q, Matrix6 R) QRDecomposeUnstable()
    {
        Matrix6 H0;
        Matrix6 A0 = this;
        Vector6 v0 = A0[0];

        v0 += new Vector6(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix5 H1;
        Matrix5 A1 = A0.Minors[0, 0];
        Vector5 v1 = A1[0];

        v1 += new Vector5(A1[0, 0].Sign * v1.Length, 0, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix4 H2;
        Matrix4 A2 = A1.Minors[0, 0];
        Vector4 v2 = A2[0];

        v2 += new Vector4(A2[0, 0].Sign * v2.Length, 0, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix3 H3;
        Matrix3 A3 = A2.Minors[0, 0];
        Vector3 v3 = A3[0];

        v3 += new Vector3(A3[0, 0].Sign * v3.Length, 0, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Matrix2 H4;
        Matrix2 A4 = A3.Minors[0, 0];
        Vector2 v4 = A4[0];

        v4 += new Vector2(A4[0, 0].Sign * v4.Length, 0);
        H4 = v4.HouseholderMatrix;
        A4 = H4 * A4;

        Scalar A5 = -A4[1, 1]; // TODO : ????????
        Matrix6[] H = new Matrix6[6];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4.., 4.., H4];
        H[5] = H[5][5, 5, -1];

        return (
            Q: H[5] * H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed * H[5].Transposed
        );
    }

    public readonly (Matrix6 U, Matrix6 D) IwasawaDecompose()
    {
        Matrix6 ONB = OrthonormalBasis;
        Matrix6 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace6 GetKrylovSpace(Vector6 vector) => VectorSpace6.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix6 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance) && _c5.Is(o._c5, tolerance);

    public readonly bool Is(Matrix6 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix6 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix6 v && Equals(v);

    public readonly bool Equals(Matrix6 other) => Is(other);

    public readonly int CompareTo(Matrix6 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix6 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix6)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 6x6-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 6x6-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>5x5 sub-matrix</returns>
    public readonly Matrix5 ToMatrix5() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]
    );

    /// <summary>
    /// Creates the homogeneous 7x7 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 7x7 transformation matrix.</returns>
    public readonly Matrix7 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        _c4.ToHomogeneousCoordinates(),
        _c5.ToHomogeneousCoordinates(),
        Vector7.UnitVectors[6]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector6> ToIsomorphism()
    {
        Matrix6 copy = this;

        return new Function<Vector6>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector6> GetEnumerator() => ((IEnumerable<Vector6>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_5_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_5_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_5_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_5_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4, out Scalar x_5_4, out Scalar x_0_5, out Scalar x_1_5, out Scalar x_2_5, out Scalar x_3_5, out Scalar x_4_5, out Scalar x_5_5) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_5_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_5_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_5_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4, x_5_4, x_0_5, x_1_5, x_2_5, x_3_5, x_4_5, x_5_5) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5]);

    public readonly void Deconstruct(out Vector6 v0, out Vector6 v1, out Vector6 v2, out Vector6 v3, out Vector6 v4, out Vector6 v5) =>
        (v0, v1, v2, v3, v4, v5) = (_c0, _c1, _c2, _c3, _c4, _c5);

    public readonly object Clone() => new Matrix6(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector6 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        5 => _c5,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 5.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix6 SetColumn(int column, in Vector6 vector)
    {
        if (column < 0 || column >= 6)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 5.");

        Vector6[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..6);

    public readonly Matrix6 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..6, values);

    public readonly Matrix6 SwapColumns(int src_col, int dst_col)
    {
        Vector6 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix6 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix6 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix6 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector6 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix6 SetRow(int row, in Vector6 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..6, rows);

    public readonly Matrix6 SetRows(Range rows, in MatrixNM values) => SetRegion(0..6, rows, values);

    public readonly Matrix6 SwapRows(int src_row, int dst_row)
    {
        Vector6 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix6 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix6 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix6 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(6);
        int[] idx_r = rows.GetOffsets(6);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix6 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(6);
        int[] idx_r = rows.GetOffsets(6);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix6(t);
    }

    /// <summary>
    /// Returns the matrix' 5x5-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>5x5-minor</returns>
    public readonly Matrix5 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector5(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix6 Add(Matrix6 m1, Matrix6 m2) => m1.Add(m2);

    public static Matrix6 Subtract(Matrix6 m1, Matrix6 m2) => m1.Subtract(m2);

    public static Matrix6 Multiply(Matrix6 m1, Matrix6 m2) => m1.Multiply(m2);

    public static Vector6 Multiply(Matrix6 m, Vector6 v) => m.Multiply(v);

    public static Matrix6 Multiply(Matrix6 m, Scalar s) => m.Multiply(s);

    public static Matrix6 Divide(Matrix6 m, Scalar s) => m.Divide(s);

    public static Matrix6 Exp(Matrix6 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix6 Sin(Matrix6 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix6 Cos(Matrix6 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix6 CracovianProduct(in Matrix6 first, in Matrix6 second) => second.Transposed.Multiply(in second);

    public static Matrix6 HadamardProduct(in Matrix6 first, in Matrix6 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix6 first, Matrix6 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix6 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[6, 6];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix6 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix6 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[6, 6];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix6 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix6 DiagonalMatrix(in Vector6 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4], diagonal[5]);

    public static Matrix6 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4, Scalar d5) => (
        d0, 0, 0, 0, 0, 0,
        0, d1, 0, 0, 0, 0,
        0, 0, d2, 0, 0, 0,
        0, 0, 0, d3, 0, 0,
        0, 0, 0, 0, d4, 0,
        0, 0, 0, 0, 0, d5
    );
    
    public static Matrix6 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix6 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix6 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 6))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 5.", nameof(column_indices));

        Vector6[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix6 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix6 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix6 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix6 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix6 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 6 || arr.GetLength(1) < 6 ? throw new ArgumentException("The array must have a minimum size of 6x6.", nameof(arr)) : new Matrix6(arr);

    public static Matrix6 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 36 => throw new ArgumentException("The array must have a minimum length of 36.", nameof(arr)),
        _ => new Matrix6(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4], arr[ 5],
            arr[ 6], arr[ 7], arr[ 8], arr[ 9], arr[10], arr[11],
            arr[12], arr[13], arr[14], arr[15], arr[16], arr[17],
            arr[18], arr[19], arr[20], arr[21], arr[22], arr[23],
            arr[24], arr[25], arr[26], arr[27], arr[28], arr[29],
            arr[30], arr[31], arr[32], arr[33], arr[34], arr[35]
        )
    };

    public static Matrix6 FromRows(in Vector6[] arr) => FromColumns(arr).Transposed;

    public static Matrix6 FromColumns(in Vector6[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 6 } => new Matrix6(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0], arr[5][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1], arr[5][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2], arr[5][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3], arr[5][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4], arr[5][4],
            arr[0][5], arr[1][5], arr[2][5], arr[3][5], arr[4][5], arr[5][5]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 6.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix6 m1, Matrix6 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix6 m1, Matrix6 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix6 operator +(in Matrix6 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix6 operator -(in Matrix6 m) => m.Negate();

    public static Matrix6 operator +(Scalar f, in Matrix6 m) => m.Add(f);

    public static Matrix6 operator +(in Matrix6 m, Scalar f) => m.Add(f);

    public static Matrix6 operator -(Scalar f, in Matrix6 m) => new Matrix6(f).Subtract(in m);

    public static Matrix6 operator -(in Matrix6 m, Scalar f) => m.Subtract(f);

    public static Matrix6 operator ++(in Matrix6 m) => m.Increment();

    public static Matrix6 operator --(in Matrix6 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix6 operator +(in Matrix6 m1, in Matrix6 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix6 operator -(in Matrix6 m1, in Matrix6 m2) => m1.Subtract(in m2);

    public static Vector6 operator *(in Matrix6 m, in Vector6 v) => m.Multiply(in v);

    public static Matrix6 operator *(in Matrix6 m1, in Matrix6 m2) => m1.Multiply(in m2);

    public static Matrix6 operator *(in Matrix6 m, Scalar f) => m.Multiply(f);

    public static Matrix6 operator *(Scalar f, in Matrix6 m) => m.Multiply(f);

    public static Matrix6 operator ^(in Matrix6 m, int c) => m.Power(c);

    public static Matrix6 operator ^(in Matrix6 m1, in Matrix6 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace6 operator |(Matrix6 A, Vector6 b) => A.Solve(b);

    public static VectorSpace6 operator |(Matrix6 A, VectorSpace6 b) => A.Solve(b);

    public static Matrix6 operator /(Matrix6 m1, Matrix6 m2) => m1.Multiply(m2.Inverse);

    public static Matrix6 operator /(in Matrix6 m, Scalar f) => m.Divide(f);

    public static Matrix6 operator %(in Matrix6 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector6 x0, Vector6 x1, Vector6 x2, Vector6 x3, Vector6 x4, Vector6 x5) (in Matrix6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

    public static implicit operator Matrix6((Vector6 x0, Vector6 x1, Vector6 x2, Vector6 x3, Vector6 x4, Vector6 x5) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c5) (in Matrix6 m) => (m[0], m[1], m[2], m[3], m[4], m[5]);

    public static explicit operator Matrix6(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5) c5) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5) (in Matrix6 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0], m._c5[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1], m._c5[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2], m._c5[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3], m._c5[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4], m._c5[4],
        m._c0[5], m._c1[5], m._c2[5], m._c3[5], m._c4[5], m._c5[5]
    );

    public static implicit operator Matrix6(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0, t.x_5_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1, t.x_5_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2, t.x_5_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3, t.x_5_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4, t.x_5_4,
        t.x_0_5, t.x_1_5, t.x_2_5, t.x_3_5, t.x_4_5, t.x_5_5
    );

    public static explicit operator Matrix6(Scalar m) => new(m);

    public static implicit operator Matrix6(in Vector6[] arr) => new(arr);

    public static implicit operator Vector6[](in Matrix6 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix6 m) => m.ToArray();

    public static implicit operator Matrix6(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix6 m) => m.Coefficients;

    public static implicit operator Matrix6(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix6 m) => new(m.Coefficients);

    public static explicit operator Matrix6(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix6 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix6>(m);

    public static implicit operator Function<Vector6>(in Matrix6 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix6EqualityComparer
        : IEqualityComparer<Matrix6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix6 x, Matrix6 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix6 obj) => obj.GetHashCode();
    }
}

public static class Matrix6Extensions
{
    public static Matrix6 Sum(this IEnumerable<Matrix6> matrices) => Matrix6.Zero.Add(matrices.ToArray());

    public static Matrix6 Average(this IEnumerable<Matrix6> matrices)
    {
        Matrix6 mat = Matrix6.Zero;
        long count = 0;

        foreach (Matrix6 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix7

/// <summary>
/// Represents a square 7x7 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix7
    : Algebra<Scalar>.IMatrix<Vector7, Matrix7>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix7, MatrixNM>
    , INative<Matrix7>
    , IEnumerable<Vector7>
    // , Function<Matrix7, Vector7>
    , IEnumerable<Scalar>
    , IComparable<Matrix7>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix7>
    , IModulusOperators<Matrix7, Scalar, Matrix7>
    , IMultiplyOperators<Matrix7, Matrix7, Matrix7>
    , IMultiplyOperators<Scalar, Matrix7, Matrix7>
    , IMultiplyOperators<Matrix7, Scalar, Matrix7>
    , IDivisionOperators<Matrix7, Scalar, Matrix7>
    , IMultiplyOperators<Vector7, Matrix7, Vector7>
    , IMultiplyOperators<Matrix7, Vector7, Vector7>
    , IDecrementOperators<Matrix7>
    , IAdditionOperators<Matrix7, Matrix7, Matrix7>
    , ISubtractionOperators<Matrix7, Matrix7, Matrix7>
    , IUnaryPlusOperators<Matrix7, Matrix7>
    , IUnaryNegationOperators<Matrix7, Matrix7>
    , IAdditiveIdentity<Matrix7, Matrix7>
    , IMultiplicativeIdentity<Matrix7, Matrix7>
    , IComparisonOperators<Matrix7, Matrix7>
    , IEqualityOperators<Matrix7, Matrix7>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector7 _c0;
    private readonly Vector7 _c1;
    private readonly Vector7 _c2;
    private readonly Vector7 _c3;
    private readonly Vector7 _c4;
    private readonly Vector7 _c5;
    private readonly Vector7 _c6;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (7, 7);

    /// <summary>
    /// The 7x7 zero matrix
    /// </summary>
    public static Matrix7 Zero { get; } = new Matrix7(0);

    /// <summary>
    /// The 7x7 identity (unit) matrix
    /// </summary>
    public static Matrix7 Identity { get; } = new(1);

    static Matrix7 IRing<Matrix7>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix7"/>.
    /// </summary>
    public static Matrix7EqualityComparer EqualityComparer { get; } = new Matrix7EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix7"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix7);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector7 this[int column] => GetColumn(column);

    public readonly Vector7 this[Index column] => this[column.GetOffset(7)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix7 this[int column, in Vector7 value] => SetColumn(column, value);

    public readonly Matrix7 this[Index column, in Vector7 value] => this[column.GetOffset(7), value];

    public readonly Matrix7 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix7 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 7 || column < 0 || column >= 7)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 6.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix7(scalars);
        }
    }

    public readonly Matrix7 this[Index column, Index row, Scalar value] => this[column.GetOffset(7), row.GetOffset(7), value];

    public readonly Matrix7 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix6> Minors => new ReadOnlyIndexer<int, int, Matrix6>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (7, 7);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[7, 7]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6] },
        { _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6] },
        { _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[49] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector7 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4], _c5[5], _c6[6]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector7[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector7[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix7 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 5 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4(), ToMatrix5(), ToMatrix6());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix7 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6],
        _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6],
        _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix7::Inverse' instead.")]
    public readonly Matrix7 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix7 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix7 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector7[] vs = Columns;

            for (int i = 0; i < 7; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant
        - GetMinor(0, 5).Determinant
        + GetMinor(0, 6).Determinant;

    public readonly Matrix7 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix7 m = this;
            // TODO : verify the following code
            Matrix7 u = Identity;

            for (int i = 0; i < 7; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 7; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 7; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 7 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector7[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector7.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 7x7 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary && _c5.IsBinary && _c6.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector7[] rows = Rows;

            for (int i = 0; i < 7; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 7; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 7; ++c)
                for (int r = 0; r < 7; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 7; ++c)
                for (int r = c + 1; r < 7; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix7 ctc = Transposed * this;

            return (ctc - new Matrix7(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 7x7-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix7(Scalar scale)
        : this(scale, 0, 0, 0, 0, 0, 0,
               0, scale, 0, 0, 0, 0, 0,
               0, 0, scale, 0, 0, 0, 0,
               0, 0, 0, scale, 0, 0, 0,
               0, 0, 0, 0, scale, 0, 0,
               0, 0, 0, 0, 0, scale, 0,
               0, 0, 0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 7x7-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    /// <param name="diag_5">The diagonal element at the position (5, 5).</param>
    /// <param name="diag_6">The diagonal element at the position (6, 6).</param>
    public Matrix7(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4, Scalar diag_5, Scalar diag_6)
        : this(diag_0, 0, 0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0, 0, 0,
               0, 0, diag_2, 0, 0, 0, 0,
               0, 0, 0, diag_3, 0, 0, 0,
               0, 0, 0, 0, diag_4, 0, 0,
               0, 0, 0, 0, 0, diag_5, 0,
               0, 0, 0, 0, 0, 0, diag_6)
    {
    }

    public Matrix7(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_5_0, Scalar s_6_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_5_1, Scalar s_6_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_5_2, Scalar s_6_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_5_3, Scalar s_6_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4, Scalar s_5_4, Scalar s_6_4, Scalar s_0_5, Scalar s_1_5, Scalar s_2_5, Scalar s_3_5, Scalar s_4_5, Scalar s_5_5, Scalar s_6_5, Scalar s_0_6, Scalar s_1_6, Scalar s_2_6, Scalar s_3_6, Scalar s_4_6, Scalar s_5_6, Scalar s_6_6)
        : this(new Vector7(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4, s_0_5, s_0_6),
               new Vector7(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4, s_1_5, s_1_6),
               new Vector7(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4, s_2_5, s_2_6),
               new Vector7(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4, s_3_5, s_3_6),
               new Vector7(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4, s_4_5, s_4_6),
               new Vector7(s_5_0, s_5_1, s_5_2, s_5_3, s_5_4, s_5_5, s_5_6),
               new Vector7(s_6_0, s_6_1, s_6_2, s_6_3, s_6_4, s_6_5, s_6_6))
    {
    }

    public Matrix7(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6],
               values[7], values[8], values[9], values[10], values[11], values[12], values[13],
               values[14], values[15], values[16], values[17], values[18], values[19], values[20],
               values[21], values[22], values[23], values[24], values[25], values[26], values[27],
               values[28], values[29], values[30], values[31], values[32], values[33], values[34],
               values[35], values[36], values[37], values[38], values[39], values[40], values[41],
               values[42], values[43], values[44], values[45], values[46], values[47], values[48])
    {
    }

    public Matrix7(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0], values[5, 0], values[6, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1], values[5, 1], values[6, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2], values[5, 2], values[6, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3], values[5, 3], values[6, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4], values[5, 4], values[6, 4],
               values[0, 5], values[1, 5], values[2, 5], values[3, 5], values[4, 5], values[5, 5], values[6, 5],
               values[0, 6], values[1, 6], values[2, 6], values[3, 6], values[4, 6], values[5, 6], values[6, 6])
    {
    }

    public Matrix7(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0], values[5][0], values[6][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1], values[5][1], values[6][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2], values[5][2], values[6][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3], values[5][3], values[6][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4], values[5][4], values[6][4],
               values[0][5], values[1][5], values[2][5], values[3][5], values[4][5], values[5][5], values[6][5],
               values[0][6], values[1][6], values[2][6], values[3][6], values[4][6], values[5][6], values[6][6])
    {
    }

    public Matrix7(in Matrix2 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), Vector7.Zero, Vector7.Zero, Vector7.Zero, Vector7.Zero, Vector7.Zero)
    {
    }

    public Matrix7(in Matrix3 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), Vector7.Zero, Vector7.Zero, Vector7.Zero, Vector7.Zero)
    {
    }

    public Matrix7(in Matrix4 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), Vector7.Zero, Vector7.Zero, Vector7.Zero)
    {
    }

    public Matrix7(in Matrix5 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), new Vector7(matrix[4]), Vector7.Zero, Vector7.Zero)
    {
    }

    public Matrix7(in Matrix6 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), new Vector7(matrix[4]), new Vector7(matrix[5]), Vector7.Zero)
    {
    }

    public Matrix7(in Matrix7 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix7(in Matrix8 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), new Vector7(matrix[4]), new Vector7(matrix[5]), new Vector7(matrix[6]))
    {
    }

    public Matrix7(in Matrix9 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), new Vector7(matrix[4]), new Vector7(matrix[5]), new Vector7(matrix[6]))
    {
    }

    public Matrix7(in Matrix10 matrix)
        : this(new Vector7(matrix[0]), new Vector7(matrix[1]), new Vector7(matrix[2]), new Vector7(matrix[3]), new Vector7(matrix[4]), new Vector7(matrix[5]), new Vector7(matrix[6]))
    {
    }

    public Matrix7(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix7(Matrix7* matrix)
        : this(*matrix)
    {
    }

    public Matrix7(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6],
               values[7], values[8], values[9], values[10], values[11], values[12], values[13],
               values[14], values[15], values[16], values[17], values[18], values[19], values[20],
               values[21], values[22], values[23], values[24], values[25], values[26], values[27],
               values[28], values[29], values[30], values[31], values[32], values[33], values[34],
               values[35], values[36], values[37], values[38], values[39], values[40], values[41],
               values[42], values[43], values[44], values[45], values[46], values[47], values[48])
    {
    }

    public Matrix7(Vector7* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6])
    {
    }

    public Matrix7(IEnumerable<Vector7> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix7(Vector7[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6])
    {
    }

    public Matrix7(Vector7 v0, Vector7 v1, Vector7 v2, Vector7 v3, Vector7 v4, Vector7 v5, Vector7 v6)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
        _c5 = v5;
        _c6 = v6;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix7 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4, -_c5, -_c6);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix7 Add(in Matrix7 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4, _c5 + second._c5, _c6 + second._c6);

    public readonly Matrix7 Add(params Matrix7[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix7 Add(Scalar Scalar) => Add(new Matrix7(Scalar));

    public readonly Matrix7 Increment() => Add(1);

    public readonly Matrix7 Decrement() => Add(-1);

    public readonly Matrix7 Subtract(in Matrix7 second) => Add(second.Negate());

    public readonly Matrix7 Subtract(params Matrix7[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix7 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector6 HomogeneousMultiply(in Vector6 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix7 Multiply(in Matrix7 second)
    {
        Vector7[] A = Rows;
        Vector7[] B = second.Columns;
        Scalar[,] C = new Scalar[7, 7];

        for (int r = 0; r < 7; ++r)
            for (int c = 0; c < 7; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix7(C);
    }

    public readonly Matrix7 Multiply(params Matrix7[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector7 Multiply(in Vector7 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4] + _c5[0] * vector[5] + _c6[0] * vector[6],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4] + _c5[1] * vector[5] + _c6[1] * vector[6],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4] + _c5[2] * vector[5] + _c6[2] * vector[6],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4] + _c5[3] * vector[5] + _c6[3] * vector[6],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4] + _c5[4] * vector[5] + _c6[4] * vector[6],
        _c0[5] * vector[0] + _c1[5] * vector[1] + _c2[5] * vector[2] + _c3[5] * vector[3] + _c4[5] * vector[4] + _c5[5] * vector[5] + _c6[5] * vector[6],
        _c0[6] * vector[0] + _c1[6] * vector[1] + _c2[6] * vector[2] + _c3[6] * vector[3] + _c4[6] * vector[4] + _c5[6] * vector[5] + _c6[6] * vector[6]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix7 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor, _c5 * factor, _c6 * factor);

    public readonly Matrix7 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix7 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix7 r = Identity;
        Matrix7 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix7 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix7 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor, _c5 % factor, _c6 % factor);

    public readonly Matrix7 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix7 result = this;
        Matrix7 exponent = this;
        Matrix7 squared = Multiply(this);
        Matrix7 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix7 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix7 result = Identity;
        Matrix7 exponent = this;
        Matrix7 squared = Multiply(this);
        Matrix7 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix7 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix7 result = Identity;
        Matrix7 exponent = this;
        Matrix7 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix7 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix7 ComponentwiseDivide(in Matrix7 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4), _c5.ComponentwiseDivide(second._c5), _c6.ComponentwiseDivide(second._c6));

    public readonly Matrix7 ComponentwiseMultiply(in Matrix7 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4), _c5.ComponentwiseMultiply(second._c5), _c6.ComponentwiseMultiply(second._c6));

    public readonly Matrix7 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function), _c5.ComponentwiseApply(function), _c6.ComponentwiseApply(function));

    public readonly Matrix7 ComponentwiseApply(Matrix7 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function), _c5.ComponentwiseApply(second._c5, function), _c6.ComponentwiseApply(second._c6, function));

    public readonly Matrix7 ComponentwiseApply(Matrix7 second, Matrix7 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function), _c5.ComponentwiseApply(second._c5, third._c5, function), _c6.ComponentwiseApply(second._c6, third._c6, function));

    public readonly Matrix7 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix7 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high), _c5.Clamp(low, high), _c6.Clamp(low, high));

    public readonly Matrix7 LinearInterpolate(in Matrix7 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix7 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 7; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 5 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4, Sub5, Sub6 };
    }

    internal readonly Matrix7 GetLinearIndependentForm()
    {
        Matrix7 m = this;

        for (int row = 0; row < 7; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 7; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 7; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector7</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace7 Solve(Vector7 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector7 x = vector;

            for (int i = 0; i < 7; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 7; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector7 x = vector;

            for (int i = 6; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix7 P, Matrix7 L, Matrix7 U) = PLUDecompose();
        VectorSpace7 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace7(SolveCG(vector));
    }

    public readonly VectorSpace7 Solve(VectorSpace7 vectorspace)
    {
        VectorSpace7 result = VectorSpace7.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace7 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector7, Matrix7>.Solve(Vector7 vector, out Vector7 solution)
    {
        VectorSpace7 space = Solve(vector);
        solution = Vector7.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector7 SolveCG(Vector7 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector7 x = vector;
        Vector7 r = vector - Multiply(vector);
        Vector7 d = r;

        for (int i = 0; i < 7; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector7 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector7 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix7 m = this;
        Vector7 v = vector;

        for (int row = 0; row < 7; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 7; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 7; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 6; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector7[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector7 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector7[] vectors = pairs.Select(p => p.vec).Distinct(Vector7.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector7 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector7 vec, Scalar val)[] pairs = new (Vector7, Scalar)[7];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 7; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector7 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector7 v_old = default;
        Vector7 v_new = Vector7.GetRandomCartesianUnitVector();
        Vector7 v_init = v_new;
        Matrix7 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector7 w = default;

        while ((w * v_init).IsZero)
            w = Vector7.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace7 GetEigenspace(Scalar eigenvalue) => VectorSpace7.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix7 P, Matrix7 S, Matrix7 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector7 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix7 P = new Matrix7(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v, pairs[5].v, pairs[6].v);
        Matrix7 S = new Matrix7(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ, pairs[5].λ, pairs[6].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix7 P, Matrix7 L, Matrix7 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4, 5, 6 };
        Matrix7 U = Identity;
        Matrix7 L = this;

        for (int i = 0; i < 6; ++i)
        {
            Vector7 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 7; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 7; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix3 A, Matrix4 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(3);

        return ((Matrix3)A, (Matrix4)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 7)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 7.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix7 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix7 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix7 Q, Matrix7 R) QRDecompose()
    {
        Matrix7 A = this;
        (Vector7 v0_0, Vector7 v0_1, Vector7 v0_2, Vector7 v0_3, Vector7 v0_4, Vector7 v0_5, Vector7 v0_6) = A;
        Vector7 v0 = v0_0 + new Vector7(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;
        v0_5 -= (2 * (v0 * v0_5)) * v0;
        v0_6 -= (2 * (v0 * v0_6)) * v0;

        Vector6 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4], v0_1[5], v0_1[6]);
        Vector6 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4], v0_2[5], v0_2[6]);
        Vector6 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4], v0_3[5], v0_3[6]);
        Vector6 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4], v0_4[5], v0_4[6]);
        Vector6 v1_4 = (v0_5[1], v0_5[2], v0_5[3], v0_5[4], v0_5[5], v0_5[6]);
        Vector6 v1_5 = (v0_6[1], v0_6[2], v0_6[3], v0_6[4], v0_6[5], v0_6[6]);
        Vector6 v1 = v1_0 + new Vector6(v1_0[0].Sign * v1_0.Length, 0, 0, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;
        v1_4 -= (2 * (v1 * v1_4)) * v1;
        v1_5 -= (2 * (v1 * v1_5)) * v1;

        Vector5 v2_0 = (v1_1[1], v1_1[2], v1_1[3], v1_1[4], v1_1[5]);
        Vector5 v2_1 = (v1_2[1], v1_2[2], v1_2[3], v1_2[4], v1_2[5]);
        Vector5 v2_2 = (v1_3[1], v1_3[2], v1_3[3], v1_3[4], v1_3[5]);
        Vector5 v2_3 = (v1_4[1], v1_4[2], v1_4[3], v1_4[4], v1_4[5]);
        Vector5 v2_4 = (v1_5[1], v1_5[2], v1_5[3], v1_5[4], v1_5[5]);
        Vector5 v2 = v2_0 + new Vector5(v2_0[0].Sign * v2_0.Length, 0, 0, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;
        v2_3 -= (2 * (v2 * v2_3)) * v2;
        v2_4 -= (2 * (v2 * v2_4)) * v2;

        Vector4 v3_0 = (v2_1[1], v2_1[2], v2_1[3], v2_1[4]);
        Vector4 v3_1 = (v2_2[1], v2_2[2], v2_2[3], v2_2[4]);
        Vector4 v3_2 = (v2_3[1], v2_3[2], v2_3[3], v2_3[4]);
        Vector4 v3_3 = (v2_4[1], v2_4[2], v2_4[3], v2_4[4]);
        Vector4 v3 = v3_0 + new Vector4(v3_0[0].Sign * v3_0.Length, 0, 0, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;
        v3_2 -= (2 * (v3 * v3_2)) * v3;
        v3_3 -= (2 * (v3 * v3_3)) * v3;

        Vector3 v4_0 = (v3_1[1], v3_1[2], v3_1[3]);
        Vector3 v4_1 = (v3_2[1], v3_2[2], v3_2[3]);
        Vector3 v4_2 = (v3_3[1], v3_3[2], v3_3[3]);
        Vector3 v4 = v4_0 + new Vector3(v4_0[0].Sign * v4_0.Length, 0, 0);

        v4 = ~v4;
        v4_0 -= (2 * (v4 * v4_0)) * v4;
        v4_1 -= (2 * (v4 * v4_1)) * v4;
        v4_2 -= (2 * (v4 * v4_2)) * v4;

        Vector2 v5_0 = (v4_1[1], v4_1[2]);
        Vector2 v5_1 = (v4_2[1], v4_2[2]);
        Vector2 v5 = v5_0 + new Vector2(v5_0[0].Sign * v5_0.Length, 0);

        v5 = ~v5;
        v5_0 -= (2 * (v5 * v5_0)) * v5;
        v5_1 -= (2 * (v5 * v5_1)) * v5;

        Matrix7 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0], v0_5[0], v0_6[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0], v1_4[0], v1_5[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0], v2_3[0], v2_4[0],
            0, 0, 0, v3_0[0], v3_1[0], v3_2[0], v3_3[0],
            0, 0, 0, 0, v4_0[0], v4_1[0], v4_2[0],
            0, 0, 0, 0, 0, v5_0[0], v5_1[0],
            0, 0, 0, 0, 0, 0, v5_1[1]
        );
        Matrix7 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];
        Q *= Identity[4.., 4.., v4.HouseholderMatrix];
        Q *= Identity[5.., 5.., v5.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix7 Q, Matrix7 R) QRDecomposeUnstable()
    {
        Matrix7 H0;
        Matrix7 A0 = this;
        Vector7 v0 = A0[0];

        v0 += new Vector7(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix6 H1;
        Matrix6 A1 = A0.Minors[0, 0];
        Vector6 v1 = A1[0];

        v1 += new Vector6(A1[0, 0].Sign * v1.Length, 0, 0, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix5 H2;
        Matrix5 A2 = A1.Minors[0, 0];
        Vector5 v2 = A2[0];

        v2 += new Vector5(A2[0, 0].Sign * v2.Length, 0, 0, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix4 H3;
        Matrix4 A3 = A2.Minors[0, 0];
        Vector4 v3 = A3[0];

        v3 += new Vector4(A3[0, 0].Sign * v3.Length, 0, 0, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Matrix3 H4;
        Matrix3 A4 = A3.Minors[0, 0];
        Vector3 v4 = A4[0];

        v4 += new Vector3(A4[0, 0].Sign * v4.Length, 0, 0);
        H4 = v4.HouseholderMatrix;
        A4 = H4 * A4;

        Matrix2 H5;
        Matrix2 A5 = A4.Minors[0, 0];
        Vector2 v5 = A5[0];

        v5 += new Vector2(A5[0, 0].Sign * v5.Length, 0);
        H5 = v5.HouseholderMatrix;
        A5 = H5 * A5;

        Scalar A6 = -A5[1, 1]; // TODO : ????????
        Matrix7[] H = new Matrix7[7];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4.., 4.., H4];
        H[5] = H[5][5.., 5.., H5];
        H[6] = H[6][6, 6, -1];

        return (
            Q: H[6] * H[5] * H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed * H[5].Transposed * H[6].Transposed
        );
    }

    public readonly (Matrix7 U, Matrix7 D) IwasawaDecompose()
    {
        Matrix7 ONB = OrthonormalBasis;
        Matrix7 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace7 GetKrylovSpace(Vector7 vector) => VectorSpace7.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix7 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance) && _c5.Is(o._c5, tolerance) && _c6.Is(o._c6, tolerance);

    public readonly bool Is(Matrix7 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix7 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix7 v && Equals(v);

    public readonly bool Equals(Matrix7 other) => Is(other);

    public readonly int CompareTo(Matrix7 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix7 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix7)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 7x7-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 7x7-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>5x5 sub-matrix</returns>
    public readonly Matrix5 ToMatrix5() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]
    );

    /// <summary>
    /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>6x6 sub-matrix</returns>
    public readonly Matrix6 ToMatrix6() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5]
    );

    /// <summary>
    /// Creates the homogeneous 8x8 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 8x8 transformation matrix.</returns>
    public readonly Matrix8 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        _c4.ToHomogeneousCoordinates(),
        _c5.ToHomogeneousCoordinates(),
        _c6.ToHomogeneousCoordinates(),
        Vector8.UnitVectors[7]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector7> ToIsomorphism()
    {
        Matrix7 copy = this;

        return new Function<Vector7>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector7> GetEnumerator() => ((IEnumerable<Vector7>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_5_0, out Scalar x_6_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_5_1, out Scalar x_6_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_5_2, out Scalar x_6_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_5_3, out Scalar x_6_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4, out Scalar x_5_4, out Scalar x_6_4, out Scalar x_0_5, out Scalar x_1_5, out Scalar x_2_5, out Scalar x_3_5, out Scalar x_4_5, out Scalar x_5_5, out Scalar x_6_5, out Scalar x_0_6, out Scalar x_1_6, out Scalar x_2_6, out Scalar x_3_6, out Scalar x_4_6, out Scalar x_5_6, out Scalar x_6_6) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, x_6_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_5_1, x_6_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_5_2, x_6_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_5_3, x_6_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4, x_5_4, x_6_4, x_0_5, x_1_5, x_2_5, x_3_5, x_4_5, x_5_5, x_6_5, x_0_6, x_1_6, x_2_6, x_3_6, x_4_6, x_5_6, x_6_6) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6]);

    public readonly void Deconstruct(out Vector7 v0, out Vector7 v1, out Vector7 v2, out Vector7 v3, out Vector7 v4, out Vector7 v5, out Vector7 v6) =>
        (v0, v1, v2, v3, v4, v5, v6) = (_c0, _c1, _c2, _c3, _c4, _c5, _c6);

    public readonly object Clone() => new Matrix7(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector7 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        5 => _c5,
        6 => _c6,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 6.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix7 SetColumn(int column, in Vector7 vector)
    {
        if (column < 0 || column >= 7)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 6.");

        Vector7[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..7);

    public readonly Matrix7 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..7, values);

    public readonly Matrix7 SwapColumns(int src_col, int dst_col)
    {
        Vector7 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix7 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix7 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix7 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector7 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix7 SetRow(int row, in Vector7 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..7, rows);

    public readonly Matrix7 SetRows(Range rows, in MatrixNM values) => SetRegion(0..7, rows, values);

    public readonly Matrix7 SwapRows(int src_row, int dst_row)
    {
        Vector7 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix7 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix7 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix7 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(7);
        int[] idx_r = rows.GetOffsets(7);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix7 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(7);
        int[] idx_r = rows.GetOffsets(7);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix7(t);
    }

    /// <summary>
    /// Returns the matrix' 6x6-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>6x6-minor</returns>
    public readonly Matrix6 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector6(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix7 Add(Matrix7 m1, Matrix7 m2) => m1.Add(m2);

    public static Matrix7 Subtract(Matrix7 m1, Matrix7 m2) => m1.Subtract(m2);

    public static Matrix7 Multiply(Matrix7 m1, Matrix7 m2) => m1.Multiply(m2);

    public static Vector7 Multiply(Matrix7 m, Vector7 v) => m.Multiply(v);

    public static Matrix7 Multiply(Matrix7 m, Scalar s) => m.Multiply(s);

    public static Matrix7 Divide(Matrix7 m, Scalar s) => m.Divide(s);

    public static Matrix7 Exp(Matrix7 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix7 Sin(Matrix7 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix7 Cos(Matrix7 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix7 CracovianProduct(in Matrix7 first, in Matrix7 second) => second.Transposed.Multiply(in second);

    public static Matrix7 HadamardProduct(in Matrix7 first, in Matrix7 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix7 first, Matrix7 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix7 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[7, 7];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix7 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix7 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[7, 7];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix7 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix7 DiagonalMatrix(in Vector7 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4], diagonal[5], diagonal[6]);

    public static Matrix7 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4, Scalar d5, Scalar d6) => (
        d0, 0, 0, 0, 0, 0, 0,
        0, d1, 0, 0, 0, 0, 0,
        0, 0, d2, 0, 0, 0, 0,
        0, 0, 0, d3, 0, 0, 0,
        0, 0, 0, 0, d4, 0, 0,
        0, 0, 0, 0, 0, d5, 0,
        0, 0, 0, 0, 0, 0, d6
    );
    
    public static Matrix7 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix7 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix7 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 7))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 6.", nameof(column_indices));

        Vector7[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix7 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix7 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix7 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix7 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix7 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 7 || arr.GetLength(1) < 7 ? throw new ArgumentException("The array must have a minimum size of 7x7.", nameof(arr)) : new Matrix7(arr);

    public static Matrix7 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 49 => throw new ArgumentException("The array must have a minimum length of 49.", nameof(arr)),
        _ => new Matrix7(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4], arr[ 5], arr[ 6],
            arr[ 7], arr[ 8], arr[ 9], arr[10], arr[11], arr[12], arr[13],
            arr[14], arr[15], arr[16], arr[17], arr[18], arr[19], arr[20],
            arr[21], arr[22], arr[23], arr[24], arr[25], arr[26], arr[27],
            arr[28], arr[29], arr[30], arr[31], arr[32], arr[33], arr[34],
            arr[35], arr[36], arr[37], arr[38], arr[39], arr[40], arr[41],
            arr[42], arr[43], arr[44], arr[45], arr[46], arr[47], arr[48]
        )
    };

    public static Matrix7 FromRows(in Vector7[] arr) => FromColumns(arr).Transposed;

    public static Matrix7 FromColumns(in Vector7[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 7 } => new Matrix7(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0], arr[5][0], arr[6][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1], arr[5][1], arr[6][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2], arr[5][2], arr[6][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3], arr[5][3], arr[6][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4], arr[5][4], arr[6][4],
            arr[0][5], arr[1][5], arr[2][5], arr[3][5], arr[4][5], arr[5][5], arr[6][5],
            arr[0][6], arr[1][6], arr[2][6], arr[3][6], arr[4][6], arr[5][6], arr[6][6]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 7.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix7 m1, Matrix7 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix7 m1, Matrix7 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix7 operator +(in Matrix7 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix7 operator -(in Matrix7 m) => m.Negate();

    public static Matrix7 operator +(Scalar f, in Matrix7 m) => m.Add(f);

    public static Matrix7 operator +(in Matrix7 m, Scalar f) => m.Add(f);

    public static Matrix7 operator -(Scalar f, in Matrix7 m) => new Matrix7(f).Subtract(in m);

    public static Matrix7 operator -(in Matrix7 m, Scalar f) => m.Subtract(f);

    public static Matrix7 operator ++(in Matrix7 m) => m.Increment();

    public static Matrix7 operator --(in Matrix7 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix7 operator +(in Matrix7 m1, in Matrix7 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix7 operator -(in Matrix7 m1, in Matrix7 m2) => m1.Subtract(in m2);

    public static Vector7 operator *(in Matrix7 m, in Vector7 v) => m.Multiply(in v);

    public static Matrix7 operator *(in Matrix7 m1, in Matrix7 m2) => m1.Multiply(in m2);

    public static Matrix7 operator *(in Matrix7 m, Scalar f) => m.Multiply(f);

    public static Matrix7 operator *(Scalar f, in Matrix7 m) => m.Multiply(f);

    public static Matrix7 operator ^(in Matrix7 m, int c) => m.Power(c);

    public static Matrix7 operator ^(in Matrix7 m1, in Matrix7 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace7 operator |(Matrix7 A, Vector7 b) => A.Solve(b);

    public static VectorSpace7 operator |(Matrix7 A, VectorSpace7 b) => A.Solve(b);

    public static Matrix7 operator /(Matrix7 m1, Matrix7 m2) => m1.Multiply(m2.Inverse);

    public static Matrix7 operator /(in Matrix7 m, Scalar f) => m.Divide(f);

    public static Matrix7 operator %(in Matrix7 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector7 x0, Vector7 x1, Vector7 x2, Vector7 x3, Vector7 x4, Vector7 x5, Vector7 x6) (in Matrix7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

    public static implicit operator Matrix7((Vector7 x0, Vector7 x1, Vector7 x2, Vector7 x3, Vector7 x4, Vector7 x5, Vector7 x6) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c6) (in Matrix7 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6]);

    public static explicit operator Matrix7(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6) c6) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6) (in Matrix7 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0], m._c5[0], m._c6[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1], m._c5[1], m._c6[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2], m._c5[2], m._c6[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3], m._c5[3], m._c6[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4], m._c5[4], m._c6[4],
        m._c0[5], m._c1[5], m._c2[5], m._c3[5], m._c4[5], m._c5[5], m._c6[5],
        m._c0[6], m._c1[6], m._c2[6], m._c3[6], m._c4[6], m._c5[6], m._c6[6]
    );

    public static implicit operator Matrix7(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0, t.x_5_0, t.x_6_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1, t.x_5_1, t.x_6_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2, t.x_5_2, t.x_6_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3, t.x_5_3, t.x_6_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4, t.x_5_4, t.x_6_4,
        t.x_0_5, t.x_1_5, t.x_2_5, t.x_3_5, t.x_4_5, t.x_5_5, t.x_6_5,
        t.x_0_6, t.x_1_6, t.x_2_6, t.x_3_6, t.x_4_6, t.x_5_6, t.x_6_6
    );

    public static explicit operator Matrix7(Scalar m) => new(m);

    public static implicit operator Matrix7(in Vector7[] arr) => new(arr);

    public static implicit operator Vector7[](in Matrix7 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix7 m) => m.ToArray();

    public static implicit operator Matrix7(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix7 m) => m.Coefficients;

    public static implicit operator Matrix7(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix7 m) => new(m.Coefficients);

    public static explicit operator Matrix7(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix7 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix7>(m);

    public static implicit operator Function<Vector7>(in Matrix7 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix7EqualityComparer
        : IEqualityComparer<Matrix7>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix7 x, Matrix7 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix7 obj) => obj.GetHashCode();
    }
}

public static class Matrix7Extensions
{
    public static Matrix7 Sum(this IEnumerable<Matrix7> matrices) => Matrix7.Zero.Add(matrices.ToArray());

    public static Matrix7 Average(this IEnumerable<Matrix7> matrices)
    {
        Matrix7 mat = Matrix7.Zero;
        long count = 0;

        foreach (Matrix7 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix8

/// <summary>
/// Represents a square 8x8 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix8
    : Algebra<Scalar>.IMatrix<Vector8, Matrix8>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix8, MatrixNM>
    , INative<Matrix8>
    , IEnumerable<Vector8>
    // , Function<Matrix8, Vector8>
    , IEnumerable<Scalar>
    , IComparable<Matrix8>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix8>
    , IModulusOperators<Matrix8, Scalar, Matrix8>
    , IMultiplyOperators<Matrix8, Matrix8, Matrix8>
    , IMultiplyOperators<Scalar, Matrix8, Matrix8>
    , IMultiplyOperators<Matrix8, Scalar, Matrix8>
    , IDivisionOperators<Matrix8, Scalar, Matrix8>
    , IMultiplyOperators<Vector8, Matrix8, Vector8>
    , IMultiplyOperators<Matrix8, Vector8, Vector8>
    , IDecrementOperators<Matrix8>
    , IAdditionOperators<Matrix8, Matrix8, Matrix8>
    , ISubtractionOperators<Matrix8, Matrix8, Matrix8>
    , IUnaryPlusOperators<Matrix8, Matrix8>
    , IUnaryNegationOperators<Matrix8, Matrix8>
    , IAdditiveIdentity<Matrix8, Matrix8>
    , IMultiplicativeIdentity<Matrix8, Matrix8>
    , IComparisonOperators<Matrix8, Matrix8>
    , IEqualityOperators<Matrix8, Matrix8>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector8 _c0;
    private readonly Vector8 _c1;
    private readonly Vector8 _c2;
    private readonly Vector8 _c3;
    private readonly Vector8 _c4;
    private readonly Vector8 _c5;
    private readonly Vector8 _c6;
    private readonly Vector8 _c7;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (8, 8);

    /// <summary>
    /// The 8x8 zero matrix
    /// </summary>
    public static Matrix8 Zero { get; } = new Matrix8(0);

    /// <summary>
    /// The 8x8 identity (unit) matrix
    /// </summary>
    public static Matrix8 Identity { get; } = new(1);

    static Matrix8 IRing<Matrix8>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix8"/>.
    /// </summary>
    public static Matrix8EqualityComparer EqualityComparer { get; } = new Matrix8EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix8"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix8);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector8 this[int column] => GetColumn(column);

    public readonly Vector8 this[Index column] => this[column.GetOffset(8)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix8 this[int column, in Vector8 value] => SetColumn(column, value);

    public readonly Matrix8 this[Index column, in Vector8 value] => this[column.GetOffset(8), value];

    public readonly Matrix8 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix8 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 8 || column < 0 || column >= 8)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 7.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix8(scalars);
        }
    }

    public readonly Matrix8 this[Index column, Index row, Scalar value] => this[column.GetOffset(8), row.GetOffset(8), value];

    public readonly Matrix8 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix7> Minors => new ReadOnlyIndexer<int, int, Matrix7>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (8, 8);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[8, 8]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7] },
        { _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7] },
        { _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7] },
        { _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[64] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector8 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4], _c5[5], _c6[6], _c7[7]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector8[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector8[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix8 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 6 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4(), ToMatrix5(), ToMatrix6(), ToMatrix7());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix8 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7],
        _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7],
        _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7],
        _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix8::Inverse' instead.")]
    public readonly Matrix8 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix8 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix8 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector8[] vs = Columns;

            for (int i = 0; i < 8; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant
        - GetMinor(0, 5).Determinant
        + GetMinor(0, 6).Determinant
        - GetMinor(0, 7).Determinant;

    public readonly Matrix8 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix8 m = this;
            // TODO : verify the following code
            Matrix8 u = Identity;

            for (int i = 0; i < 8; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 8; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 8; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 8 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector8[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector8.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 8x8 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary && _c5.IsBinary && _c6.IsBinary && _c7.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector8[] rows = Rows;

            for (int i = 0; i < 8; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 8; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 8; ++c)
                for (int r = 0; r < 8; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 8; ++c)
                for (int r = c + 1; r < 8; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix8 ctc = Transposed * this;

            return (ctc - new Matrix8(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 8x8-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix8(Scalar scale)
        : this(scale, 0, 0, 0, 0, 0, 0, 0,
               0, scale, 0, 0, 0, 0, 0, 0,
               0, 0, scale, 0, 0, 0, 0, 0,
               0, 0, 0, scale, 0, 0, 0, 0,
               0, 0, 0, 0, scale, 0, 0, 0,
               0, 0, 0, 0, 0, scale, 0, 0,
               0, 0, 0, 0, 0, 0, scale, 0,
               0, 0, 0, 0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 8x8-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    /// <param name="diag_5">The diagonal element at the position (5, 5).</param>
    /// <param name="diag_6">The diagonal element at the position (6, 6).</param>
    /// <param name="diag_7">The diagonal element at the position (7, 7).</param>
    public Matrix8(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4, Scalar diag_5, Scalar diag_6, Scalar diag_7)
        : this(diag_0, 0, 0, 0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0, 0, 0, 0,
               0, 0, diag_2, 0, 0, 0, 0, 0,
               0, 0, 0, diag_3, 0, 0, 0, 0,
               0, 0, 0, 0, diag_4, 0, 0, 0,
               0, 0, 0, 0, 0, diag_5, 0, 0,
               0, 0, 0, 0, 0, 0, diag_6, 0,
               0, 0, 0, 0, 0, 0, 0, diag_7)
    {
    }

    public Matrix8(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_5_0, Scalar s_6_0, Scalar s_7_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_5_1, Scalar s_6_1, Scalar s_7_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_5_2, Scalar s_6_2, Scalar s_7_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_5_3, Scalar s_6_3, Scalar s_7_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4, Scalar s_5_4, Scalar s_6_4, Scalar s_7_4, Scalar s_0_5, Scalar s_1_5, Scalar s_2_5, Scalar s_3_5, Scalar s_4_5, Scalar s_5_5, Scalar s_6_5, Scalar s_7_5, Scalar s_0_6, Scalar s_1_6, Scalar s_2_6, Scalar s_3_6, Scalar s_4_6, Scalar s_5_6, Scalar s_6_6, Scalar s_7_6, Scalar s_0_7, Scalar s_1_7, Scalar s_2_7, Scalar s_3_7, Scalar s_4_7, Scalar s_5_7, Scalar s_6_7, Scalar s_7_7)
        : this(new Vector8(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4, s_0_5, s_0_6, s_0_7),
               new Vector8(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4, s_1_5, s_1_6, s_1_7),
               new Vector8(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4, s_2_5, s_2_6, s_2_7),
               new Vector8(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4, s_3_5, s_3_6, s_3_7),
               new Vector8(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4, s_4_5, s_4_6, s_4_7),
               new Vector8(s_5_0, s_5_1, s_5_2, s_5_3, s_5_4, s_5_5, s_5_6, s_5_7),
               new Vector8(s_6_0, s_6_1, s_6_2, s_6_3, s_6_4, s_6_5, s_6_6, s_6_7),
               new Vector8(s_7_0, s_7_1, s_7_2, s_7_3, s_7_4, s_7_5, s_7_6, s_7_7))
    {
    }

    public Matrix8(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7],
               values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15],
               values[16], values[17], values[18], values[19], values[20], values[21], values[22], values[23],
               values[24], values[25], values[26], values[27], values[28], values[29], values[30], values[31],
               values[32], values[33], values[34], values[35], values[36], values[37], values[38], values[39],
               values[40], values[41], values[42], values[43], values[44], values[45], values[46], values[47],
               values[48], values[49], values[50], values[51], values[52], values[53], values[54], values[55],
               values[56], values[57], values[58], values[59], values[60], values[61], values[62], values[63])
    {
    }

    public Matrix8(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0], values[5, 0], values[6, 0], values[7, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1], values[5, 1], values[6, 1], values[7, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2], values[5, 2], values[6, 2], values[7, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3], values[5, 3], values[6, 3], values[7, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4], values[5, 4], values[6, 4], values[7, 4],
               values[0, 5], values[1, 5], values[2, 5], values[3, 5], values[4, 5], values[5, 5], values[6, 5], values[7, 5],
               values[0, 6], values[1, 6], values[2, 6], values[3, 6], values[4, 6], values[5, 6], values[6, 6], values[7, 6],
               values[0, 7], values[1, 7], values[2, 7], values[3, 7], values[4, 7], values[5, 7], values[6, 7], values[7, 7])
    {
    }

    public Matrix8(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0], values[5][0], values[6][0], values[7][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1], values[5][1], values[6][1], values[7][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2], values[5][2], values[6][2], values[7][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3], values[5][3], values[6][3], values[7][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4], values[5][4], values[6][4], values[7][4],
               values[0][5], values[1][5], values[2][5], values[3][5], values[4][5], values[5][5], values[6][5], values[7][5],
               values[0][6], values[1][6], values[2][6], values[3][6], values[4][6], values[5][6], values[6][6], values[7][6],
               values[0][7], values[1][7], values[2][7], values[3][7], values[4][7], values[5][7], values[6][7], values[7][7])
    {
    }

    public Matrix8(in Matrix2 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero)
    {
    }

    public Matrix8(in Matrix3 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero)
    {
    }

    public Matrix8(in Matrix4 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), Vector8.Zero, Vector8.Zero, Vector8.Zero, Vector8.Zero)
    {
    }

    public Matrix8(in Matrix5 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), new Vector8(matrix[4]), Vector8.Zero, Vector8.Zero, Vector8.Zero)
    {
    }

    public Matrix8(in Matrix6 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), new Vector8(matrix[4]), new Vector8(matrix[5]), Vector8.Zero, Vector8.Zero)
    {
    }

    public Matrix8(in Matrix7 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), new Vector8(matrix[4]), new Vector8(matrix[5]), new Vector8(matrix[6]), Vector8.Zero)
    {
    }

    public Matrix8(in Matrix8 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix8(in Matrix9 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), new Vector8(matrix[4]), new Vector8(matrix[5]), new Vector8(matrix[6]), new Vector8(matrix[7]))
    {
    }

    public Matrix8(in Matrix10 matrix)
        : this(new Vector8(matrix[0]), new Vector8(matrix[1]), new Vector8(matrix[2]), new Vector8(matrix[3]), new Vector8(matrix[4]), new Vector8(matrix[5]), new Vector8(matrix[6]), new Vector8(matrix[7]))
    {
    }

    public Matrix8(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix8(Matrix8* matrix)
        : this(*matrix)
    {
    }

    public Matrix8(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7],
               values[8], values[9], values[10], values[11], values[12], values[13], values[14], values[15],
               values[16], values[17], values[18], values[19], values[20], values[21], values[22], values[23],
               values[24], values[25], values[26], values[27], values[28], values[29], values[30], values[31],
               values[32], values[33], values[34], values[35], values[36], values[37], values[38], values[39],
               values[40], values[41], values[42], values[43], values[44], values[45], values[46], values[47],
               values[48], values[49], values[50], values[51], values[52], values[53], values[54], values[55],
               values[56], values[57], values[58], values[59], values[60], values[61], values[62], values[63])
    {
    }

    public Matrix8(Vector8* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7])
    {
    }

    public Matrix8(IEnumerable<Vector8> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix8(Vector8[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7])
    {
    }

    public Matrix8(Vector8 v0, Vector8 v1, Vector8 v2, Vector8 v3, Vector8 v4, Vector8 v5, Vector8 v6, Vector8 v7)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
        _c5 = v5;
        _c6 = v6;
        _c7 = v7;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix8 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4, -_c5, -_c6, -_c7);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix8 Add(in Matrix8 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4, _c5 + second._c5, _c6 + second._c6, _c7 + second._c7);

    public readonly Matrix8 Add(params Matrix8[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix8 Add(Scalar Scalar) => Add(new Matrix8(Scalar));

    public readonly Matrix8 Increment() => Add(1);

    public readonly Matrix8 Decrement() => Add(-1);

    public readonly Matrix8 Subtract(in Matrix8 second) => Add(second.Negate());

    public readonly Matrix8 Subtract(params Matrix8[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix8 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector7 HomogeneousMultiply(in Vector7 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix8 Multiply(in Matrix8 second)
    {
        Vector8[] A = Rows;
        Vector8[] B = second.Columns;
        Scalar[,] C = new Scalar[8, 8];

        for (int r = 0; r < 8; ++r)
            for (int c = 0; c < 8; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix8(C);
    }

    public readonly Matrix8 Multiply(params Matrix8[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector8 Multiply(in Vector8 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4] + _c5[0] * vector[5] + _c6[0] * vector[6] + _c7[0] * vector[7],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4] + _c5[1] * vector[5] + _c6[1] * vector[6] + _c7[1] * vector[7],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4] + _c5[2] * vector[5] + _c6[2] * vector[6] + _c7[2] * vector[7],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4] + _c5[3] * vector[5] + _c6[3] * vector[6] + _c7[3] * vector[7],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4] + _c5[4] * vector[5] + _c6[4] * vector[6] + _c7[4] * vector[7],
        _c0[5] * vector[0] + _c1[5] * vector[1] + _c2[5] * vector[2] + _c3[5] * vector[3] + _c4[5] * vector[4] + _c5[5] * vector[5] + _c6[5] * vector[6] + _c7[5] * vector[7],
        _c0[6] * vector[0] + _c1[6] * vector[1] + _c2[6] * vector[2] + _c3[6] * vector[3] + _c4[6] * vector[4] + _c5[6] * vector[5] + _c6[6] * vector[6] + _c7[6] * vector[7],
        _c0[7] * vector[0] + _c1[7] * vector[1] + _c2[7] * vector[2] + _c3[7] * vector[3] + _c4[7] * vector[4] + _c5[7] * vector[5] + _c6[7] * vector[6] + _c7[7] * vector[7]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix8 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor, _c5 * factor, _c6 * factor, _c7 * factor);

    public readonly Matrix8 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix8 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix8 r = Identity;
        Matrix8 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix8 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix8 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor, _c5 % factor, _c6 % factor, _c7 % factor);

    public readonly Matrix8 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix8 result = this;
        Matrix8 exponent = this;
        Matrix8 squared = Multiply(this);
        Matrix8 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix8 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix8 result = Identity;
        Matrix8 exponent = this;
        Matrix8 squared = Multiply(this);
        Matrix8 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix8 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix8 result = Identity;
        Matrix8 exponent = this;
        Matrix8 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix8 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix8 ComponentwiseDivide(in Matrix8 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4), _c5.ComponentwiseDivide(second._c5), _c6.ComponentwiseDivide(second._c6), _c7.ComponentwiseDivide(second._c7));

    public readonly Matrix8 ComponentwiseMultiply(in Matrix8 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4), _c5.ComponentwiseMultiply(second._c5), _c6.ComponentwiseMultiply(second._c6), _c7.ComponentwiseMultiply(second._c7));

    public readonly Matrix8 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function), _c5.ComponentwiseApply(function), _c6.ComponentwiseApply(function), _c7.ComponentwiseApply(function));

    public readonly Matrix8 ComponentwiseApply(Matrix8 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function), _c5.ComponentwiseApply(second._c5, function), _c6.ComponentwiseApply(second._c6, function), _c7.ComponentwiseApply(second._c7, function));

    public readonly Matrix8 ComponentwiseApply(Matrix8 second, Matrix8 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function), _c5.ComponentwiseApply(second._c5, third._c5, function), _c6.ComponentwiseApply(second._c6, third._c6, function), _c7.ComponentwiseApply(second._c7, third._c7, function));

    public readonly Matrix8 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix8 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high), _c5.Clamp(low, high), _c6.Clamp(low, high), _c7.Clamp(low, high));

    public readonly Matrix8 LinearInterpolate(in Matrix8 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix8 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 8; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 6 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4, Sub5, Sub6, Sub7 };
    }

    internal readonly Matrix8 GetLinearIndependentForm()
    {
        Matrix8 m = this;

        for (int row = 0; row < 8; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 8; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 8; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector8</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace8 Solve(Vector8 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector8 x = vector;

            for (int i = 0; i < 8; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 8; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector8 x = vector;

            for (int i = 7; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix8 P, Matrix8 L, Matrix8 U) = PLUDecompose();
        VectorSpace8 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace8(SolveCG(vector));
    }

    public readonly VectorSpace8 Solve(VectorSpace8 vectorspace)
    {
        VectorSpace8 result = VectorSpace8.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace8 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector8, Matrix8>.Solve(Vector8 vector, out Vector8 solution)
    {
        VectorSpace8 space = Solve(vector);
        solution = Vector8.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector8 SolveCG(Vector8 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector8 x = vector;
        Vector8 r = vector - Multiply(vector);
        Vector8 d = r;

        for (int i = 0; i < 8; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector8 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector8 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix8 m = this;
        Vector8 v = vector;

        for (int row = 0; row < 8; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 8; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 8; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 7; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector8[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector8 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector8[] vectors = pairs.Select(p => p.vec).Distinct(Vector8.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector8 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector8 vec, Scalar val)[] pairs = new (Vector8, Scalar)[8];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 8; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector8 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector8 v_old = default;
        Vector8 v_new = Vector8.GetRandomCartesianUnitVector();
        Vector8 v_init = v_new;
        Matrix8 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector8 w = default;

        while ((w * v_init).IsZero)
            w = Vector8.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace8 GetEigenspace(Scalar eigenvalue) => VectorSpace8.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix8 P, Matrix8 S, Matrix8 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector8 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix8 P = new Matrix8(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v, pairs[5].v, pairs[6].v, pairs[7].v);
        Matrix8 S = new Matrix8(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ, pairs[5].λ, pairs[6].λ, pairs[7].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix8 P, Matrix8 L, Matrix8 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4, 5, 6, 7 };
        Matrix8 U = Identity;
        Matrix8 L = this;

        for (int i = 0; i < 7; ++i)
        {
            Vector8 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 8; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 8; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix4 A, Matrix4 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(4);

        return ((Matrix4)A, (Matrix4)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 8)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 8.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix8 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix8 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix8 Q, Matrix8 R) QRDecompose()
    {
        Matrix8 A = this;
        (Vector8 v0_0, Vector8 v0_1, Vector8 v0_2, Vector8 v0_3, Vector8 v0_4, Vector8 v0_5, Vector8 v0_6, Vector8 v0_7) = A;
        Vector8 v0 = v0_0 + new Vector8(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;
        v0_5 -= (2 * (v0 * v0_5)) * v0;
        v0_6 -= (2 * (v0 * v0_6)) * v0;
        v0_7 -= (2 * (v0 * v0_7)) * v0;

        Vector7 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4], v0_1[5], v0_1[6], v0_1[7]);
        Vector7 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4], v0_2[5], v0_2[6], v0_2[7]);
        Vector7 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4], v0_3[5], v0_3[6], v0_3[7]);
        Vector7 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4], v0_4[5], v0_4[6], v0_4[7]);
        Vector7 v1_4 = (v0_5[1], v0_5[2], v0_5[3], v0_5[4], v0_5[5], v0_5[6], v0_5[7]);
        Vector7 v1_5 = (v0_6[1], v0_6[2], v0_6[3], v0_6[4], v0_6[5], v0_6[6], v0_6[7]);
        Vector7 v1_6 = (v0_7[1], v0_7[2], v0_7[3], v0_7[4], v0_7[5], v0_7[6], v0_7[7]);
        Vector7 v1 = v1_0 + new Vector7(v1_0[0].Sign * v1_0.Length, 0, 0, 0, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;
        v1_4 -= (2 * (v1 * v1_4)) * v1;
        v1_5 -= (2 * (v1 * v1_5)) * v1;
        v1_6 -= (2 * (v1 * v1_6)) * v1;

        Vector6 v2_0 = (v1_1[1], v1_1[2], v1_1[3], v1_1[4], v1_1[5], v1_1[6]);
        Vector6 v2_1 = (v1_2[1], v1_2[2], v1_2[3], v1_2[4], v1_2[5], v1_2[6]);
        Vector6 v2_2 = (v1_3[1], v1_3[2], v1_3[3], v1_3[4], v1_3[5], v1_3[6]);
        Vector6 v2_3 = (v1_4[1], v1_4[2], v1_4[3], v1_4[4], v1_4[5], v1_4[6]);
        Vector6 v2_4 = (v1_5[1], v1_5[2], v1_5[3], v1_5[4], v1_5[5], v1_5[6]);
        Vector6 v2_5 = (v1_6[1], v1_6[2], v1_6[3], v1_6[4], v1_6[5], v1_6[6]);
        Vector6 v2 = v2_0 + new Vector6(v2_0[0].Sign * v2_0.Length, 0, 0, 0, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;
        v2_3 -= (2 * (v2 * v2_3)) * v2;
        v2_4 -= (2 * (v2 * v2_4)) * v2;
        v2_5 -= (2 * (v2 * v2_5)) * v2;

        Vector5 v3_0 = (v2_1[1], v2_1[2], v2_1[3], v2_1[4], v2_1[5]);
        Vector5 v3_1 = (v2_2[1], v2_2[2], v2_2[3], v2_2[4], v2_2[5]);
        Vector5 v3_2 = (v2_3[1], v2_3[2], v2_3[3], v2_3[4], v2_3[5]);
        Vector5 v3_3 = (v2_4[1], v2_4[2], v2_4[3], v2_4[4], v2_4[5]);
        Vector5 v3_4 = (v2_5[1], v2_5[2], v2_5[3], v2_5[4], v2_5[5]);
        Vector5 v3 = v3_0 + new Vector5(v3_0[0].Sign * v3_0.Length, 0, 0, 0, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;
        v3_2 -= (2 * (v3 * v3_2)) * v3;
        v3_3 -= (2 * (v3 * v3_3)) * v3;
        v3_4 -= (2 * (v3 * v3_4)) * v3;

        Vector4 v4_0 = (v3_1[1], v3_1[2], v3_1[3], v3_1[4]);
        Vector4 v4_1 = (v3_2[1], v3_2[2], v3_2[3], v3_2[4]);
        Vector4 v4_2 = (v3_3[1], v3_3[2], v3_3[3], v3_3[4]);
        Vector4 v4_3 = (v3_4[1], v3_4[2], v3_4[3], v3_4[4]);
        Vector4 v4 = v4_0 + new Vector4(v4_0[0].Sign * v4_0.Length, 0, 0, 0);

        v4 = ~v4;
        v4_0 -= (2 * (v4 * v4_0)) * v4;
        v4_1 -= (2 * (v4 * v4_1)) * v4;
        v4_2 -= (2 * (v4 * v4_2)) * v4;
        v4_3 -= (2 * (v4 * v4_3)) * v4;

        Vector3 v5_0 = (v4_1[1], v4_1[2], v4_1[3]);
        Vector3 v5_1 = (v4_2[1], v4_2[2], v4_2[3]);
        Vector3 v5_2 = (v4_3[1], v4_3[2], v4_3[3]);
        Vector3 v5 = v5_0 + new Vector3(v5_0[0].Sign * v5_0.Length, 0, 0);

        v5 = ~v5;
        v5_0 -= (2 * (v5 * v5_0)) * v5;
        v5_1 -= (2 * (v5 * v5_1)) * v5;
        v5_2 -= (2 * (v5 * v5_2)) * v5;

        Vector2 v6_0 = (v5_1[1], v5_1[2]);
        Vector2 v6_1 = (v5_2[1], v5_2[2]);
        Vector2 v6 = v6_0 + new Vector2(v6_0[0].Sign * v6_0.Length, 0);

        v6 = ~v6;
        v6_0 -= (2 * (v6 * v6_0)) * v6;
        v6_1 -= (2 * (v6 * v6_1)) * v6;

        Matrix8 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0], v0_5[0], v0_6[0], v0_7[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0], v1_4[0], v1_5[0], v1_6[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0], v2_3[0], v2_4[0], v2_5[0],
            0, 0, 0, v3_0[0], v3_1[0], v3_2[0], v3_3[0], v3_4[0],
            0, 0, 0, 0, v4_0[0], v4_1[0], v4_2[0], v4_3[0],
            0, 0, 0, 0, 0, v5_0[0], v5_1[0], v5_2[0],
            0, 0, 0, 0, 0, 0, v6_0[0], v6_1[0],
            0, 0, 0, 0, 0, 0, 0, v6_1[1]
        );
        Matrix8 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];
        Q *= Identity[4.., 4.., v4.HouseholderMatrix];
        Q *= Identity[5.., 5.., v5.HouseholderMatrix];
        Q *= Identity[6.., 6.., v6.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix8 Q, Matrix8 R) QRDecomposeUnstable()
    {
        Matrix8 H0;
        Matrix8 A0 = this;
        Vector8 v0 = A0[0];

        v0 += new Vector8(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix7 H1;
        Matrix7 A1 = A0.Minors[0, 0];
        Vector7 v1 = A1[0];

        v1 += new Vector7(A1[0, 0].Sign * v1.Length, 0, 0, 0, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix6 H2;
        Matrix6 A2 = A1.Minors[0, 0];
        Vector6 v2 = A2[0];

        v2 += new Vector6(A2[0, 0].Sign * v2.Length, 0, 0, 0, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix5 H3;
        Matrix5 A3 = A2.Minors[0, 0];
        Vector5 v3 = A3[0];

        v3 += new Vector5(A3[0, 0].Sign * v3.Length, 0, 0, 0, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Matrix4 H4;
        Matrix4 A4 = A3.Minors[0, 0];
        Vector4 v4 = A4[0];

        v4 += new Vector4(A4[0, 0].Sign * v4.Length, 0, 0, 0);
        H4 = v4.HouseholderMatrix;
        A4 = H4 * A4;

        Matrix3 H5;
        Matrix3 A5 = A4.Minors[0, 0];
        Vector3 v5 = A5[0];

        v5 += new Vector3(A5[0, 0].Sign * v5.Length, 0, 0);
        H5 = v5.HouseholderMatrix;
        A5 = H5 * A5;

        Matrix2 H6;
        Matrix2 A6 = A5.Minors[0, 0];
        Vector2 v6 = A6[0];

        v6 += new Vector2(A6[0, 0].Sign * v6.Length, 0);
        H6 = v6.HouseholderMatrix;
        A6 = H6 * A6;

        Scalar A7 = -A6[1, 1]; // TODO : ????????
        Matrix8[] H = new Matrix8[8];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4.., 4.., H4];
        H[5] = H[5][5.., 5.., H5];
        H[6] = H[6][6.., 6.., H6];
        H[7] = H[7][7, 7, -1];

        return (
            Q: H[7] * H[6] * H[5] * H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed * H[5].Transposed * H[6].Transposed * H[7].Transposed
        );
    }

    public readonly (Matrix8 U, Matrix8 D) IwasawaDecompose()
    {
        Matrix8 ONB = OrthonormalBasis;
        Matrix8 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace8 GetKrylovSpace(Vector8 vector) => VectorSpace8.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix8 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance) && _c5.Is(o._c5, tolerance) && _c6.Is(o._c6, tolerance) && _c7.Is(o._c7, tolerance);

    public readonly bool Is(Matrix8 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix8 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix8 v && Equals(v);

    public readonly bool Equals(Matrix8 other) => Is(other);

    public readonly int CompareTo(Matrix8 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix8 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix8)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 8x8-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 8x8-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>5x5 sub-matrix</returns>
    public readonly Matrix5 ToMatrix5() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]
    );

    /// <summary>
    /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>6x6 sub-matrix</returns>
    public readonly Matrix6 ToMatrix6() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5]
    );

    /// <summary>
    /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>7x7 sub-matrix</returns>
    public readonly Matrix7 ToMatrix7() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6]
    );

    /// <summary>
    /// Creates the homogeneous 9x9 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 9x9 transformation matrix.</returns>
    public readonly Matrix9 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        _c4.ToHomogeneousCoordinates(),
        _c5.ToHomogeneousCoordinates(),
        _c6.ToHomogeneousCoordinates(),
        _c7.ToHomogeneousCoordinates(),
        Vector9.UnitVectors[8]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector8> ToIsomorphism()
    {
        Matrix8 copy = this;

        return new Function<Vector8>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector8> GetEnumerator() => ((IEnumerable<Vector8>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_5_0, out Scalar x_6_0, out Scalar x_7_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_5_1, out Scalar x_6_1, out Scalar x_7_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_5_2, out Scalar x_6_2, out Scalar x_7_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_5_3, out Scalar x_6_3, out Scalar x_7_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4, out Scalar x_5_4, out Scalar x_6_4, out Scalar x_7_4, out Scalar x_0_5, out Scalar x_1_5, out Scalar x_2_5, out Scalar x_3_5, out Scalar x_4_5, out Scalar x_5_5, out Scalar x_6_5, out Scalar x_7_5, out Scalar x_0_6, out Scalar x_1_6, out Scalar x_2_6, out Scalar x_3_6, out Scalar x_4_6, out Scalar x_5_6, out Scalar x_6_6, out Scalar x_7_6, out Scalar x_0_7, out Scalar x_1_7, out Scalar x_2_7, out Scalar x_3_7, out Scalar x_4_7, out Scalar x_5_7, out Scalar x_6_7, out Scalar x_7_7) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, x_6_0, x_7_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_5_1, x_6_1, x_7_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_5_2, x_6_2, x_7_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_5_3, x_6_3, x_7_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4, x_5_4, x_6_4, x_7_4, x_0_5, x_1_5, x_2_5, x_3_5, x_4_5, x_5_5, x_6_5, x_7_5, x_0_6, x_1_6, x_2_6, x_3_6, x_4_6, x_5_6, x_6_6, x_7_6, x_0_7, x_1_7, x_2_7, x_3_7, x_4_7, x_5_7, x_6_7, x_7_7) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7]);

    public readonly void Deconstruct(out Vector8 v0, out Vector8 v1, out Vector8 v2, out Vector8 v3, out Vector8 v4, out Vector8 v5, out Vector8 v6, out Vector8 v7) =>
        (v0, v1, v2, v3, v4, v5, v6, v7) = (_c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7);

    public readonly object Clone() => new Matrix8(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector8 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        5 => _c5,
        6 => _c6,
        7 => _c7,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 7.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix8 SetColumn(int column, in Vector8 vector)
    {
        if (column < 0 || column >= 8)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 7.");

        Vector8[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..8);

    public readonly Matrix8 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..8, values);

    public readonly Matrix8 SwapColumns(int src_col, int dst_col)
    {
        Vector8 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix8 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix8 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix8 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector8 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix8 SetRow(int row, in Vector8 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..8, rows);

    public readonly Matrix8 SetRows(Range rows, in MatrixNM values) => SetRegion(0..8, rows, values);

    public readonly Matrix8 SwapRows(int src_row, int dst_row)
    {
        Vector8 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix8 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix8 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix8 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(8);
        int[] idx_r = rows.GetOffsets(8);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix8 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(8);
        int[] idx_r = rows.GetOffsets(8);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix8(t);
    }

    /// <summary>
    /// Returns the matrix' 7x7-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>7x7-minor</returns>
    public readonly Matrix7 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector7(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix8 Add(Matrix8 m1, Matrix8 m2) => m1.Add(m2);

    public static Matrix8 Subtract(Matrix8 m1, Matrix8 m2) => m1.Subtract(m2);

    public static Matrix8 Multiply(Matrix8 m1, Matrix8 m2) => m1.Multiply(m2);

    public static Vector8 Multiply(Matrix8 m, Vector8 v) => m.Multiply(v);

    public static Matrix8 Multiply(Matrix8 m, Scalar s) => m.Multiply(s);

    public static Matrix8 Divide(Matrix8 m, Scalar s) => m.Divide(s);

    public static Matrix8 Exp(Matrix8 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix8 Sin(Matrix8 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix8 Cos(Matrix8 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix8 CracovianProduct(in Matrix8 first, in Matrix8 second) => second.Transposed.Multiply(in second);

    public static Matrix8 HadamardProduct(in Matrix8 first, in Matrix8 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix8 first, Matrix8 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix8 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[8, 8];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix8 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix8 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[8, 8];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix8 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix8 DiagonalMatrix(in Vector8 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4], diagonal[5], diagonal[6], diagonal[7]);

    public static Matrix8 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4, Scalar d5, Scalar d6, Scalar d7) => (
        d0, 0, 0, 0, 0, 0, 0, 0,
        0, d1, 0, 0, 0, 0, 0, 0,
        0, 0, d2, 0, 0, 0, 0, 0,
        0, 0, 0, d3, 0, 0, 0, 0,
        0, 0, 0, 0, d4, 0, 0, 0,
        0, 0, 0, 0, 0, d5, 0, 0,
        0, 0, 0, 0, 0, 0, d6, 0,
        0, 0, 0, 0, 0, 0, 0, d7
    );
    
    public static Matrix8 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix8 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix8 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 8))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 7.", nameof(column_indices));

        Vector8[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix8 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix8 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix8 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix8 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix8 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 8 || arr.GetLength(1) < 8 ? throw new ArgumentException("The array must have a minimum size of 8x8.", nameof(arr)) : new Matrix8(arr);

    public static Matrix8 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 64 => throw new ArgumentException("The array must have a minimum length of 64.", nameof(arr)),
        _ => new Matrix8(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4], arr[ 5], arr[ 6], arr[ 7],
            arr[ 8], arr[ 9], arr[10], arr[11], arr[12], arr[13], arr[14], arr[15],
            arr[16], arr[17], arr[18], arr[19], arr[20], arr[21], arr[22], arr[23],
            arr[24], arr[25], arr[26], arr[27], arr[28], arr[29], arr[30], arr[31],
            arr[32], arr[33], arr[34], arr[35], arr[36], arr[37], arr[38], arr[39],
            arr[40], arr[41], arr[42], arr[43], arr[44], arr[45], arr[46], arr[47],
            arr[48], arr[49], arr[50], arr[51], arr[52], arr[53], arr[54], arr[55],
            arr[56], arr[57], arr[58], arr[59], arr[60], arr[61], arr[62], arr[63]
        )
    };

    public static Matrix8 FromRows(in Vector8[] arr) => FromColumns(arr).Transposed;

    public static Matrix8 FromColumns(in Vector8[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 8 } => new Matrix8(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0], arr[5][0], arr[6][0], arr[7][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1], arr[5][1], arr[6][1], arr[7][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2], arr[5][2], arr[6][2], arr[7][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3], arr[5][3], arr[6][3], arr[7][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4], arr[5][4], arr[6][4], arr[7][4],
            arr[0][5], arr[1][5], arr[2][5], arr[3][5], arr[4][5], arr[5][5], arr[6][5], arr[7][5],
            arr[0][6], arr[1][6], arr[2][6], arr[3][6], arr[4][6], arr[5][6], arr[6][6], arr[7][6],
            arr[0][7], arr[1][7], arr[2][7], arr[3][7], arr[4][7], arr[5][7], arr[6][7], arr[7][7]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 8.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix8 m1, Matrix8 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix8 m1, Matrix8 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix8 operator +(in Matrix8 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix8 operator -(in Matrix8 m) => m.Negate();

    public static Matrix8 operator +(Scalar f, in Matrix8 m) => m.Add(f);

    public static Matrix8 operator +(in Matrix8 m, Scalar f) => m.Add(f);

    public static Matrix8 operator -(Scalar f, in Matrix8 m) => new Matrix8(f).Subtract(in m);

    public static Matrix8 operator -(in Matrix8 m, Scalar f) => m.Subtract(f);

    public static Matrix8 operator ++(in Matrix8 m) => m.Increment();

    public static Matrix8 operator --(in Matrix8 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix8 operator +(in Matrix8 m1, in Matrix8 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix8 operator -(in Matrix8 m1, in Matrix8 m2) => m1.Subtract(in m2);

    public static Vector8 operator *(in Matrix8 m, in Vector8 v) => m.Multiply(in v);

    public static Matrix8 operator *(in Matrix8 m1, in Matrix8 m2) => m1.Multiply(in m2);

    public static Matrix8 operator *(in Matrix8 m, Scalar f) => m.Multiply(f);

    public static Matrix8 operator *(Scalar f, in Matrix8 m) => m.Multiply(f);

    public static Matrix8 operator ^(in Matrix8 m, int c) => m.Power(c);

    public static Matrix8 operator ^(in Matrix8 m1, in Matrix8 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace8 operator |(Matrix8 A, Vector8 b) => A.Solve(b);

    public static VectorSpace8 operator |(Matrix8 A, VectorSpace8 b) => A.Solve(b);

    public static Matrix8 operator /(Matrix8 m1, Matrix8 m2) => m1.Multiply(m2.Inverse);

    public static Matrix8 operator /(in Matrix8 m, Scalar f) => m.Divide(f);

    public static Matrix8 operator %(in Matrix8 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector8 x0, Vector8 x1, Vector8 x2, Vector8 x3, Vector8 x4, Vector8 x5, Vector8 x6, Vector8 x7) (in Matrix8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

    public static implicit operator Matrix8((Vector8 x0, Vector8 x1, Vector8 x2, Vector8 x3, Vector8 x4, Vector8 x5, Vector8 x6, Vector8 x7) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c7) (in Matrix8 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7]);

    public static explicit operator Matrix8(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7) c7) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7) (in Matrix8 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0], m._c5[0], m._c6[0], m._c7[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1], m._c5[1], m._c6[1], m._c7[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2], m._c5[2], m._c6[2], m._c7[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3], m._c5[3], m._c6[3], m._c7[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4], m._c5[4], m._c6[4], m._c7[4],
        m._c0[5], m._c1[5], m._c2[5], m._c3[5], m._c4[5], m._c5[5], m._c6[5], m._c7[5],
        m._c0[6], m._c1[6], m._c2[6], m._c3[6], m._c4[6], m._c5[6], m._c6[6], m._c7[6],
        m._c0[7], m._c1[7], m._c2[7], m._c3[7], m._c4[7], m._c5[7], m._c6[7], m._c7[7]
    );

    public static implicit operator Matrix8(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0, t.x_5_0, t.x_6_0, t.x_7_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1, t.x_5_1, t.x_6_1, t.x_7_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2, t.x_5_2, t.x_6_2, t.x_7_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3, t.x_5_3, t.x_6_3, t.x_7_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4, t.x_5_4, t.x_6_4, t.x_7_4,
        t.x_0_5, t.x_1_5, t.x_2_5, t.x_3_5, t.x_4_5, t.x_5_5, t.x_6_5, t.x_7_5,
        t.x_0_6, t.x_1_6, t.x_2_6, t.x_3_6, t.x_4_6, t.x_5_6, t.x_6_6, t.x_7_6,
        t.x_0_7, t.x_1_7, t.x_2_7, t.x_3_7, t.x_4_7, t.x_5_7, t.x_6_7, t.x_7_7
    );

    public static explicit operator Matrix8(Scalar m) => new(m);

    public static implicit operator Matrix8(in Vector8[] arr) => new(arr);

    public static implicit operator Vector8[](in Matrix8 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix8 m) => m.ToArray();

    public static implicit operator Matrix8(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix8 m) => m.Coefficients;

    public static implicit operator Matrix8(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix8 m) => new(m.Coefficients);

    public static explicit operator Matrix8(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix8 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix8>(m);

    public static implicit operator Function<Vector8>(in Matrix8 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix8EqualityComparer
        : IEqualityComparer<Matrix8>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix8 x, Matrix8 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix8 obj) => obj.GetHashCode();
    }
}

public static class Matrix8Extensions
{
    public static Matrix8 Sum(this IEnumerable<Matrix8> matrices) => Matrix8.Zero.Add(matrices.ToArray());

    public static Matrix8 Average(this IEnumerable<Matrix8> matrices)
    {
        Matrix8 mat = Matrix8.Zero;
        long count = 0;

        foreach (Matrix8 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix9

/// <summary>
/// Represents a square 9x9 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix9
    : Algebra<Scalar>.IMatrix<Vector9, Matrix9>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix9, MatrixNM>
    , INative<Matrix9>
    , IEnumerable<Vector9>
    // , Function<Matrix9, Vector9>
    , IEnumerable<Scalar>
    , IComparable<Matrix9>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix9>
    , IModulusOperators<Matrix9, Scalar, Matrix9>
    , IMultiplyOperators<Matrix9, Matrix9, Matrix9>
    , IMultiplyOperators<Scalar, Matrix9, Matrix9>
    , IMultiplyOperators<Matrix9, Scalar, Matrix9>
    , IDivisionOperators<Matrix9, Scalar, Matrix9>
    , IMultiplyOperators<Vector9, Matrix9, Vector9>
    , IMultiplyOperators<Matrix9, Vector9, Vector9>
    , IDecrementOperators<Matrix9>
    , IAdditionOperators<Matrix9, Matrix9, Matrix9>
    , ISubtractionOperators<Matrix9, Matrix9, Matrix9>
    , IUnaryPlusOperators<Matrix9, Matrix9>
    , IUnaryNegationOperators<Matrix9, Matrix9>
    , IAdditiveIdentity<Matrix9, Matrix9>
    , IMultiplicativeIdentity<Matrix9, Matrix9>
    , IComparisonOperators<Matrix9, Matrix9>
    , IEqualityOperators<Matrix9, Matrix9>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector9 _c0;
    private readonly Vector9 _c1;
    private readonly Vector9 _c2;
    private readonly Vector9 _c3;
    private readonly Vector9 _c4;
    private readonly Vector9 _c5;
    private readonly Vector9 _c6;
    private readonly Vector9 _c7;
    private readonly Vector9 _c8;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (9, 9);

    /// <summary>
    /// The 9x9 zero matrix
    /// </summary>
    public static Matrix9 Zero { get; } = new Matrix9(0);

    /// <summary>
    /// The 9x9 identity (unit) matrix
    /// </summary>
    public static Matrix9 Identity { get; } = new(1);

    static Matrix9 IRing<Matrix9>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix9"/>.
    /// </summary>
    public static Matrix9EqualityComparer EqualityComparer { get; } = new Matrix9EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix9"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix9);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector9 this[int column] => GetColumn(column);

    public readonly Vector9 this[Index column] => this[column.GetOffset(9)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix9 this[int column, in Vector9 value] => SetColumn(column, value);

    public readonly Matrix9 this[Index column, in Vector9 value] => this[column.GetOffset(9), value];

    public readonly Matrix9 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix9 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 9 || column < 0 || column >= 9)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 8.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix9(scalars);
        }
    }

    public readonly Matrix9 this[Index column, Index row, Scalar value] => this[column.GetOffset(9), row.GetOffset(9), value];

    public readonly Matrix9 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix8> Minors => new ReadOnlyIndexer<int, int, Matrix8>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (9, 9);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[9, 9]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7], _c0[8] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7], _c1[8] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7], _c2[8] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7], _c3[8] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7], _c4[8] },
        { _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7], _c5[8] },
        { _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7], _c6[8] },
        { _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7], _c7[8] },
        { _c8[0], _c8[1], _c8[2], _c8[3], _c8[4], _c8[5], _c8[6], _c8[7], _c8[8] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[81] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c8[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c8[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c8[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c8[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c8[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c8[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c8[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7], _c8[7], _c0[8], _c1[8], _c2[8], _c3[8], _c4[8], _c5[8], _c6[8], _c7[8], _c8[8] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector9 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4], _c5[5], _c6[6], _c7[7], _c8[8]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector9[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector9[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix9 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 7 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7, Matrix8 Sub8) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4(), ToMatrix5(), ToMatrix6(), ToMatrix7(), ToMatrix8());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix9 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7], _c0[8],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7], _c1[8],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7], _c2[8],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7], _c3[8],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7], _c4[8],
        _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7], _c5[8],
        _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7], _c6[8],
        _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7], _c7[8],
        _c8[0], _c8[1], _c8[2], _c8[3], _c8[4], _c8[5], _c8[6], _c8[7], _c8[8]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix9::Inverse' instead.")]
    public readonly Matrix9 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix9 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix9 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector9[] vs = Columns;

            for (int i = 0; i < 9; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant
        - GetMinor(0, 5).Determinant
        + GetMinor(0, 6).Determinant
        - GetMinor(0, 7).Determinant
        + GetMinor(0, 8).Determinant;

    public readonly Matrix9 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix9 m = this;
            // TODO : verify the following code
            Matrix9 u = Identity;

            for (int i = 0; i < 9; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 9; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 9; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 9 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector9[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector9.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 9x9 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary && _c5.IsBinary && _c6.IsBinary && _c7.IsBinary && _c8.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector9[] rows = Rows;

            for (int i = 0; i < 9; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 9; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 9; ++c)
                for (int r = 0; r < 9; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 9; ++c)
                for (int r = c + 1; r < 9; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix9 ctc = Transposed * this;

            return (ctc - new Matrix9(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 9x9-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix9(Scalar scale)
        : this(scale, 0, 0, 0, 0, 0, 0, 0, 0,
               0, scale, 0, 0, 0, 0, 0, 0, 0,
               0, 0, scale, 0, 0, 0, 0, 0, 0,
               0, 0, 0, scale, 0, 0, 0, 0, 0,
               0, 0, 0, 0, scale, 0, 0, 0, 0,
               0, 0, 0, 0, 0, scale, 0, 0, 0,
               0, 0, 0, 0, 0, 0, scale, 0, 0,
               0, 0, 0, 0, 0, 0, 0, scale, 0,
               0, 0, 0, 0, 0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 9x9-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    /// <param name="diag_5">The diagonal element at the position (5, 5).</param>
    /// <param name="diag_6">The diagonal element at the position (6, 6).</param>
    /// <param name="diag_7">The diagonal element at the position (7, 7).</param>
    /// <param name="diag_8">The diagonal element at the position (8, 8).</param>
    public Matrix9(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4, Scalar diag_5, Scalar diag_6, Scalar diag_7, Scalar diag_8)
        : this(diag_0, 0, 0, 0, 0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0, 0, 0, 0, 0,
               0, 0, diag_2, 0, 0, 0, 0, 0, 0,
               0, 0, 0, diag_3, 0, 0, 0, 0, 0,
               0, 0, 0, 0, diag_4, 0, 0, 0, 0,
               0, 0, 0, 0, 0, diag_5, 0, 0, 0,
               0, 0, 0, 0, 0, 0, diag_6, 0, 0,
               0, 0, 0, 0, 0, 0, 0, diag_7, 0,
               0, 0, 0, 0, 0, 0, 0, 0, diag_8)
    {
    }

    public Matrix9(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_5_0, Scalar s_6_0, Scalar s_7_0, Scalar s_8_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_5_1, Scalar s_6_1, Scalar s_7_1, Scalar s_8_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_5_2, Scalar s_6_2, Scalar s_7_2, Scalar s_8_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_5_3, Scalar s_6_3, Scalar s_7_3, Scalar s_8_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4, Scalar s_5_4, Scalar s_6_4, Scalar s_7_4, Scalar s_8_4, Scalar s_0_5, Scalar s_1_5, Scalar s_2_5, Scalar s_3_5, Scalar s_4_5, Scalar s_5_5, Scalar s_6_5, Scalar s_7_5, Scalar s_8_5, Scalar s_0_6, Scalar s_1_6, Scalar s_2_6, Scalar s_3_6, Scalar s_4_6, Scalar s_5_6, Scalar s_6_6, Scalar s_7_6, Scalar s_8_6, Scalar s_0_7, Scalar s_1_7, Scalar s_2_7, Scalar s_3_7, Scalar s_4_7, Scalar s_5_7, Scalar s_6_7, Scalar s_7_7, Scalar s_8_7, Scalar s_0_8, Scalar s_1_8, Scalar s_2_8, Scalar s_3_8, Scalar s_4_8, Scalar s_5_8, Scalar s_6_8, Scalar s_7_8, Scalar s_8_8)
        : this(new Vector9(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4, s_0_5, s_0_6, s_0_7, s_0_8),
               new Vector9(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4, s_1_5, s_1_6, s_1_7, s_1_8),
               new Vector9(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4, s_2_5, s_2_6, s_2_7, s_2_8),
               new Vector9(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4, s_3_5, s_3_6, s_3_7, s_3_8),
               new Vector9(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4, s_4_5, s_4_6, s_4_7, s_4_8),
               new Vector9(s_5_0, s_5_1, s_5_2, s_5_3, s_5_4, s_5_5, s_5_6, s_5_7, s_5_8),
               new Vector9(s_6_0, s_6_1, s_6_2, s_6_3, s_6_4, s_6_5, s_6_6, s_6_7, s_6_8),
               new Vector9(s_7_0, s_7_1, s_7_2, s_7_3, s_7_4, s_7_5, s_7_6, s_7_7, s_7_8),
               new Vector9(s_8_0, s_8_1, s_8_2, s_8_3, s_8_4, s_8_5, s_8_6, s_8_7, s_8_8))
    {
    }

    public Matrix9(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8],
               values[9], values[10], values[11], values[12], values[13], values[14], values[15], values[16], values[17],
               values[18], values[19], values[20], values[21], values[22], values[23], values[24], values[25], values[26],
               values[27], values[28], values[29], values[30], values[31], values[32], values[33], values[34], values[35],
               values[36], values[37], values[38], values[39], values[40], values[41], values[42], values[43], values[44],
               values[45], values[46], values[47], values[48], values[49], values[50], values[51], values[52], values[53],
               values[54], values[55], values[56], values[57], values[58], values[59], values[60], values[61], values[62],
               values[63], values[64], values[65], values[66], values[67], values[68], values[69], values[70], values[71],
               values[72], values[73], values[74], values[75], values[76], values[77], values[78], values[79], values[80])
    {
    }

    public Matrix9(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0], values[5, 0], values[6, 0], values[7, 0], values[8, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1], values[5, 1], values[6, 1], values[7, 1], values[8, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2], values[5, 2], values[6, 2], values[7, 2], values[8, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3], values[5, 3], values[6, 3], values[7, 3], values[8, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4], values[5, 4], values[6, 4], values[7, 4], values[8, 4],
               values[0, 5], values[1, 5], values[2, 5], values[3, 5], values[4, 5], values[5, 5], values[6, 5], values[7, 5], values[8, 5],
               values[0, 6], values[1, 6], values[2, 6], values[3, 6], values[4, 6], values[5, 6], values[6, 6], values[7, 6], values[8, 6],
               values[0, 7], values[1, 7], values[2, 7], values[3, 7], values[4, 7], values[5, 7], values[6, 7], values[7, 7], values[8, 7],
               values[0, 8], values[1, 8], values[2, 8], values[3, 8], values[4, 8], values[5, 8], values[6, 8], values[7, 8], values[8, 8])
    {
    }

    public Matrix9(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0], values[5][0], values[6][0], values[7][0], values[8][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1], values[5][1], values[6][1], values[7][1], values[8][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2], values[5][2], values[6][2], values[7][2], values[8][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3], values[5][3], values[6][3], values[7][3], values[8][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4], values[5][4], values[6][4], values[7][4], values[8][4],
               values[0][5], values[1][5], values[2][5], values[3][5], values[4][5], values[5][5], values[6][5], values[7][5], values[8][5],
               values[0][6], values[1][6], values[2][6], values[3][6], values[4][6], values[5][6], values[6][6], values[7][6], values[8][6],
               values[0][7], values[1][7], values[2][7], values[3][7], values[4][7], values[5][7], values[6][7], values[7][7], values[8][7],
               values[0][8], values[1][8], values[2][8], values[3][8], values[4][8], values[5][8], values[6][8], values[7][8], values[8][8])
    {
    }

    public Matrix9(in Matrix2 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix3 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix4 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix5 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), new Vector9(matrix[4]), Vector9.Zero, Vector9.Zero, Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix6 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), new Vector9(matrix[4]), new Vector9(matrix[5]), Vector9.Zero, Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix7 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), new Vector9(matrix[4]), new Vector9(matrix[5]), new Vector9(matrix[6]), Vector9.Zero, Vector9.Zero)
    {
    }

    public Matrix9(in Matrix8 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), new Vector9(matrix[4]), new Vector9(matrix[5]), new Vector9(matrix[6]), new Vector9(matrix[7]), Vector9.Zero)
    {
    }

    public Matrix9(in Matrix9 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix9(in Matrix10 matrix)
        : this(new Vector9(matrix[0]), new Vector9(matrix[1]), new Vector9(matrix[2]), new Vector9(matrix[3]), new Vector9(matrix[4]), new Vector9(matrix[5]), new Vector9(matrix[6]), new Vector9(matrix[7]), new Vector9(matrix[8]))
    {
    }

    public Matrix9(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix9(Matrix9* matrix)
        : this(*matrix)
    {
    }

    public Matrix9(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8],
               values[9], values[10], values[11], values[12], values[13], values[14], values[15], values[16], values[17],
               values[18], values[19], values[20], values[21], values[22], values[23], values[24], values[25], values[26],
               values[27], values[28], values[29], values[30], values[31], values[32], values[33], values[34], values[35],
               values[36], values[37], values[38], values[39], values[40], values[41], values[42], values[43], values[44],
               values[45], values[46], values[47], values[48], values[49], values[50], values[51], values[52], values[53],
               values[54], values[55], values[56], values[57], values[58], values[59], values[60], values[61], values[62],
               values[63], values[64], values[65], values[66], values[67], values[68], values[69], values[70], values[71],
               values[72], values[73], values[74], values[75], values[76], values[77], values[78], values[79], values[80])
    {
    }

    public Matrix9(Vector9* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7], columns[8])
    {
    }

    public Matrix9(IEnumerable<Vector9> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix9(Vector9[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7], columns[8])
    {
    }

    public Matrix9(Vector9 v0, Vector9 v1, Vector9 v2, Vector9 v3, Vector9 v4, Vector9 v5, Vector9 v6, Vector9 v7, Vector9 v8)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
        _c5 = v5;
        _c6 = v6;
        _c7 = v7;
        _c8 = v8;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix9 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4, -_c5, -_c6, -_c7, -_c8);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix9 Add(in Matrix9 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4, _c5 + second._c5, _c6 + second._c6, _c7 + second._c7, _c8 + second._c8);

    public readonly Matrix9 Add(params Matrix9[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix9 Add(Scalar Scalar) => Add(new Matrix9(Scalar));

    public readonly Matrix9 Increment() => Add(1);

    public readonly Matrix9 Decrement() => Add(-1);

    public readonly Matrix9 Subtract(in Matrix9 second) => Add(second.Negate());

    public readonly Matrix9 Subtract(params Matrix9[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix9 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector8 HomogeneousMultiply(in Vector8 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix9 Multiply(in Matrix9 second)
    {
        Vector9[] A = Rows;
        Vector9[] B = second.Columns;
        Scalar[,] C = new Scalar[9, 9];

        for (int r = 0; r < 9; ++r)
            for (int c = 0; c < 9; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix9(C);
    }

    public readonly Matrix9 Multiply(params Matrix9[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector9 Multiply(in Vector9 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4] + _c5[0] * vector[5] + _c6[0] * vector[6] + _c7[0] * vector[7] + _c8[0] * vector[8],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4] + _c5[1] * vector[5] + _c6[1] * vector[6] + _c7[1] * vector[7] + _c8[1] * vector[8],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4] + _c5[2] * vector[5] + _c6[2] * vector[6] + _c7[2] * vector[7] + _c8[2] * vector[8],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4] + _c5[3] * vector[5] + _c6[3] * vector[6] + _c7[3] * vector[7] + _c8[3] * vector[8],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4] + _c5[4] * vector[5] + _c6[4] * vector[6] + _c7[4] * vector[7] + _c8[4] * vector[8],
        _c0[5] * vector[0] + _c1[5] * vector[1] + _c2[5] * vector[2] + _c3[5] * vector[3] + _c4[5] * vector[4] + _c5[5] * vector[5] + _c6[5] * vector[6] + _c7[5] * vector[7] + _c8[5] * vector[8],
        _c0[6] * vector[0] + _c1[6] * vector[1] + _c2[6] * vector[2] + _c3[6] * vector[3] + _c4[6] * vector[4] + _c5[6] * vector[5] + _c6[6] * vector[6] + _c7[6] * vector[7] + _c8[6] * vector[8],
        _c0[7] * vector[0] + _c1[7] * vector[1] + _c2[7] * vector[2] + _c3[7] * vector[3] + _c4[7] * vector[4] + _c5[7] * vector[5] + _c6[7] * vector[6] + _c7[7] * vector[7] + _c8[7] * vector[8],
        _c0[8] * vector[0] + _c1[8] * vector[1] + _c2[8] * vector[2] + _c3[8] * vector[3] + _c4[8] * vector[4] + _c5[8] * vector[5] + _c6[8] * vector[6] + _c7[8] * vector[7] + _c8[8] * vector[8]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix9 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor, _c5 * factor, _c6 * factor, _c7 * factor, _c8 * factor);

    public readonly Matrix9 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix9 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix9 r = Identity;
        Matrix9 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix9 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix9 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor, _c5 % factor, _c6 % factor, _c7 % factor, _c8 % factor);

    public readonly Matrix9 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix9 result = this;
        Matrix9 exponent = this;
        Matrix9 squared = Multiply(this);
        Matrix9 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix9 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix9 result = Identity;
        Matrix9 exponent = this;
        Matrix9 squared = Multiply(this);
        Matrix9 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix9 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix9 result = Identity;
        Matrix9 exponent = this;
        Matrix9 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix9 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix9 ComponentwiseDivide(in Matrix9 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4), _c5.ComponentwiseDivide(second._c5), _c6.ComponentwiseDivide(second._c6), _c7.ComponentwiseDivide(second._c7), _c8.ComponentwiseDivide(second._c8));

    public readonly Matrix9 ComponentwiseMultiply(in Matrix9 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4), _c5.ComponentwiseMultiply(second._c5), _c6.ComponentwiseMultiply(second._c6), _c7.ComponentwiseMultiply(second._c7), _c8.ComponentwiseMultiply(second._c8));

    public readonly Matrix9 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function), _c5.ComponentwiseApply(function), _c6.ComponentwiseApply(function), _c7.ComponentwiseApply(function), _c8.ComponentwiseApply(function));

    public readonly Matrix9 ComponentwiseApply(Matrix9 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function), _c5.ComponentwiseApply(second._c5, function), _c6.ComponentwiseApply(second._c6, function), _c7.ComponentwiseApply(second._c7, function), _c8.ComponentwiseApply(second._c8, function));

    public readonly Matrix9 ComponentwiseApply(Matrix9 second, Matrix9 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function), _c5.ComponentwiseApply(second._c5, third._c5, function), _c6.ComponentwiseApply(second._c6, third._c6, function), _c7.ComponentwiseApply(second._c7, third._c7, function), _c8.ComponentwiseApply(second._c8, third._c8, function));

    public readonly Matrix9 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix9 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high), _c5.Clamp(low, high), _c6.Clamp(low, high), _c7.Clamp(low, high), _c8.Clamp(low, high));

    public readonly Matrix9 LinearInterpolate(in Matrix9 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix9 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 9; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 7 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7, Matrix8 Sub8) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4, Sub5, Sub6, Sub7, Sub8 };
    }

    internal readonly Matrix9 GetLinearIndependentForm()
    {
        Matrix9 m = this;

        for (int row = 0; row < 9; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 9; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 9; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector9</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace9 Solve(Vector9 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector9 x = vector;

            for (int i = 0; i < 9; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 9; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector9 x = vector;

            for (int i = 8; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix9 P, Matrix9 L, Matrix9 U) = PLUDecompose();
        VectorSpace9 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace9(SolveCG(vector));
    }

    public readonly VectorSpace9 Solve(VectorSpace9 vectorspace)
    {
        VectorSpace9 result = VectorSpace9.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace9 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector9, Matrix9>.Solve(Vector9 vector, out Vector9 solution)
    {
        VectorSpace9 space = Solve(vector);
        solution = Vector9.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector9 SolveCG(Vector9 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector9 x = vector;
        Vector9 r = vector - Multiply(vector);
        Vector9 d = r;

        for (int i = 0; i < 9; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector9 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector9 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix9 m = this;
        Vector9 v = vector;

        for (int row = 0; row < 9; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 9; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 9; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 8; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector9[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector9 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector9[] vectors = pairs.Select(p => p.vec).Distinct(Vector9.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector9 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector9 vec, Scalar val)[] pairs = new (Vector9, Scalar)[9];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 9; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector9 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector9 v_old = default;
        Vector9 v_new = Vector9.GetRandomCartesianUnitVector();
        Vector9 v_init = v_new;
        Matrix9 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector9 w = default;

        while ((w * v_init).IsZero)
            w = Vector9.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace9 GetEigenspace(Scalar eigenvalue) => VectorSpace9.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix9 P, Matrix9 S, Matrix9 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector9 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix9 P = new Matrix9(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v, pairs[5].v, pairs[6].v, pairs[7].v, pairs[8].v);
        Matrix9 S = new Matrix9(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ, pairs[5].λ, pairs[6].λ, pairs[7].λ, pairs[8].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix9 P, Matrix9 L, Matrix9 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4, 5, 6, 7, 8 };
        Matrix9 U = Identity;
        Matrix9 L = this;

        for (int i = 0; i < 8; ++i)
        {
            Vector9 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 9; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 9; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix4 A, Matrix5 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(4);

        return ((Matrix4)A, (Matrix5)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 9)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 9.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix9 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix9 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix9 Q, Matrix9 R) QRDecompose()
    {
        Matrix9 A = this;
        (Vector9 v0_0, Vector9 v0_1, Vector9 v0_2, Vector9 v0_3, Vector9 v0_4, Vector9 v0_5, Vector9 v0_6, Vector9 v0_7, Vector9 v0_8) = A;
        Vector9 v0 = v0_0 + new Vector9(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;
        v0_5 -= (2 * (v0 * v0_5)) * v0;
        v0_6 -= (2 * (v0 * v0_6)) * v0;
        v0_7 -= (2 * (v0 * v0_7)) * v0;
        v0_8 -= (2 * (v0 * v0_8)) * v0;

        Vector8 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4], v0_1[5], v0_1[6], v0_1[7], v0_1[8]);
        Vector8 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4], v0_2[5], v0_2[6], v0_2[7], v0_2[8]);
        Vector8 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4], v0_3[5], v0_3[6], v0_3[7], v0_3[8]);
        Vector8 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4], v0_4[5], v0_4[6], v0_4[7], v0_4[8]);
        Vector8 v1_4 = (v0_5[1], v0_5[2], v0_5[3], v0_5[4], v0_5[5], v0_5[6], v0_5[7], v0_5[8]);
        Vector8 v1_5 = (v0_6[1], v0_6[2], v0_6[3], v0_6[4], v0_6[5], v0_6[6], v0_6[7], v0_6[8]);
        Vector8 v1_6 = (v0_7[1], v0_7[2], v0_7[3], v0_7[4], v0_7[5], v0_7[6], v0_7[7], v0_7[8]);
        Vector8 v1_7 = (v0_8[1], v0_8[2], v0_8[3], v0_8[4], v0_8[5], v0_8[6], v0_8[7], v0_8[8]);
        Vector8 v1 = v1_0 + new Vector8(v1_0[0].Sign * v1_0.Length, 0, 0, 0, 0, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;
        v1_4 -= (2 * (v1 * v1_4)) * v1;
        v1_5 -= (2 * (v1 * v1_5)) * v1;
        v1_6 -= (2 * (v1 * v1_6)) * v1;
        v1_7 -= (2 * (v1 * v1_7)) * v1;

        Vector7 v2_0 = (v1_1[1], v1_1[2], v1_1[3], v1_1[4], v1_1[5], v1_1[6], v1_1[7]);
        Vector7 v2_1 = (v1_2[1], v1_2[2], v1_2[3], v1_2[4], v1_2[5], v1_2[6], v1_2[7]);
        Vector7 v2_2 = (v1_3[1], v1_3[2], v1_3[3], v1_3[4], v1_3[5], v1_3[6], v1_3[7]);
        Vector7 v2_3 = (v1_4[1], v1_4[2], v1_4[3], v1_4[4], v1_4[5], v1_4[6], v1_4[7]);
        Vector7 v2_4 = (v1_5[1], v1_5[2], v1_5[3], v1_5[4], v1_5[5], v1_5[6], v1_5[7]);
        Vector7 v2_5 = (v1_6[1], v1_6[2], v1_6[3], v1_6[4], v1_6[5], v1_6[6], v1_6[7]);
        Vector7 v2_6 = (v1_7[1], v1_7[2], v1_7[3], v1_7[4], v1_7[5], v1_7[6], v1_7[7]);
        Vector7 v2 = v2_0 + new Vector7(v2_0[0].Sign * v2_0.Length, 0, 0, 0, 0, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;
        v2_3 -= (2 * (v2 * v2_3)) * v2;
        v2_4 -= (2 * (v2 * v2_4)) * v2;
        v2_5 -= (2 * (v2 * v2_5)) * v2;
        v2_6 -= (2 * (v2 * v2_6)) * v2;

        Vector6 v3_0 = (v2_1[1], v2_1[2], v2_1[3], v2_1[4], v2_1[5], v2_1[6]);
        Vector6 v3_1 = (v2_2[1], v2_2[2], v2_2[3], v2_2[4], v2_2[5], v2_2[6]);
        Vector6 v3_2 = (v2_3[1], v2_3[2], v2_3[3], v2_3[4], v2_3[5], v2_3[6]);
        Vector6 v3_3 = (v2_4[1], v2_4[2], v2_4[3], v2_4[4], v2_4[5], v2_4[6]);
        Vector6 v3_4 = (v2_5[1], v2_5[2], v2_5[3], v2_5[4], v2_5[5], v2_5[6]);
        Vector6 v3_5 = (v2_6[1], v2_6[2], v2_6[3], v2_6[4], v2_6[5], v2_6[6]);
        Vector6 v3 = v3_0 + new Vector6(v3_0[0].Sign * v3_0.Length, 0, 0, 0, 0, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;
        v3_2 -= (2 * (v3 * v3_2)) * v3;
        v3_3 -= (2 * (v3 * v3_3)) * v3;
        v3_4 -= (2 * (v3 * v3_4)) * v3;
        v3_5 -= (2 * (v3 * v3_5)) * v3;

        Vector5 v4_0 = (v3_1[1], v3_1[2], v3_1[3], v3_1[4], v3_1[5]);
        Vector5 v4_1 = (v3_2[1], v3_2[2], v3_2[3], v3_2[4], v3_2[5]);
        Vector5 v4_2 = (v3_3[1], v3_3[2], v3_3[3], v3_3[4], v3_3[5]);
        Vector5 v4_3 = (v3_4[1], v3_4[2], v3_4[3], v3_4[4], v3_4[5]);
        Vector5 v4_4 = (v3_5[1], v3_5[2], v3_5[3], v3_5[4], v3_5[5]);
        Vector5 v4 = v4_0 + new Vector5(v4_0[0].Sign * v4_0.Length, 0, 0, 0, 0);

        v4 = ~v4;
        v4_0 -= (2 * (v4 * v4_0)) * v4;
        v4_1 -= (2 * (v4 * v4_1)) * v4;
        v4_2 -= (2 * (v4 * v4_2)) * v4;
        v4_3 -= (2 * (v4 * v4_3)) * v4;
        v4_4 -= (2 * (v4 * v4_4)) * v4;

        Vector4 v5_0 = (v4_1[1], v4_1[2], v4_1[3], v4_1[4]);
        Vector4 v5_1 = (v4_2[1], v4_2[2], v4_2[3], v4_2[4]);
        Vector4 v5_2 = (v4_3[1], v4_3[2], v4_3[3], v4_3[4]);
        Vector4 v5_3 = (v4_4[1], v4_4[2], v4_4[3], v4_4[4]);
        Vector4 v5 = v5_0 + new Vector4(v5_0[0].Sign * v5_0.Length, 0, 0, 0);

        v5 = ~v5;
        v5_0 -= (2 * (v5 * v5_0)) * v5;
        v5_1 -= (2 * (v5 * v5_1)) * v5;
        v5_2 -= (2 * (v5 * v5_2)) * v5;
        v5_3 -= (2 * (v5 * v5_3)) * v5;

        Vector3 v6_0 = (v5_1[1], v5_1[2], v5_1[3]);
        Vector3 v6_1 = (v5_2[1], v5_2[2], v5_2[3]);
        Vector3 v6_2 = (v5_3[1], v5_3[2], v5_3[3]);
        Vector3 v6 = v6_0 + new Vector3(v6_0[0].Sign * v6_0.Length, 0, 0);

        v6 = ~v6;
        v6_0 -= (2 * (v6 * v6_0)) * v6;
        v6_1 -= (2 * (v6 * v6_1)) * v6;
        v6_2 -= (2 * (v6 * v6_2)) * v6;

        Vector2 v7_0 = (v6_1[1], v6_1[2]);
        Vector2 v7_1 = (v6_2[1], v6_2[2]);
        Vector2 v7 = v7_0 + new Vector2(v7_0[0].Sign * v7_0.Length, 0);

        v7 = ~v7;
        v7_0 -= (2 * (v7 * v7_0)) * v7;
        v7_1 -= (2 * (v7 * v7_1)) * v7;

        Matrix9 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0], v0_5[0], v0_6[0], v0_7[0], v0_8[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0], v1_4[0], v1_5[0], v1_6[0], v1_7[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0], v2_3[0], v2_4[0], v2_5[0], v2_6[0],
            0, 0, 0, v3_0[0], v3_1[0], v3_2[0], v3_3[0], v3_4[0], v3_5[0],
            0, 0, 0, 0, v4_0[0], v4_1[0], v4_2[0], v4_3[0], v4_4[0],
            0, 0, 0, 0, 0, v5_0[0], v5_1[0], v5_2[0], v5_3[0],
            0, 0, 0, 0, 0, 0, v6_0[0], v6_1[0], v6_2[0],
            0, 0, 0, 0, 0, 0, 0, v7_0[0], v7_1[0],
            0, 0, 0, 0, 0, 0, 0, 0, v7_1[1]
        );
        Matrix9 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];
        Q *= Identity[4.., 4.., v4.HouseholderMatrix];
        Q *= Identity[5.., 5.., v5.HouseholderMatrix];
        Q *= Identity[6.., 6.., v6.HouseholderMatrix];
        Q *= Identity[7.., 7.., v7.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix9 Q, Matrix9 R) QRDecomposeUnstable()
    {
        Matrix9 H0;
        Matrix9 A0 = this;
        Vector9 v0 = A0[0];

        v0 += new Vector9(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix8 H1;
        Matrix8 A1 = A0.Minors[0, 0];
        Vector8 v1 = A1[0];

        v1 += new Vector8(A1[0, 0].Sign * v1.Length, 0, 0, 0, 0, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix7 H2;
        Matrix7 A2 = A1.Minors[0, 0];
        Vector7 v2 = A2[0];

        v2 += new Vector7(A2[0, 0].Sign * v2.Length, 0, 0, 0, 0, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix6 H3;
        Matrix6 A3 = A2.Minors[0, 0];
        Vector6 v3 = A3[0];

        v3 += new Vector6(A3[0, 0].Sign * v3.Length, 0, 0, 0, 0, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Matrix5 H4;
        Matrix5 A4 = A3.Minors[0, 0];
        Vector5 v4 = A4[0];

        v4 += new Vector5(A4[0, 0].Sign * v4.Length, 0, 0, 0, 0);
        H4 = v4.HouseholderMatrix;
        A4 = H4 * A4;

        Matrix4 H5;
        Matrix4 A5 = A4.Minors[0, 0];
        Vector4 v5 = A5[0];

        v5 += new Vector4(A5[0, 0].Sign * v5.Length, 0, 0, 0);
        H5 = v5.HouseholderMatrix;
        A5 = H5 * A5;

        Matrix3 H6;
        Matrix3 A6 = A5.Minors[0, 0];
        Vector3 v6 = A6[0];

        v6 += new Vector3(A6[0, 0].Sign * v6.Length, 0, 0);
        H6 = v6.HouseholderMatrix;
        A6 = H6 * A6;

        Matrix2 H7;
        Matrix2 A7 = A6.Minors[0, 0];
        Vector2 v7 = A7[0];

        v7 += new Vector2(A7[0, 0].Sign * v7.Length, 0);
        H7 = v7.HouseholderMatrix;
        A7 = H7 * A7;

        Scalar A8 = -A7[1, 1]; // TODO : ????????
        Matrix9[] H = new Matrix9[9];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4.., 4.., H4];
        H[5] = H[5][5.., 5.., H5];
        H[6] = H[6][6.., 6.., H6];
        H[7] = H[7][7.., 7.., H7];
        H[8] = H[8][8, 8, -1];

        return (
            Q: H[8] * H[7] * H[6] * H[5] * H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed * H[5].Transposed * H[6].Transposed * H[7].Transposed * H[8].Transposed
        );
    }

    public readonly (Matrix9 U, Matrix9 D) IwasawaDecompose()
    {
        Matrix9 ONB = OrthonormalBasis;
        Matrix9 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace9 GetKrylovSpace(Vector9 vector) => VectorSpace9.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix9 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance) && _c5.Is(o._c5, tolerance) && _c6.Is(o._c6, tolerance) && _c7.Is(o._c7, tolerance) && _c8.Is(o._c8, tolerance);

    public readonly bool Is(Matrix9 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix9 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix9 v && Equals(v);

    public readonly bool Equals(Matrix9 other) => Is(other);

    public readonly int CompareTo(Matrix9 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix9 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix9)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 9x9-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 9x9-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>5x5 sub-matrix</returns>
    public readonly Matrix5 ToMatrix5() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]
    );

    /// <summary>
    /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>6x6 sub-matrix</returns>
    public readonly Matrix6 ToMatrix6() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5]
    );

    /// <summary>
    /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>7x7 sub-matrix</returns>
    public readonly Matrix7 ToMatrix7() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6]
    );

    /// <summary>
    /// Returns the upper-left 8x8 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>8x8 sub-matrix</returns>
    public readonly Matrix8 ToMatrix8() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6],
        _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7]
    );

    /// <summary>
    /// Creates the homogeneous 10x10 transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous 10x10 transformation matrix.</returns>
    public readonly Matrix10 ToHomogeneousTransformationMatrix() => (
        _c0.ToHomogeneousCoordinates(),
        _c1.ToHomogeneousCoordinates(),
        _c2.ToHomogeneousCoordinates(),
        _c3.ToHomogeneousCoordinates(),
        _c4.ToHomogeneousCoordinates(),
        _c5.ToHomogeneousCoordinates(),
        _c6.ToHomogeneousCoordinates(),
        _c7.ToHomogeneousCoordinates(),
        _c8.ToHomogeneousCoordinates(),
        Vector10.UnitVectors[9]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector9> ToIsomorphism()
    {
        Matrix9 copy = this;

        return new Function<Vector9>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector9> GetEnumerator() => ((IEnumerable<Vector9>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_5_0, out Scalar x_6_0, out Scalar x_7_0, out Scalar x_8_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_5_1, out Scalar x_6_1, out Scalar x_7_1, out Scalar x_8_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_5_2, out Scalar x_6_2, out Scalar x_7_2, out Scalar x_8_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_5_3, out Scalar x_6_3, out Scalar x_7_3, out Scalar x_8_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4, out Scalar x_5_4, out Scalar x_6_4, out Scalar x_7_4, out Scalar x_8_4, out Scalar x_0_5, out Scalar x_1_5, out Scalar x_2_5, out Scalar x_3_5, out Scalar x_4_5, out Scalar x_5_5, out Scalar x_6_5, out Scalar x_7_5, out Scalar x_8_5, out Scalar x_0_6, out Scalar x_1_6, out Scalar x_2_6, out Scalar x_3_6, out Scalar x_4_6, out Scalar x_5_6, out Scalar x_6_6, out Scalar x_7_6, out Scalar x_8_6, out Scalar x_0_7, out Scalar x_1_7, out Scalar x_2_7, out Scalar x_3_7, out Scalar x_4_7, out Scalar x_5_7, out Scalar x_6_7, out Scalar x_7_7, out Scalar x_8_7, out Scalar x_0_8, out Scalar x_1_8, out Scalar x_2_8, out Scalar x_3_8, out Scalar x_4_8, out Scalar x_5_8, out Scalar x_6_8, out Scalar x_7_8, out Scalar x_8_8) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, x_6_0, x_7_0, x_8_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_5_1, x_6_1, x_7_1, x_8_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_5_2, x_6_2, x_7_2, x_8_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_5_3, x_6_3, x_7_3, x_8_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4, x_5_4, x_6_4, x_7_4, x_8_4, x_0_5, x_1_5, x_2_5, x_3_5, x_4_5, x_5_5, x_6_5, x_7_5, x_8_5, x_0_6, x_1_6, x_2_6, x_3_6, x_4_6, x_5_6, x_6_6, x_7_6, x_8_6, x_0_7, x_1_7, x_2_7, x_3_7, x_4_7, x_5_7, x_6_7, x_7_7, x_8_7, x_0_8, x_1_8, x_2_8, x_3_8, x_4_8, x_5_8, x_6_8, x_7_8, x_8_8) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c8[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c8[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c8[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c8[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c8[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c8[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c8[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7], _c8[7], _c0[8], _c1[8], _c2[8], _c3[8], _c4[8], _c5[8], _c6[8], _c7[8], _c8[8]);

    public readonly void Deconstruct(out Vector9 v0, out Vector9 v1, out Vector9 v2, out Vector9 v3, out Vector9 v4, out Vector9 v5, out Vector9 v6, out Vector9 v7, out Vector9 v8) =>
        (v0, v1, v2, v3, v4, v5, v6, v7, v8) = (_c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8);

    public readonly object Clone() => new Matrix9(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector9 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        5 => _c5,
        6 => _c6,
        7 => _c7,
        8 => _c8,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 8.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix9 SetColumn(int column, in Vector9 vector)
    {
        if (column < 0 || column >= 9)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 8.");

        Vector9[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..9);

    public readonly Matrix9 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..9, values);

    public readonly Matrix9 SwapColumns(int src_col, int dst_col)
    {
        Vector9 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix9 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix9 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix9 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector9 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix9 SetRow(int row, in Vector9 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..9, rows);

    public readonly Matrix9 SetRows(Range rows, in MatrixNM values) => SetRegion(0..9, rows, values);

    public readonly Matrix9 SwapRows(int src_row, int dst_row)
    {
        Vector9 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix9 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix9 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix9 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(9);
        int[] idx_r = rows.GetOffsets(9);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix9 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(9);
        int[] idx_r = rows.GetOffsets(9);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix9(t);
    }

    /// <summary>
    /// Returns the matrix' 8x8-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>8x8-minor</returns>
    public readonly Matrix8 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector8(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix9 Add(Matrix9 m1, Matrix9 m2) => m1.Add(m2);

    public static Matrix9 Subtract(Matrix9 m1, Matrix9 m2) => m1.Subtract(m2);

    public static Matrix9 Multiply(Matrix9 m1, Matrix9 m2) => m1.Multiply(m2);

    public static Vector9 Multiply(Matrix9 m, Vector9 v) => m.Multiply(v);

    public static Matrix9 Multiply(Matrix9 m, Scalar s) => m.Multiply(s);

    public static Matrix9 Divide(Matrix9 m, Scalar s) => m.Divide(s);

    public static Matrix9 Exp(Matrix9 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix9 Sin(Matrix9 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix9 Cos(Matrix9 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix9 CracovianProduct(in Matrix9 first, in Matrix9 second) => second.Transposed.Multiply(in second);

    public static Matrix9 HadamardProduct(in Matrix9 first, in Matrix9 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix9 first, Matrix9 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix9 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[9, 9];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix9 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix9 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[9, 9];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix9 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix9 DiagonalMatrix(in Vector9 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4], diagonal[5], diagonal[6], diagonal[7], diagonal[8]);

    public static Matrix9 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4, Scalar d5, Scalar d6, Scalar d7, Scalar d8) => (
        d0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, d1, 0, 0, 0, 0, 0, 0, 0,
        0, 0, d2, 0, 0, 0, 0, 0, 0,
        0, 0, 0, d3, 0, 0, 0, 0, 0,
        0, 0, 0, 0, d4, 0, 0, 0, 0,
        0, 0, 0, 0, 0, d5, 0, 0, 0,
        0, 0, 0, 0, 0, 0, d6, 0, 0,
        0, 0, 0, 0, 0, 0, 0, d7, 0,
        0, 0, 0, 0, 0, 0, 0, 0, d8
    );
    
    public static Matrix9 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5, a.Power(8) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(8) * .5, a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix9 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix9 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 9))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 8.", nameof(column_indices));

        Vector9[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix9 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix9 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix9 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix9 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix9 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 9 || arr.GetLength(1) < 9 ? throw new ArgumentException("The array must have a minimum size of 9x9.", nameof(arr)) : new Matrix9(arr);

    public static Matrix9 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 81 => throw new ArgumentException("The array must have a minimum length of 81.", nameof(arr)),
        _ => new Matrix9(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4], arr[ 5], arr[ 6], arr[ 7], arr[ 8],
            arr[ 9], arr[10], arr[11], arr[12], arr[13], arr[14], arr[15], arr[16], arr[17],
            arr[18], arr[19], arr[20], arr[21], arr[22], arr[23], arr[24], arr[25], arr[26],
            arr[27], arr[28], arr[29], arr[30], arr[31], arr[32], arr[33], arr[34], arr[35],
            arr[36], arr[37], arr[38], arr[39], arr[40], arr[41], arr[42], arr[43], arr[44],
            arr[45], arr[46], arr[47], arr[48], arr[49], arr[50], arr[51], arr[52], arr[53],
            arr[54], arr[55], arr[56], arr[57], arr[58], arr[59], arr[60], arr[61], arr[62],
            arr[63], arr[64], arr[65], arr[66], arr[67], arr[68], arr[69], arr[70], arr[71],
            arr[72], arr[73], arr[74], arr[75], arr[76], arr[77], arr[78], arr[79], arr[80]
        )
    };

    public static Matrix9 FromRows(in Vector9[] arr) => FromColumns(arr).Transposed;

    public static Matrix9 FromColumns(in Vector9[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 9 } => new Matrix9(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0], arr[5][0], arr[6][0], arr[7][0], arr[8][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1], arr[5][1], arr[6][1], arr[7][1], arr[8][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2], arr[5][2], arr[6][2], arr[7][2], arr[8][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3], arr[5][3], arr[6][3], arr[7][3], arr[8][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4], arr[5][4], arr[6][4], arr[7][4], arr[8][4],
            arr[0][5], arr[1][5], arr[2][5], arr[3][5], arr[4][5], arr[5][5], arr[6][5], arr[7][5], arr[8][5],
            arr[0][6], arr[1][6], arr[2][6], arr[3][6], arr[4][6], arr[5][6], arr[6][6], arr[7][6], arr[8][6],
            arr[0][7], arr[1][7], arr[2][7], arr[3][7], arr[4][7], arr[5][7], arr[6][7], arr[7][7], arr[8][7],
            arr[0][8], arr[1][8], arr[2][8], arr[3][8], arr[4][8], arr[5][8], arr[6][8], arr[7][8], arr[8][8]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 9.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix9 m1, Matrix9 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix9 m1, Matrix9 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix9 operator +(in Matrix9 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix9 operator -(in Matrix9 m) => m.Negate();

    public static Matrix9 operator +(Scalar f, in Matrix9 m) => m.Add(f);

    public static Matrix9 operator +(in Matrix9 m, Scalar f) => m.Add(f);

    public static Matrix9 operator -(Scalar f, in Matrix9 m) => new Matrix9(f).Subtract(in m);

    public static Matrix9 operator -(in Matrix9 m, Scalar f) => m.Subtract(f);

    public static Matrix9 operator ++(in Matrix9 m) => m.Increment();

    public static Matrix9 operator --(in Matrix9 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix9 operator +(in Matrix9 m1, in Matrix9 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix9 operator -(in Matrix9 m1, in Matrix9 m2) => m1.Subtract(in m2);

    public static Vector9 operator *(in Matrix9 m, in Vector9 v) => m.Multiply(in v);

    public static Matrix9 operator *(in Matrix9 m1, in Matrix9 m2) => m1.Multiply(in m2);

    public static Matrix9 operator *(in Matrix9 m, Scalar f) => m.Multiply(f);

    public static Matrix9 operator *(Scalar f, in Matrix9 m) => m.Multiply(f);

    public static Matrix9 operator ^(in Matrix9 m, int c) => m.Power(c);

    public static Matrix9 operator ^(in Matrix9 m1, in Matrix9 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace9 operator |(Matrix9 A, Vector9 b) => A.Solve(b);

    public static VectorSpace9 operator |(Matrix9 A, VectorSpace9 b) => A.Solve(b);

    public static Matrix9 operator /(Matrix9 m1, Matrix9 m2) => m1.Multiply(m2.Inverse);

    public static Matrix9 operator /(in Matrix9 m, Scalar f) => m.Divide(f);

    public static Matrix9 operator %(in Matrix9 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector9 x0, Vector9 x1, Vector9 x2, Vector9 x3, Vector9 x4, Vector9 x5, Vector9 x6, Vector9 x7, Vector9 x8) (in Matrix9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

    public static implicit operator Matrix9((Vector9 x0, Vector9 x1, Vector9 x2, Vector9 x3, Vector9 x4, Vector9 x5, Vector9 x6, Vector9 x7, Vector9 x8) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c7, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c8) (in Matrix9 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8]);

    public static explicit operator Matrix9(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c7, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8) c8) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7, t.c8);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_8_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_8_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_8_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_8_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_8_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_8_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_8_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7, Scalar x_8_7, Scalar x_0_8, Scalar x_1_8, Scalar x_2_8, Scalar x_3_8, Scalar x_4_8, Scalar x_5_8, Scalar x_6_8, Scalar x_7_8, Scalar x_8_8) (in Matrix9 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0], m._c5[0], m._c6[0], m._c7[0], m._c8[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1], m._c5[1], m._c6[1], m._c7[1], m._c8[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2], m._c5[2], m._c6[2], m._c7[2], m._c8[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3], m._c5[3], m._c6[3], m._c7[3], m._c8[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4], m._c5[4], m._c6[4], m._c7[4], m._c8[4],
        m._c0[5], m._c1[5], m._c2[5], m._c3[5], m._c4[5], m._c5[5], m._c6[5], m._c7[5], m._c8[5],
        m._c0[6], m._c1[6], m._c2[6], m._c3[6], m._c4[6], m._c5[6], m._c6[6], m._c7[6], m._c8[6],
        m._c0[7], m._c1[7], m._c2[7], m._c3[7], m._c4[7], m._c5[7], m._c6[7], m._c7[7], m._c8[7],
        m._c0[8], m._c1[8], m._c2[8], m._c3[8], m._c4[8], m._c5[8], m._c6[8], m._c7[8], m._c8[8]
    );

    public static implicit operator Matrix9(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_8_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_8_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_8_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_8_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_8_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_8_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_8_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7, Scalar x_8_7, Scalar x_0_8, Scalar x_1_8, Scalar x_2_8, Scalar x_3_8, Scalar x_4_8, Scalar x_5_8, Scalar x_6_8, Scalar x_7_8, Scalar x_8_8) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0, t.x_5_0, t.x_6_0, t.x_7_0, t.x_8_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1, t.x_5_1, t.x_6_1, t.x_7_1, t.x_8_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2, t.x_5_2, t.x_6_2, t.x_7_2, t.x_8_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3, t.x_5_3, t.x_6_3, t.x_7_3, t.x_8_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4, t.x_5_4, t.x_6_4, t.x_7_4, t.x_8_4,
        t.x_0_5, t.x_1_5, t.x_2_5, t.x_3_5, t.x_4_5, t.x_5_5, t.x_6_5, t.x_7_5, t.x_8_5,
        t.x_0_6, t.x_1_6, t.x_2_6, t.x_3_6, t.x_4_6, t.x_5_6, t.x_6_6, t.x_7_6, t.x_8_6,
        t.x_0_7, t.x_1_7, t.x_2_7, t.x_3_7, t.x_4_7, t.x_5_7, t.x_6_7, t.x_7_7, t.x_8_7,
        t.x_0_8, t.x_1_8, t.x_2_8, t.x_3_8, t.x_4_8, t.x_5_8, t.x_6_8, t.x_7_8, t.x_8_8
    );

    public static explicit operator Matrix9(Scalar m) => new(m);

    public static implicit operator Matrix9(in Vector9[] arr) => new(arr);

    public static implicit operator Vector9[](in Matrix9 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix9 m) => m.ToArray();

    public static implicit operator Matrix9(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix9 m) => m.Coefficients;

    public static implicit operator Matrix9(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix9 m) => new(m.Coefficients);

    public static explicit operator Matrix9(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix9 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix9>(m);

    public static implicit operator Function<Vector9>(in Matrix9 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix9EqualityComparer
        : IEqualityComparer<Matrix9>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix9 x, Matrix9 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix9 obj) => obj.GetHashCode();
    }
}

public static class Matrix9Extensions
{
    public static Matrix9 Sum(this IEnumerable<Matrix9> matrices) => Matrix9.Zero.Add(matrices.ToArray());

    public static Matrix9 Average(this IEnumerable<Matrix9> matrices)
    {
        Matrix9 mat = Matrix9.Zero;
        long count = 0;

        foreach (Matrix9 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region Matrix10

/// <summary>
/// Represents a square 10x10 matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Matrix10
    : Algebra<Scalar>.IMatrix<Vector10, Matrix10>
    , Algebra<Scalar, Polynomial>.IMatrix<Matrix10, MatrixNM>
    , INative<Matrix10>
    , IEnumerable<Vector10>
    // , Function<Matrix10, Vector10>
    , IEnumerable<Scalar>
    , IComparable<Matrix10>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<Matrix10>
    , IModulusOperators<Matrix10, Scalar, Matrix10>
    , IMultiplyOperators<Matrix10, Matrix10, Matrix10>
    , IMultiplyOperators<Scalar, Matrix10, Matrix10>
    , IMultiplyOperators<Matrix10, Scalar, Matrix10>
    , IDivisionOperators<Matrix10, Scalar, Matrix10>
    , IMultiplyOperators<Vector10, Matrix10, Vector10>
    , IMultiplyOperators<Matrix10, Vector10, Vector10>
    , IDecrementOperators<Matrix10>
    , IAdditionOperators<Matrix10, Matrix10, Matrix10>
    , ISubtractionOperators<Matrix10, Matrix10, Matrix10>
    , IUnaryPlusOperators<Matrix10, Matrix10>
    , IUnaryNegationOperators<Matrix10, Matrix10>
    , IAdditiveIdentity<Matrix10, Matrix10>
    , IMultiplicativeIdentity<Matrix10, Matrix10>
    , IComparisonOperators<Matrix10, Matrix10>
    , IEqualityOperators<Matrix10, Matrix10>
#endif
{
    #region PRIVATE FIELDS

    private readonly Vector10 _c0;
    private readonly Vector10 _c1;
    private readonly Vector10 _c2;
    private readonly Vector10 _c3;
    private readonly Vector10 _c4;
    private readonly Vector10 _c5;
    private readonly Vector10 _c6;
    private readonly Vector10 _c7;
    private readonly Vector10 _c8;
    private readonly Vector10 _c9;

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (10, 10);

    /// <summary>
    /// The 10x10 zero matrix
    /// </summary>
    public static Matrix10 Zero { get; } = new Matrix10(0);

    /// <summary>
    /// The 10x10 identity (unit) matrix
    /// </summary>
    public static Matrix10 Identity { get; } = new(1);

    static Matrix10 IRing<Matrix10>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="Matrix10"/>.
    /// </summary>
    public static Matrix10EqualityComparer EqualityComparer { get; } = new Matrix10EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="Matrix10"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(Matrix10);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector10 this[int column] => GetColumn(column);

    public readonly Vector10 this[Index column] => this[column.GetOffset(10)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix10 this[int column, in Vector10 value] => SetColumn(column, value);

    public readonly Matrix10 this[Index column, in Vector10 value] => this[column.GetOffset(10), value];

    public readonly Matrix10 this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly Matrix10 this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= 10 || column < 0 || column >= 10)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and 9.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new Matrix10(scalars);
        }
    }

    public readonly Matrix10 this[Index column, Index row, Scalar value] => this[column.GetOffset(10), row.GetOffset(10), value];

    public readonly Matrix10 this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

    public readonly ReadOnlyIndexer<int, int, Matrix9> Minors => new ReadOnlyIndexer<int, int, Matrix9>(GetMinor);

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (10, 10);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[10, 10]
    {
        { _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7], _c0[8], _c0[9] },
        { _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7], _c1[8], _c1[9] },
        { _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7], _c2[8], _c2[9] },
        { _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7], _c3[8], _c3[9] },
        { _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7], _c4[8], _c4[9] },
        { _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7], _c5[8], _c5[9] },
        { _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7], _c6[8], _c6[9] },
        { _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7], _c7[8], _c7[9] },
        { _c8[0], _c8[1], _c8[2], _c8[3], _c8[4], _c8[5], _c8[6], _c8[7], _c8[8], _c8[9] },
        { _c9[0], _c9[1], _c9[2], _c9[3], _c9[4], _c9[5], _c9[6], _c9[7], _c9[8], _c9[9] }
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[100] { _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c8[0], _c9[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c8[1], _c9[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c8[2], _c9[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c8[3], _c9[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c8[4], _c9[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c8[5], _c9[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c8[6], _c9[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7], _c8[7], _c9[7], _c0[8], _c1[8], _c2[8], _c3[8], _c4[8], _c5[8], _c6[8], _c7[8], _c8[8], _c9[8], _c0[9], _c1[9], _c2[9], _c3[9], _c4[9], _c5[9], _c6[9], _c7[9], _c8[9], _c9[9] };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly Vector10 MainDiagonal => (_c0[0], _c1[1], _c2[2], _c3[3], _c4[4], _c5[5], _c6[6], _c7[7], _c8[8], _c9[9]);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly Vector10[] Columns => new[] { _c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9 };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly Vector10[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Matrix10 AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();

    /// <summary>
    /// Returns a set of the first 8 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7, Matrix8 Sub8, Matrix9 Sub9) PrincipalSubmatrices => (ToMatrix2(), ToMatrix3(), ToMatrix4(), ToMatrix5(), ToMatrix6(), ToMatrix7(), ToMatrix8(), ToMatrix9());

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly Matrix10 Transposed => (
        _c0[0], _c0[1], _c0[2], _c0[3], _c0[4], _c0[5], _c0[6], _c0[7], _c0[8], _c0[9],
        _c1[0], _c1[1], _c1[2], _c1[3], _c1[4], _c1[5], _c1[6], _c1[7], _c1[8], _c1[9],
        _c2[0], _c2[1], _c2[2], _c2[3], _c2[4], _c2[5], _c2[6], _c2[7], _c2[8], _c2[9],
        _c3[0], _c3[1], _c3[2], _c3[3], _c3[4], _c3[5], _c3[6], _c3[7], _c3[8], _c3[9],
        _c4[0], _c4[1], _c4[2], _c4[3], _c4[4], _c4[5], _c4[6], _c4[7], _c4[8], _c4[9],
        _c5[0], _c5[1], _c5[2], _c5[3], _c5[4], _c5[5], _c5[6], _c5[7], _c5[8], _c5[9],
        _c6[0], _c6[1], _c6[2], _c6[3], _c6[4], _c6[5], _c6[6], _c6[7], _c6[8], _c6[9],
        _c7[0], _c7[1], _c7[2], _c7[3], _c7[4], _c7[5], _c7[6], _c7[7], _c7[8], _c7[9],
        _c8[0], _c8[1], _c8[2], _c8[3], _c8[4], _c8[5], _c8[6], _c8[7], _c8[8], _c8[9],
        _c9[0], _c9[1], _c9[2], _c9[3], _c9[4], _c9[5], _c9[6], _c9[7], _c9[8], _c9[9]
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar Matrix10::Inverse' instead.")]
    public readonly Matrix10 MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly Matrix10 GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly Matrix10 OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Vector10[] vs = Columns;

            for (int i = 0; i < 10; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
        + GetMinor(0, 0).Determinant
        - GetMinor(0, 1).Determinant
        + GetMinor(0, 2).Determinant
        - GetMinor(0, 3).Determinant
        + GetMinor(0, 4).Determinant
        - GetMinor(0, 5).Determinant
        + GetMinor(0, 6).Determinant
        - GetMinor(0, 7).Determinant
        + GetMinor(0, 8).Determinant
        - GetMinor(0, 9).Determinant;

    public readonly Matrix10 Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            Matrix10 m = this;
            // TODO : verify the following code
            Matrix10 u = Identity;

            for (int i = 0; i < 10; ++i)
            {
                int max = i;

                for (int j = i + 1; j < 10; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < 10; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = 10 - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
        }
    }

    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly Vector10[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != Vector10.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the 10x10 identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => _c0.IsBinary && _c1.IsBinary && _c2.IsBinary && _c3.IsBinary && _c4.IsBinary && _c5.IsBinary && _c6.IsBinary && _c7.IsBinary && _c8.IsBinary && _c9.IsBinary;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            Vector10[] rows = Rows;

            for (int i = 0; i < 10; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < 10; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 10; ++c)
                for (int r = 0; r < 10; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < 10; ++c)
                for (int r = c + 1; r < 10; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Matrix10 ctc = Transposed * this;

            return (ctc - new Matrix10(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 10x10-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public Matrix10(Scalar scale)
        : this(scale, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0, scale, 0, 0, 0, 0, 0, 0, 0, 0,
               0, 0, scale, 0, 0, 0, 0, 0, 0, 0,
               0, 0, 0, scale, 0, 0, 0, 0, 0, 0,
               0, 0, 0, 0, scale, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 0, scale, 0, 0, 0, 0,
               0, 0, 0, 0, 0, 0, scale, 0, 0, 0,
               0, 0, 0, 0, 0, 0, 0, scale, 0, 0,
               0, 0, 0, 0, 0, 0, 0, 0, scale, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, scale)
    {
    }

    /// <summary>
    /// Creates a new 10x10-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="diag_0">The diagonal element at the position (0, 0).</param>
    /// <param name="diag_1">The diagonal element at the position (1, 1).</param>
    /// <param name="diag_2">The diagonal element at the position (2, 2).</param>
    /// <param name="diag_3">The diagonal element at the position (3, 3).</param>
    /// <param name="diag_4">The diagonal element at the position (4, 4).</param>
    /// <param name="diag_5">The diagonal element at the position (5, 5).</param>
    /// <param name="diag_6">The diagonal element at the position (6, 6).</param>
    /// <param name="diag_7">The diagonal element at the position (7, 7).</param>
    /// <param name="diag_8">The diagonal element at the position (8, 8).</param>
    /// <param name="diag_9">The diagonal element at the position (9, 9).</param>
    public Matrix10(Scalar diag_0, Scalar diag_1, Scalar diag_2, Scalar diag_3, Scalar diag_4, Scalar diag_5, Scalar diag_6, Scalar diag_7, Scalar diag_8, Scalar diag_9)
        : this(diag_0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
               0, diag_1, 0, 0, 0, 0, 0, 0, 0, 0,
               0, 0, diag_2, 0, 0, 0, 0, 0, 0, 0,
               0, 0, 0, diag_3, 0, 0, 0, 0, 0, 0,
               0, 0, 0, 0, diag_4, 0, 0, 0, 0, 0,
               0, 0, 0, 0, 0, diag_5, 0, 0, 0, 0,
               0, 0, 0, 0, 0, 0, diag_6, 0, 0, 0,
               0, 0, 0, 0, 0, 0, 0, diag_7, 0, 0,
               0, 0, 0, 0, 0, 0, 0, 0, diag_8, 0,
               0, 0, 0, 0, 0, 0, 0, 0, 0, diag_9)
    {
    }

    public Matrix10(Scalar s_0_0, Scalar s_1_0, Scalar s_2_0, Scalar s_3_0, Scalar s_4_0, Scalar s_5_0, Scalar s_6_0, Scalar s_7_0, Scalar s_8_0, Scalar s_9_0, Scalar s_0_1, Scalar s_1_1, Scalar s_2_1, Scalar s_3_1, Scalar s_4_1, Scalar s_5_1, Scalar s_6_1, Scalar s_7_1, Scalar s_8_1, Scalar s_9_1, Scalar s_0_2, Scalar s_1_2, Scalar s_2_2, Scalar s_3_2, Scalar s_4_2, Scalar s_5_2, Scalar s_6_2, Scalar s_7_2, Scalar s_8_2, Scalar s_9_2, Scalar s_0_3, Scalar s_1_3, Scalar s_2_3, Scalar s_3_3, Scalar s_4_3, Scalar s_5_3, Scalar s_6_3, Scalar s_7_3, Scalar s_8_3, Scalar s_9_3, Scalar s_0_4, Scalar s_1_4, Scalar s_2_4, Scalar s_3_4, Scalar s_4_4, Scalar s_5_4, Scalar s_6_4, Scalar s_7_4, Scalar s_8_4, Scalar s_9_4, Scalar s_0_5, Scalar s_1_5, Scalar s_2_5, Scalar s_3_5, Scalar s_4_5, Scalar s_5_5, Scalar s_6_5, Scalar s_7_5, Scalar s_8_5, Scalar s_9_5, Scalar s_0_6, Scalar s_1_6, Scalar s_2_6, Scalar s_3_6, Scalar s_4_6, Scalar s_5_6, Scalar s_6_6, Scalar s_7_6, Scalar s_8_6, Scalar s_9_6, Scalar s_0_7, Scalar s_1_7, Scalar s_2_7, Scalar s_3_7, Scalar s_4_7, Scalar s_5_7, Scalar s_6_7, Scalar s_7_7, Scalar s_8_7, Scalar s_9_7, Scalar s_0_8, Scalar s_1_8, Scalar s_2_8, Scalar s_3_8, Scalar s_4_8, Scalar s_5_8, Scalar s_6_8, Scalar s_7_8, Scalar s_8_8, Scalar s_9_8, Scalar s_0_9, Scalar s_1_9, Scalar s_2_9, Scalar s_3_9, Scalar s_4_9, Scalar s_5_9, Scalar s_6_9, Scalar s_7_9, Scalar s_8_9, Scalar s_9_9)
        : this(new Vector10(s_0_0, s_0_1, s_0_2, s_0_3, s_0_4, s_0_5, s_0_6, s_0_7, s_0_8, s_0_9),
               new Vector10(s_1_0, s_1_1, s_1_2, s_1_3, s_1_4, s_1_5, s_1_6, s_1_7, s_1_8, s_1_9),
               new Vector10(s_2_0, s_2_1, s_2_2, s_2_3, s_2_4, s_2_5, s_2_6, s_2_7, s_2_8, s_2_9),
               new Vector10(s_3_0, s_3_1, s_3_2, s_3_3, s_3_4, s_3_5, s_3_6, s_3_7, s_3_8, s_3_9),
               new Vector10(s_4_0, s_4_1, s_4_2, s_4_3, s_4_4, s_4_5, s_4_6, s_4_7, s_4_8, s_4_9),
               new Vector10(s_5_0, s_5_1, s_5_2, s_5_3, s_5_4, s_5_5, s_5_6, s_5_7, s_5_8, s_5_9),
               new Vector10(s_6_0, s_6_1, s_6_2, s_6_3, s_6_4, s_6_5, s_6_6, s_6_7, s_6_8, s_6_9),
               new Vector10(s_7_0, s_7_1, s_7_2, s_7_3, s_7_4, s_7_5, s_7_6, s_7_7, s_7_8, s_7_9),
               new Vector10(s_8_0, s_8_1, s_8_2, s_8_3, s_8_4, s_8_5, s_8_6, s_8_7, s_8_8, s_8_9),
               new Vector10(s_9_0, s_9_1, s_9_2, s_9_3, s_9_4, s_9_5, s_9_6, s_9_7, s_9_8, s_9_9))
    {
    }

    public Matrix10(Scalar[] values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9],
               values[10], values[11], values[12], values[13], values[14], values[15], values[16], values[17], values[18], values[19],
               values[20], values[21], values[22], values[23], values[24], values[25], values[26], values[27], values[28], values[29],
               values[30], values[31], values[32], values[33], values[34], values[35], values[36], values[37], values[38], values[39],
               values[40], values[41], values[42], values[43], values[44], values[45], values[46], values[47], values[48], values[49],
               values[50], values[51], values[52], values[53], values[54], values[55], values[56], values[57], values[58], values[59],
               values[60], values[61], values[62], values[63], values[64], values[65], values[66], values[67], values[68], values[69],
               values[70], values[71], values[72], values[73], values[74], values[75], values[76], values[77], values[78], values[79],
               values[80], values[81], values[82], values[83], values[84], values[85], values[86], values[87], values[88], values[89],
               values[90], values[91], values[92], values[93], values[94], values[95], values[96], values[97], values[98], values[99])
    {
    }

    public Matrix10(Scalar[,] values)
        : this(values[0, 0], values[1, 0], values[2, 0], values[3, 0], values[4, 0], values[5, 0], values[6, 0], values[7, 0], values[8, 0], values[9, 0],
               values[0, 1], values[1, 1], values[2, 1], values[3, 1], values[4, 1], values[5, 1], values[6, 1], values[7, 1], values[8, 1], values[9, 1],
               values[0, 2], values[1, 2], values[2, 2], values[3, 2], values[4, 2], values[5, 2], values[6, 2], values[7, 2], values[8, 2], values[9, 2],
               values[0, 3], values[1, 3], values[2, 3], values[3, 3], values[4, 3], values[5, 3], values[6, 3], values[7, 3], values[8, 3], values[9, 3],
               values[0, 4], values[1, 4], values[2, 4], values[3, 4], values[4, 4], values[5, 4], values[6, 4], values[7, 4], values[8, 4], values[9, 4],
               values[0, 5], values[1, 5], values[2, 5], values[3, 5], values[4, 5], values[5, 5], values[6, 5], values[7, 5], values[8, 5], values[9, 5],
               values[0, 6], values[1, 6], values[2, 6], values[3, 6], values[4, 6], values[5, 6], values[6, 6], values[7, 6], values[8, 6], values[9, 6],
               values[0, 7], values[1, 7], values[2, 7], values[3, 7], values[4, 7], values[5, 7], values[6, 7], values[7, 7], values[8, 7], values[9, 7],
               values[0, 8], values[1, 8], values[2, 8], values[3, 8], values[4, 8], values[5, 8], values[6, 8], values[7, 8], values[8, 8], values[9, 8],
               values[0, 9], values[1, 9], values[2, 9], values[3, 9], values[4, 9], values[5, 9], values[6, 9], values[7, 9], values[8, 9], values[9, 9])
    {
    }

    public Matrix10(Scalar[][] values)
        : this(values[0][0], values[1][0], values[2][0], values[3][0], values[4][0], values[5][0], values[6][0], values[7][0], values[8][0], values[9][0],
               values[0][1], values[1][1], values[2][1], values[3][1], values[4][1], values[5][1], values[6][1], values[7][1], values[8][1], values[9][1],
               values[0][2], values[1][2], values[2][2], values[3][2], values[4][2], values[5][2], values[6][2], values[7][2], values[8][2], values[9][2],
               values[0][3], values[1][3], values[2][3], values[3][3], values[4][3], values[5][3], values[6][3], values[7][3], values[8][3], values[9][3],
               values[0][4], values[1][4], values[2][4], values[3][4], values[4][4], values[5][4], values[6][4], values[7][4], values[8][4], values[9][4],
               values[0][5], values[1][5], values[2][5], values[3][5], values[4][5], values[5][5], values[6][5], values[7][5], values[8][5], values[9][5],
               values[0][6], values[1][6], values[2][6], values[3][6], values[4][6], values[5][6], values[6][6], values[7][6], values[8][6], values[9][6],
               values[0][7], values[1][7], values[2][7], values[3][7], values[4][7], values[5][7], values[6][7], values[7][7], values[8][7], values[9][7],
               values[0][8], values[1][8], values[2][8], values[3][8], values[4][8], values[5][8], values[6][8], values[7][8], values[8][8], values[9][8],
               values[0][9], values[1][9], values[2][9], values[3][9], values[4][9], values[5][9], values[6][9], values[7][9], values[8][9], values[9][9])
    {
    }

    public Matrix10(in Matrix2 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix3 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix4 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix5 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), new Vector10(matrix[4]), Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix6 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), new Vector10(matrix[4]), new Vector10(matrix[5]), Vector10.Zero, Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix7 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), new Vector10(matrix[4]), new Vector10(matrix[5]), new Vector10(matrix[6]), Vector10.Zero, Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix8 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), new Vector10(matrix[4]), new Vector10(matrix[5]), new Vector10(matrix[6]), new Vector10(matrix[7]), Vector10.Zero, Vector10.Zero)
    {
    }

    public Matrix10(in Matrix9 matrix)
        : this(new Vector10(matrix[0]), new Vector10(matrix[1]), new Vector10(matrix[2]), new Vector10(matrix[3]), new Vector10(matrix[4]), new Vector10(matrix[5]), new Vector10(matrix[6]), new Vector10(matrix[7]), new Vector10(matrix[8]), Vector10.Zero)
    {
    }

    public Matrix10(in Matrix10 matrix)
        : this(matrix.Columns)
    {
    }

    public Matrix10(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public Matrix10(Matrix10* matrix)
        : this(*matrix)
    {
    }

    public Matrix10(Scalar* values)
        : this(values[0], values[1], values[2], values[3], values[4], values[5], values[6], values[7], values[8], values[9],
               values[10], values[11], values[12], values[13], values[14], values[15], values[16], values[17], values[18], values[19],
               values[20], values[21], values[22], values[23], values[24], values[25], values[26], values[27], values[28], values[29],
               values[30], values[31], values[32], values[33], values[34], values[35], values[36], values[37], values[38], values[39],
               values[40], values[41], values[42], values[43], values[44], values[45], values[46], values[47], values[48], values[49],
               values[50], values[51], values[52], values[53], values[54], values[55], values[56], values[57], values[58], values[59],
               values[60], values[61], values[62], values[63], values[64], values[65], values[66], values[67], values[68], values[69],
               values[70], values[71], values[72], values[73], values[74], values[75], values[76], values[77], values[78], values[79],
               values[80], values[81], values[82], values[83], values[84], values[85], values[86], values[87], values[88], values[89],
               values[90], values[91], values[92], values[93], values[94], values[95], values[96], values[97], values[98], values[99])
    {
    }

    public Matrix10(Vector10* columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7], columns[8], columns[9])
    {
    }

    public Matrix10(IEnumerable<Vector10> columns)
        : this(columns.ToArray())
    {
    }

    public Matrix10(Vector10[] columns)
        : this(columns[0], columns[1], columns[2], columns[3], columns[4], columns[5], columns[6], columns[7], columns[8], columns[9])
    {
    }

    public Matrix10(Vector10 v0, Vector10 v1, Vector10 v2, Vector10 v3, Vector10 v4, Vector10 v5, Vector10 v6, Vector10 v7, Vector10 v8, Vector10 v9)
    {
        _c0 = v0;
        _c1 = v1;
        _c2 = v2;
        _c3 = v3;
        _c4 = v4;
        _c5 = v5;
        _c6 = v6;
        _c7 = v7;
        _c8 = v8;
        _c9 = v9;
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly Matrix10 Negate() => new(-_c0, -_c1, -_c2, -_c3, -_c4, -_c5, -_c6, -_c7, -_c8, -_c9);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly Matrix10 Add(in Matrix10 second) => new(_c0 + second._c0, _c1 + second._c1, _c2 + second._c2, _c3 + second._c3, _c4 + second._c4, _c5 + second._c5, _c6 + second._c6, _c7 + second._c7, _c8 + second._c8, _c9 + second._c9);

    public readonly Matrix10 Add(params Matrix10[] matrices) => matrices.Aggregate(this, Add);

    public readonly Matrix10 Add(Scalar Scalar) => Add(new Matrix10(Scalar));

    public readonly Matrix10 Increment() => Add(1);

    public readonly Matrix10 Decrement() => Add(-1);

    public readonly Matrix10 Subtract(in Matrix10 second) => Add(second.Negate());

    public readonly Matrix10 Subtract(params Matrix10[] matrices) => matrices.Aggregate(this, Subtract);

    public Matrix10 Subtract(Scalar scalar) => Add(scalar.Negate());

    public readonly Vector9 HomogeneousMultiply(in Vector9 second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix10 Multiply(in Matrix10 second)
    {
        Vector10[] A = Rows;
        Vector10[] B = second.Columns;
        Scalar[,] C = new Scalar[10, 10];

        for (int r = 0; r < 10; ++r)
            for (int c = 0; c < 10; ++c)
                C[c, r] = A[r] * B[c];

        return new Matrix10(C);
    }

    public readonly Matrix10 Multiply(params Matrix10[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly Vector10 Multiply(in Vector10 vector) => new(
        _c0[0] * vector[0] + _c1[0] * vector[1] + _c2[0] * vector[2] + _c3[0] * vector[3] + _c4[0] * vector[4] + _c5[0] * vector[5] + _c6[0] * vector[6] + _c7[0] * vector[7] + _c8[0] * vector[8] + _c9[0] * vector[9],
        _c0[1] * vector[0] + _c1[1] * vector[1] + _c2[1] * vector[2] + _c3[1] * vector[3] + _c4[1] * vector[4] + _c5[1] * vector[5] + _c6[1] * vector[6] + _c7[1] * vector[7] + _c8[1] * vector[8] + _c9[1] * vector[9],
        _c0[2] * vector[0] + _c1[2] * vector[1] + _c2[2] * vector[2] + _c3[2] * vector[3] + _c4[2] * vector[4] + _c5[2] * vector[5] + _c6[2] * vector[6] + _c7[2] * vector[7] + _c8[2] * vector[8] + _c9[2] * vector[9],
        _c0[3] * vector[0] + _c1[3] * vector[1] + _c2[3] * vector[2] + _c3[3] * vector[3] + _c4[3] * vector[4] + _c5[3] * vector[5] + _c6[3] * vector[6] + _c7[3] * vector[7] + _c8[3] * vector[8] + _c9[3] * vector[9],
        _c0[4] * vector[0] + _c1[4] * vector[1] + _c2[4] * vector[2] + _c3[4] * vector[3] + _c4[4] * vector[4] + _c5[4] * vector[5] + _c6[4] * vector[6] + _c7[4] * vector[7] + _c8[4] * vector[8] + _c9[4] * vector[9],
        _c0[5] * vector[0] + _c1[5] * vector[1] + _c2[5] * vector[2] + _c3[5] * vector[3] + _c4[5] * vector[4] + _c5[5] * vector[5] + _c6[5] * vector[6] + _c7[5] * vector[7] + _c8[5] * vector[8] + _c9[5] * vector[9],
        _c0[6] * vector[0] + _c1[6] * vector[1] + _c2[6] * vector[2] + _c3[6] * vector[3] + _c4[6] * vector[4] + _c5[6] * vector[5] + _c6[6] * vector[6] + _c7[6] * vector[7] + _c8[6] * vector[8] + _c9[6] * vector[9],
        _c0[7] * vector[0] + _c1[7] * vector[1] + _c2[7] * vector[2] + _c3[7] * vector[3] + _c4[7] * vector[4] + _c5[7] * vector[5] + _c6[7] * vector[6] + _c7[7] * vector[7] + _c8[7] * vector[8] + _c9[7] * vector[9],
        _c0[8] * vector[0] + _c1[8] * vector[1] + _c2[8] * vector[2] + _c3[8] * vector[3] + _c4[8] * vector[4] + _c5[8] * vector[5] + _c6[8] * vector[6] + _c7[8] * vector[7] + _c8[8] * vector[8] + _c9[8] * vector[9],
        _c0[9] * vector[0] + _c1[9] * vector[1] + _c2[9] * vector[2] + _c3[9] * vector[3] + _c4[9] * vector[4] + _c5[9] * vector[5] + _c6[9] * vector[6] + _c7[9] * vector[7] + _c8[9] * vector[8] + _c9[9] * vector[9]
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly Matrix10 Multiply(Scalar factor) => new(_c0 * factor, _c1 * factor, _c2 * factor, _c3 * factor, _c4 * factor, _c5 * factor, _c6 * factor, _c7 * factor, _c8 * factor, _c9 * factor);

    public readonly Matrix10 Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public Matrix10 Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        Matrix10 r = Identity;
        Matrix10 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly Matrix10 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Matrix10 Modulus(Scalar factor) => new(_c0 % factor, _c1 % factor, _c2 % factor, _c3 % factor, _c4 % factor, _c5 % factor, _c6 % factor, _c7 % factor, _c8 % factor, _c9 % factor);

    public readonly Matrix10 Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix10 result = this;
        Matrix10 exponent = this;
        Matrix10 squared = Multiply(this);
        Matrix10 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix10 Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix10 result = Identity;
        Matrix10 exponent = this;
        Matrix10 squared = Multiply(this);
        Matrix10 last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Matrix10 Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        Matrix10 result = Identity;
        Matrix10 exponent = this;
        Matrix10 last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(Matrix10 other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly Matrix10 ComponentwiseDivide(in Matrix10 second) => new(_c0.ComponentwiseDivide(second._c0), _c1.ComponentwiseDivide(second._c1), _c2.ComponentwiseDivide(second._c2), _c3.ComponentwiseDivide(second._c3), _c4.ComponentwiseDivide(second._c4), _c5.ComponentwiseDivide(second._c5), _c6.ComponentwiseDivide(second._c6), _c7.ComponentwiseDivide(second._c7), _c8.ComponentwiseDivide(second._c8), _c9.ComponentwiseDivide(second._c9));

    public readonly Matrix10 ComponentwiseMultiply(in Matrix10 second) => new(_c0.ComponentwiseMultiply(second._c0), _c1.ComponentwiseMultiply(second._c1), _c2.ComponentwiseMultiply(second._c2), _c3.ComponentwiseMultiply(second._c3), _c4.ComponentwiseMultiply(second._c4), _c5.ComponentwiseMultiply(second._c5), _c6.ComponentwiseMultiply(second._c6), _c7.ComponentwiseMultiply(second._c7), _c8.ComponentwiseMultiply(second._c8), _c9.ComponentwiseMultiply(second._c9));

    public readonly Matrix10 ComponentwiseApply(Func<Scalar, Scalar> function) => new(_c0.ComponentwiseApply(function), _c1.ComponentwiseApply(function), _c2.ComponentwiseApply(function), _c3.ComponentwiseApply(function), _c4.ComponentwiseApply(function), _c5.ComponentwiseApply(function), _c6.ComponentwiseApply(function), _c7.ComponentwiseApply(function), _c8.ComponentwiseApply(function), _c9.ComponentwiseApply(function));

    public readonly Matrix10 ComponentwiseApply(Matrix10 second, Func<Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, function), _c1.ComponentwiseApply(second._c1, function), _c2.ComponentwiseApply(second._c2, function), _c3.ComponentwiseApply(second._c3, function), _c4.ComponentwiseApply(second._c4, function), _c5.ComponentwiseApply(second._c5, function), _c6.ComponentwiseApply(second._c6, function), _c7.ComponentwiseApply(second._c7, function), _c8.ComponentwiseApply(second._c8, function), _c9.ComponentwiseApply(second._c9, function));

    public readonly Matrix10 ComponentwiseApply(Matrix10 second, Matrix10 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(_c0.ComponentwiseApply(second._c0, third._c0, function), _c1.ComponentwiseApply(second._c1, third._c1, function), _c2.ComponentwiseApply(second._c2, third._c2, function), _c3.ComponentwiseApply(second._c3, third._c3, function), _c4.ComponentwiseApply(second._c4, third._c4, function), _c5.ComponentwiseApply(second._c5, third._c5, function), _c6.ComponentwiseApply(second._c6, third._c6, function), _c7.ComponentwiseApply(second._c7, third._c7, function), _c8.ComponentwiseApply(second._c8, third._c8, function), _c9.ComponentwiseApply(second._c9, third._c9, function));

    public readonly Matrix10 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Matrix10 Clamp(Scalar low, Scalar high) => new(_c0.Clamp(low, high), _c1.Clamp(low, high), _c2.Clamp(low, high), _c3.Clamp(low, high), _c4.Clamp(low, high), _c5.Clamp(low, high), _c6.Clamp(low, high), _c7.Clamp(low, high), _c8.Clamp(low, high), _c9.Clamp(low, high));

    public readonly Matrix10 LinearInterpolate(in Matrix10 other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in Matrix10 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 10; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first 8 principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
    {
        (Matrix2 Sub2, Matrix3 Sub3, Matrix4 Sub4, Matrix5 Sub5, Matrix6 Sub6, Matrix7 Sub7, Matrix8 Sub8, Matrix9 Sub9) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], Sub2, Sub3, Sub4, Sub5, Sub6, Sub7, Sub8, Sub9 };
    }

    internal readonly Matrix10 GetLinearIndependentForm()
    {
        Matrix10 m = this;

        for (int row = 0; row < 10; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 10; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 10; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector">Vector10</param>
    /// <returns>Solution</returns>
    public readonly VectorSpace10 Solve(Vector10 vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            Vector10 x = vector;

            for (int i = 0; i < 10; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < 10; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            Vector10 x = vector;

            for (int i = 9; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (Matrix10 P, Matrix10 L, Matrix10 U) = PLUDecompose();
        VectorSpace10 y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new VectorSpace10(SolveCG(vector));
    }

    public readonly VectorSpace10 Solve(VectorSpace10 vectorspace)
    {
        VectorSpace10 result = VectorSpace10.Empty;

        if (!vectorspace.IsEmpty)
            foreach (VectorSpace10 solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<Vector10, Matrix10>.Solve(Vector10 vector, out Vector10 solution)
    {
        VectorSpace10 space = Solve(vector);
        solution = Vector10.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly Vector10 SolveCG(Vector10 vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        Vector10 x = vector;
        Vector10 r = vector - Multiply(vector);
        Vector10 d = r;

        for (int i = 0; i < 10; ++i)
        {
            if (r.Length.IsZero)
                break;

            Vector10 ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            Vector10 rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        Matrix10 m = this;
        Vector10 v = vector;

        for (int row = 0; row < 10; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < 10; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < 10; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = 9; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (Vector10[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (Vector10 vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        Vector10[] vectors = pairs.Select(p => p.vec).Distinct(Vector10.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (Vector10 Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (Vector10 vec, Scalar val)[] pairs = new (Vector10, Scalar)[10];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= 10; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (Vector10 Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        Vector10 v_old = default;
        Vector10 v_new = Vector10.GetRandomCartesianUnitVector();
        Vector10 v_init = v_new;
        Matrix10 A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        Vector10 w = default;

        while ((w * v_init).IsZero)
            w = Vector10.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly VectorSpace10 GetEigenspace(Scalar eigenvalue) => VectorSpace10.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (Matrix10 P, Matrix10 S, Matrix10 Pn) Diagonalize(Scalar tolerance)
    {
        (Vector10 v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        Matrix10 P = new Matrix10(pairs[0].v, pairs[1].v, pairs[2].v, pairs[3].v, pairs[4].v, pairs[5].v, pairs[6].v, pairs[7].v, pairs[8].v, pairs[9].v);
        Matrix10 S = new Matrix10(pairs[0].λ, pairs[1].λ, pairs[2].λ, pairs[3].λ, pairs[4].λ, pairs[5].λ, pairs[6].λ, pairs[7].λ, pairs[8].λ, pairs[9].λ);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (Matrix10 P, Matrix10 L, Matrix10 U) PLUDecompose()
    {
        int[] perm = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
        Matrix10 U = Identity;
        Matrix10 L = this;

        for (int i = 0; i < 9; ++i)
        {
            Vector10 column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < 10; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < 10; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

    public readonly (Matrix5 A, Matrix5 C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(5);

        return ((Matrix5)A, (Matrix5)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= 10)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and 10.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly Matrix10 CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

        // TODO : cholesky decomposition
        /*
        Matrix10 res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
    }

    public readonly (Matrix10 Q, Matrix10 R) QRDecompose()
    {
        Matrix10 A = this;
        (Vector10 v0_0, Vector10 v0_1, Vector10 v0_2, Vector10 v0_3, Vector10 v0_4, Vector10 v0_5, Vector10 v0_6, Vector10 v0_7, Vector10 v0_8, Vector10 v0_9) = A;
        Vector10 v0 = v0_0 + new Vector10(v0_0[0].Sign * v0_0.Length, 0, 0, 0, 0, 0, 0, 0, 0, 0);

        v0 = ~v0;
        v0_0 -= (2 * (v0 * v0_0)) * v0;
        v0_1 -= (2 * (v0 * v0_1)) * v0;
        v0_2 -= (2 * (v0 * v0_2)) * v0;
        v0_3 -= (2 * (v0 * v0_3)) * v0;
        v0_4 -= (2 * (v0 * v0_4)) * v0;
        v0_5 -= (2 * (v0 * v0_5)) * v0;
        v0_6 -= (2 * (v0 * v0_6)) * v0;
        v0_7 -= (2 * (v0 * v0_7)) * v0;
        v0_8 -= (2 * (v0 * v0_8)) * v0;
        v0_9 -= (2 * (v0 * v0_9)) * v0;

        Vector9 v1_0 = (v0_1[1], v0_1[2], v0_1[3], v0_1[4], v0_1[5], v0_1[6], v0_1[7], v0_1[8], v0_1[9]);
        Vector9 v1_1 = (v0_2[1], v0_2[2], v0_2[3], v0_2[4], v0_2[5], v0_2[6], v0_2[7], v0_2[8], v0_2[9]);
        Vector9 v1_2 = (v0_3[1], v0_3[2], v0_3[3], v0_3[4], v0_3[5], v0_3[6], v0_3[7], v0_3[8], v0_3[9]);
        Vector9 v1_3 = (v0_4[1], v0_4[2], v0_4[3], v0_4[4], v0_4[5], v0_4[6], v0_4[7], v0_4[8], v0_4[9]);
        Vector9 v1_4 = (v0_5[1], v0_5[2], v0_5[3], v0_5[4], v0_5[5], v0_5[6], v0_5[7], v0_5[8], v0_5[9]);
        Vector9 v1_5 = (v0_6[1], v0_6[2], v0_6[3], v0_6[4], v0_6[5], v0_6[6], v0_6[7], v0_6[8], v0_6[9]);
        Vector9 v1_6 = (v0_7[1], v0_7[2], v0_7[3], v0_7[4], v0_7[5], v0_7[6], v0_7[7], v0_7[8], v0_7[9]);
        Vector9 v1_7 = (v0_8[1], v0_8[2], v0_8[3], v0_8[4], v0_8[5], v0_8[6], v0_8[7], v0_8[8], v0_8[9]);
        Vector9 v1_8 = (v0_9[1], v0_9[2], v0_9[3], v0_9[4], v0_9[5], v0_9[6], v0_9[7], v0_9[8], v0_9[9]);
        Vector9 v1 = v1_0 + new Vector9(v1_0[0].Sign * v1_0.Length, 0, 0, 0, 0, 0, 0, 0, 0);

        v1 = ~v1;
        v1_0 -= (2 * (v1 * v1_0)) * v1;
        v1_1 -= (2 * (v1 * v1_1)) * v1;
        v1_2 -= (2 * (v1 * v1_2)) * v1;
        v1_3 -= (2 * (v1 * v1_3)) * v1;
        v1_4 -= (2 * (v1 * v1_4)) * v1;
        v1_5 -= (2 * (v1 * v1_5)) * v1;
        v1_6 -= (2 * (v1 * v1_6)) * v1;
        v1_7 -= (2 * (v1 * v1_7)) * v1;
        v1_8 -= (2 * (v1 * v1_8)) * v1;

        Vector8 v2_0 = (v1_1[1], v1_1[2], v1_1[3], v1_1[4], v1_1[5], v1_1[6], v1_1[7], v1_1[8]);
        Vector8 v2_1 = (v1_2[1], v1_2[2], v1_2[3], v1_2[4], v1_2[5], v1_2[6], v1_2[7], v1_2[8]);
        Vector8 v2_2 = (v1_3[1], v1_3[2], v1_3[3], v1_3[4], v1_3[5], v1_3[6], v1_3[7], v1_3[8]);
        Vector8 v2_3 = (v1_4[1], v1_4[2], v1_4[3], v1_4[4], v1_4[5], v1_4[6], v1_4[7], v1_4[8]);
        Vector8 v2_4 = (v1_5[1], v1_5[2], v1_5[3], v1_5[4], v1_5[5], v1_5[6], v1_5[7], v1_5[8]);
        Vector8 v2_5 = (v1_6[1], v1_6[2], v1_6[3], v1_6[4], v1_6[5], v1_6[6], v1_6[7], v1_6[8]);
        Vector8 v2_6 = (v1_7[1], v1_7[2], v1_7[3], v1_7[4], v1_7[5], v1_7[6], v1_7[7], v1_7[8]);
        Vector8 v2_7 = (v1_8[1], v1_8[2], v1_8[3], v1_8[4], v1_8[5], v1_8[6], v1_8[7], v1_8[8]);
        Vector8 v2 = v2_0 + new Vector8(v2_0[0].Sign * v2_0.Length, 0, 0, 0, 0, 0, 0, 0);

        v2 = ~v2;
        v2_0 -= (2 * (v2 * v2_0)) * v2;
        v2_1 -= (2 * (v2 * v2_1)) * v2;
        v2_2 -= (2 * (v2 * v2_2)) * v2;
        v2_3 -= (2 * (v2 * v2_3)) * v2;
        v2_4 -= (2 * (v2 * v2_4)) * v2;
        v2_5 -= (2 * (v2 * v2_5)) * v2;
        v2_6 -= (2 * (v2 * v2_6)) * v2;
        v2_7 -= (2 * (v2 * v2_7)) * v2;

        Vector7 v3_0 = (v2_1[1], v2_1[2], v2_1[3], v2_1[4], v2_1[5], v2_1[6], v2_1[7]);
        Vector7 v3_1 = (v2_2[1], v2_2[2], v2_2[3], v2_2[4], v2_2[5], v2_2[6], v2_2[7]);
        Vector7 v3_2 = (v2_3[1], v2_3[2], v2_3[3], v2_3[4], v2_3[5], v2_3[6], v2_3[7]);
        Vector7 v3_3 = (v2_4[1], v2_4[2], v2_4[3], v2_4[4], v2_4[5], v2_4[6], v2_4[7]);
        Vector7 v3_4 = (v2_5[1], v2_5[2], v2_5[3], v2_5[4], v2_5[5], v2_5[6], v2_5[7]);
        Vector7 v3_5 = (v2_6[1], v2_6[2], v2_6[3], v2_6[4], v2_6[5], v2_6[6], v2_6[7]);
        Vector7 v3_6 = (v2_7[1], v2_7[2], v2_7[3], v2_7[4], v2_7[5], v2_7[6], v2_7[7]);
        Vector7 v3 = v3_0 + new Vector7(v3_0[0].Sign * v3_0.Length, 0, 0, 0, 0, 0, 0);

        v3 = ~v3;
        v3_0 -= (2 * (v3 * v3_0)) * v3;
        v3_1 -= (2 * (v3 * v3_1)) * v3;
        v3_2 -= (2 * (v3 * v3_2)) * v3;
        v3_3 -= (2 * (v3 * v3_3)) * v3;
        v3_4 -= (2 * (v3 * v3_4)) * v3;
        v3_5 -= (2 * (v3 * v3_5)) * v3;
        v3_6 -= (2 * (v3 * v3_6)) * v3;

        Vector6 v4_0 = (v3_1[1], v3_1[2], v3_1[3], v3_1[4], v3_1[5], v3_1[6]);
        Vector6 v4_1 = (v3_2[1], v3_2[2], v3_2[3], v3_2[4], v3_2[5], v3_2[6]);
        Vector6 v4_2 = (v3_3[1], v3_3[2], v3_3[3], v3_3[4], v3_3[5], v3_3[6]);
        Vector6 v4_3 = (v3_4[1], v3_4[2], v3_4[3], v3_4[4], v3_4[5], v3_4[6]);
        Vector6 v4_4 = (v3_5[1], v3_5[2], v3_5[3], v3_5[4], v3_5[5], v3_5[6]);
        Vector6 v4_5 = (v3_6[1], v3_6[2], v3_6[3], v3_6[4], v3_6[5], v3_6[6]);
        Vector6 v4 = v4_0 + new Vector6(v4_0[0].Sign * v4_0.Length, 0, 0, 0, 0, 0);

        v4 = ~v4;
        v4_0 -= (2 * (v4 * v4_0)) * v4;
        v4_1 -= (2 * (v4 * v4_1)) * v4;
        v4_2 -= (2 * (v4 * v4_2)) * v4;
        v4_3 -= (2 * (v4 * v4_3)) * v4;
        v4_4 -= (2 * (v4 * v4_4)) * v4;
        v4_5 -= (2 * (v4 * v4_5)) * v4;

        Vector5 v5_0 = (v4_1[1], v4_1[2], v4_1[3], v4_1[4], v4_1[5]);
        Vector5 v5_1 = (v4_2[1], v4_2[2], v4_2[3], v4_2[4], v4_2[5]);
        Vector5 v5_2 = (v4_3[1], v4_3[2], v4_3[3], v4_3[4], v4_3[5]);
        Vector5 v5_3 = (v4_4[1], v4_4[2], v4_4[3], v4_4[4], v4_4[5]);
        Vector5 v5_4 = (v4_5[1], v4_5[2], v4_5[3], v4_5[4], v4_5[5]);
        Vector5 v5 = v5_0 + new Vector5(v5_0[0].Sign * v5_0.Length, 0, 0, 0, 0);

        v5 = ~v5;
        v5_0 -= (2 * (v5 * v5_0)) * v5;
        v5_1 -= (2 * (v5 * v5_1)) * v5;
        v5_2 -= (2 * (v5 * v5_2)) * v5;
        v5_3 -= (2 * (v5 * v5_3)) * v5;
        v5_4 -= (2 * (v5 * v5_4)) * v5;

        Vector4 v6_0 = (v5_1[1], v5_1[2], v5_1[3], v5_1[4]);
        Vector4 v6_1 = (v5_2[1], v5_2[2], v5_2[3], v5_2[4]);
        Vector4 v6_2 = (v5_3[1], v5_3[2], v5_3[3], v5_3[4]);
        Vector4 v6_3 = (v5_4[1], v5_4[2], v5_4[3], v5_4[4]);
        Vector4 v6 = v6_0 + new Vector4(v6_0[0].Sign * v6_0.Length, 0, 0, 0);

        v6 = ~v6;
        v6_0 -= (2 * (v6 * v6_0)) * v6;
        v6_1 -= (2 * (v6 * v6_1)) * v6;
        v6_2 -= (2 * (v6 * v6_2)) * v6;
        v6_3 -= (2 * (v6 * v6_3)) * v6;

        Vector3 v7_0 = (v6_1[1], v6_1[2], v6_1[3]);
        Vector3 v7_1 = (v6_2[1], v6_2[2], v6_2[3]);
        Vector3 v7_2 = (v6_3[1], v6_3[2], v6_3[3]);
        Vector3 v7 = v7_0 + new Vector3(v7_0[0].Sign * v7_0.Length, 0, 0);

        v7 = ~v7;
        v7_0 -= (2 * (v7 * v7_0)) * v7;
        v7_1 -= (2 * (v7 * v7_1)) * v7;
        v7_2 -= (2 * (v7 * v7_2)) * v7;

        Vector2 v8_0 = (v7_1[1], v7_1[2]);
        Vector2 v8_1 = (v7_2[1], v7_2[2]);
        Vector2 v8 = v8_0 + new Vector2(v8_0[0].Sign * v8_0.Length, 0);

        v8 = ~v8;
        v8_0 -= (2 * (v8 * v8_0)) * v8;
        v8_1 -= (2 * (v8 * v8_1)) * v8;

        Matrix10 R = (
            v0_0[0], v0_1[0], v0_2[0], v0_3[0], v0_4[0], v0_5[0], v0_6[0], v0_7[0], v0_8[0], v0_9[0],
            0, v1_0[0], v1_1[0], v1_2[0], v1_3[0], v1_4[0], v1_5[0], v1_6[0], v1_7[0], v1_8[0],
            0, 0, v2_0[0], v2_1[0], v2_2[0], v2_3[0], v2_4[0], v2_5[0], v2_6[0], v2_7[0],
            0, 0, 0, v3_0[0], v3_1[0], v3_2[0], v3_3[0], v3_4[0], v3_5[0], v3_6[0],
            0, 0, 0, 0, v4_0[0], v4_1[0], v4_2[0], v4_3[0], v4_4[0], v4_5[0],
            0, 0, 0, 0, 0, v5_0[0], v5_1[0], v5_2[0], v5_3[0], v5_4[0],
            0, 0, 0, 0, 0, 0, v6_0[0], v6_1[0], v6_2[0], v6_3[0],
            0, 0, 0, 0, 0, 0, 0, v7_0[0], v7_1[0], v7_2[0],
            0, 0, 0, 0, 0, 0, 0, 0, v8_0[0], v8_1[0],
            0, 0, 0, 0, 0, 0, 0, 0, 0, v8_1[1]
        );
        Matrix10 Q = v0.HouseholderMatrix;

        Q *= Identity[1.., 1.., v1.HouseholderMatrix];
        Q *= Identity[2.., 2.., v2.HouseholderMatrix];
        Q *= Identity[3.., 3.., v3.HouseholderMatrix];
        Q *= Identity[4.., 4.., v4.HouseholderMatrix];
        Q *= Identity[5.., 5.., v5.HouseholderMatrix];
        Q *= Identity[6.., 6.., v6.HouseholderMatrix];
        Q *= Identity[7.., 7.., v7.HouseholderMatrix];
        Q *= Identity[8.., 8.., v8.HouseholderMatrix];

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (Matrix10 Q, Matrix10 R) QRDecomposeUnstable()
    {
        Matrix10 H0;
        Matrix10 A0 = this;
        Vector10 v0 = A0[0];

        v0 += new Vector10(A0[0, 0].Sign * v0.Length, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        H0 = v0.HouseholderMatrix;
        A0 = H0 * A0;

        Matrix9 H1;
        Matrix9 A1 = A0.Minors[0, 0];
        Vector9 v1 = A1[0];

        v1 += new Vector9(A1[0, 0].Sign * v1.Length, 0, 0, 0, 0, 0, 0, 0, 0);
        H1 = v1.HouseholderMatrix;
        A1 = H1 * A1;

        Matrix8 H2;
        Matrix8 A2 = A1.Minors[0, 0];
        Vector8 v2 = A2[0];

        v2 += new Vector8(A2[0, 0].Sign * v2.Length, 0, 0, 0, 0, 0, 0, 0);
        H2 = v2.HouseholderMatrix;
        A2 = H2 * A2;

        Matrix7 H3;
        Matrix7 A3 = A2.Minors[0, 0];
        Vector7 v3 = A3[0];

        v3 += new Vector7(A3[0, 0].Sign * v3.Length, 0, 0, 0, 0, 0, 0);
        H3 = v3.HouseholderMatrix;
        A3 = H3 * A3;

        Matrix6 H4;
        Matrix6 A4 = A3.Minors[0, 0];
        Vector6 v4 = A4[0];

        v4 += new Vector6(A4[0, 0].Sign * v4.Length, 0, 0, 0, 0, 0);
        H4 = v4.HouseholderMatrix;
        A4 = H4 * A4;

        Matrix5 H5;
        Matrix5 A5 = A4.Minors[0, 0];
        Vector5 v5 = A5[0];

        v5 += new Vector5(A5[0, 0].Sign * v5.Length, 0, 0, 0, 0);
        H5 = v5.HouseholderMatrix;
        A5 = H5 * A5;

        Matrix4 H6;
        Matrix4 A6 = A5.Minors[0, 0];
        Vector4 v6 = A6[0];

        v6 += new Vector4(A6[0, 0].Sign * v6.Length, 0, 0, 0);
        H6 = v6.HouseholderMatrix;
        A6 = H6 * A6;

        Matrix3 H7;
        Matrix3 A7 = A6.Minors[0, 0];
        Vector3 v7 = A7[0];

        v7 += new Vector3(A7[0, 0].Sign * v7.Length, 0, 0);
        H7 = v7.HouseholderMatrix;
        A7 = H7 * A7;

        Matrix2 H8;
        Matrix2 A8 = A7.Minors[0, 0];
        Vector2 v8 = A8[0];

        v8 += new Vector2(A8[0, 0].Sign * v8.Length, 0);
        H8 = v8.HouseholderMatrix;
        A8 = H8 * A8;

        Scalar A9 = -A8[1, 1]; // TODO : ????????
        Matrix10[] H = new Matrix10[10];

        H[0] = H0;
        H[1] = H[1][1.., 1.., H1];
        H[2] = H[2][2.., 2.., H2];
        H[3] = H[3][3.., 3.., H3];
        H[4] = H[4][4.., 4.., H4];
        H[5] = H[5][5.., 5.., H5];
        H[6] = H[6][6.., 6.., H6];
        H[7] = H[7][7.., 7.., H7];
        H[8] = H[8][8.., 8.., H8];
        H[9] = H[9][9, 9, -1];

        return (
            Q: H[9] * H[8] * H[7] * H[6] * H[5] * H[4] * H[3] * H[2] * H[1] * H[0] * A0,
            R: H[0].Transposed * H[1].Transposed * H[2].Transposed * H[3].Transposed * H[4].Transposed * H[5].Transposed * H[6].Transposed * H[7].Transposed * H[8].Transposed * H[9].Transposed
        );
    }

    public readonly (Matrix10 U, Matrix10 D) IwasawaDecompose()
    {
        Matrix10 ONB = OrthonormalBasis;
        Matrix10 D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly VectorSpace10 GetKrylovSpace(Vector10 vector) => VectorSpace10.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(Matrix10 o, Scalar tolerance) => _c0.Is(o._c0, tolerance) && _c1.Is(o._c1, tolerance) && _c2.Is(o._c2, tolerance) && _c3.Is(o._c3, tolerance) && _c4.Is(o._c4, tolerance) && _c5.Is(o._c5, tolerance) && _c6.Is(o._c6, tolerance) && _c7.Is(o._c7, tolerance) && _c8.Is(o._c8, tolerance) && _c9.Is(o._c9, tolerance);

    public readonly bool Is(Matrix10 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Matrix10 o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is Matrix10 v && Equals(v);

    public readonly bool Equals(Matrix10 other) => Is(other);

    public readonly int CompareTo(Matrix10 other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is Matrix10 m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(Matrix10)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 10x10-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The 10x10-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION

    /// <summary>
    /// Returns the upper-left 2x2 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>2x2 sub-matrix</returns>
    public readonly Matrix2 ToMatrix2() => (
        _c0[0], _c1[0],
        _c0[1], _c1[1]
    );

    /// <summary>
    /// Returns the upper-left 3x3 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>3x3 sub-matrix</returns>
    public readonly Matrix3 ToMatrix3() => (
        _c0[0], _c1[0], _c2[0],
        _c0[1], _c1[1], _c2[1],
        _c0[2], _c1[2], _c2[2]
    );

    /// <summary>
    /// Returns the upper-left 4x4 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>4x4 sub-matrix</returns>
    public readonly Matrix4 ToMatrix4() => (
        _c0[0], _c1[0], _c2[0], _c3[0],
        _c0[1], _c1[1], _c2[1], _c3[1],
        _c0[2], _c1[2], _c2[2], _c3[2],
        _c0[3], _c1[3], _c2[3], _c3[3]
    );

    /// <summary>
    /// Returns the upper-left 5x5 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>5x5 sub-matrix</returns>
    public readonly Matrix5 ToMatrix5() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4]
    );

    /// <summary>
    /// Returns the upper-left 6x6 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>6x6 sub-matrix</returns>
    public readonly Matrix6 ToMatrix6() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5]
    );

    /// <summary>
    /// Returns the upper-left 7x7 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>7x7 sub-matrix</returns>
    public readonly Matrix7 ToMatrix7() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6]
    );

    /// <summary>
    /// Returns the upper-left 8x8 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>8x8 sub-matrix</returns>
    public readonly Matrix8 ToMatrix8() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6],
        _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7]
    );

    /// <summary>
    /// Returns the upper-left 9x9 sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns>9x9 sub-matrix</returns>
    public readonly Matrix9 ToMatrix9() => (
        _c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c8[0],
        _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c8[1],
        _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c8[2],
        _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c8[3],
        _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c8[4],
        _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c8[5],
        _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c8[6],
        _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7], _c8[7],
        _c0[8], _c1[8], _c2[8], _c3[8], _c4[8], _c5[8], _c6[8], _c7[8], _c8[8]
    );

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<Vector10> ToIsomorphism()
    {
        Matrix10 copy = this;

        return new Function<Vector10>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<Vector10> GetEnumerator() => ((IEnumerable<Vector10>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(out Scalar x_0_0, out Scalar x_1_0, out Scalar x_2_0, out Scalar x_3_0, out Scalar x_4_0, out Scalar x_5_0, out Scalar x_6_0, out Scalar x_7_0, out Scalar x_8_0, out Scalar x_9_0, out Scalar x_0_1, out Scalar x_1_1, out Scalar x_2_1, out Scalar x_3_1, out Scalar x_4_1, out Scalar x_5_1, out Scalar x_6_1, out Scalar x_7_1, out Scalar x_8_1, out Scalar x_9_1, out Scalar x_0_2, out Scalar x_1_2, out Scalar x_2_2, out Scalar x_3_2, out Scalar x_4_2, out Scalar x_5_2, out Scalar x_6_2, out Scalar x_7_2, out Scalar x_8_2, out Scalar x_9_2, out Scalar x_0_3, out Scalar x_1_3, out Scalar x_2_3, out Scalar x_3_3, out Scalar x_4_3, out Scalar x_5_3, out Scalar x_6_3, out Scalar x_7_3, out Scalar x_8_3, out Scalar x_9_3, out Scalar x_0_4, out Scalar x_1_4, out Scalar x_2_4, out Scalar x_3_4, out Scalar x_4_4, out Scalar x_5_4, out Scalar x_6_4, out Scalar x_7_4, out Scalar x_8_4, out Scalar x_9_4, out Scalar x_0_5, out Scalar x_1_5, out Scalar x_2_5, out Scalar x_3_5, out Scalar x_4_5, out Scalar x_5_5, out Scalar x_6_5, out Scalar x_7_5, out Scalar x_8_5, out Scalar x_9_5, out Scalar x_0_6, out Scalar x_1_6, out Scalar x_2_6, out Scalar x_3_6, out Scalar x_4_6, out Scalar x_5_6, out Scalar x_6_6, out Scalar x_7_6, out Scalar x_8_6, out Scalar x_9_6, out Scalar x_0_7, out Scalar x_1_7, out Scalar x_2_7, out Scalar x_3_7, out Scalar x_4_7, out Scalar x_5_7, out Scalar x_6_7, out Scalar x_7_7, out Scalar x_8_7, out Scalar x_9_7, out Scalar x_0_8, out Scalar x_1_8, out Scalar x_2_8, out Scalar x_3_8, out Scalar x_4_8, out Scalar x_5_8, out Scalar x_6_8, out Scalar x_7_8, out Scalar x_8_8, out Scalar x_9_8, out Scalar x_0_9, out Scalar x_1_9, out Scalar x_2_9, out Scalar x_3_9, out Scalar x_4_9, out Scalar x_5_9, out Scalar x_6_9, out Scalar x_7_9, out Scalar x_8_9, out Scalar x_9_9) =>
        (x_0_0, x_1_0, x_2_0, x_3_0, x_4_0, x_5_0, x_6_0, x_7_0, x_8_0, x_9_0, x_0_1, x_1_1, x_2_1, x_3_1, x_4_1, x_5_1, x_6_1, x_7_1, x_8_1, x_9_1, x_0_2, x_1_2, x_2_2, x_3_2, x_4_2, x_5_2, x_6_2, x_7_2, x_8_2, x_9_2, x_0_3, x_1_3, x_2_3, x_3_3, x_4_3, x_5_3, x_6_3, x_7_3, x_8_3, x_9_3, x_0_4, x_1_4, x_2_4, x_3_4, x_4_4, x_5_4, x_6_4, x_7_4, x_8_4, x_9_4, x_0_5, x_1_5, x_2_5, x_3_5, x_4_5, x_5_5, x_6_5, x_7_5, x_8_5, x_9_5, x_0_6, x_1_6, x_2_6, x_3_6, x_4_6, x_5_6, x_6_6, x_7_6, x_8_6, x_9_6, x_0_7, x_1_7, x_2_7, x_3_7, x_4_7, x_5_7, x_6_7, x_7_7, x_8_7, x_9_7, x_0_8, x_1_8, x_2_8, x_3_8, x_4_8, x_5_8, x_6_8, x_7_8, x_8_8, x_9_8, x_0_9, x_1_9, x_2_9, x_3_9, x_4_9, x_5_9, x_6_9, x_7_9, x_8_9, x_9_9) = (_c0[0], _c1[0], _c2[0], _c3[0], _c4[0], _c5[0], _c6[0], _c7[0], _c8[0], _c9[0], _c0[1], _c1[1], _c2[1], _c3[1], _c4[1], _c5[1], _c6[1], _c7[1], _c8[1], _c9[1], _c0[2], _c1[2], _c2[2], _c3[2], _c4[2], _c5[2], _c6[2], _c7[2], _c8[2], _c9[2], _c0[3], _c1[3], _c2[3], _c3[3], _c4[3], _c5[3], _c6[3], _c7[3], _c8[3], _c9[3], _c0[4], _c1[4], _c2[4], _c3[4], _c4[4], _c5[4], _c6[4], _c7[4], _c8[4], _c9[4], _c0[5], _c1[5], _c2[5], _c3[5], _c4[5], _c5[5], _c6[5], _c7[5], _c8[5], _c9[5], _c0[6], _c1[6], _c2[6], _c3[6], _c4[6], _c5[6], _c6[6], _c7[6], _c8[6], _c9[6], _c0[7], _c1[7], _c2[7], _c3[7], _c4[7], _c5[7], _c6[7], _c7[7], _c8[7], _c9[7], _c0[8], _c1[8], _c2[8], _c3[8], _c4[8], _c5[8], _c6[8], _c7[8], _c8[8], _c9[8], _c0[9], _c1[9], _c2[9], _c3[9], _c4[9], _c5[9], _c6[9], _c7[9], _c8[9], _c9[9]);

    public readonly void Deconstruct(out Vector10 v0, out Vector10 v1, out Vector10 v2, out Vector10 v3, out Vector10 v4, out Vector10 v5, out Vector10 v6, out Vector10 v7, out Vector10 v8, out Vector10 v9) =>
        (v0, v1, v2, v3, v4, v5, v6, v7, v8, v9) = (_c0, _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9);

    public readonly object Clone() => new Matrix10(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly Vector10 GetColumn(int column) => column switch
    {
        0 => _c0,
        1 => _c1,
        2 => _c2,
        3 => _c3,
        4 => _c4,
        5 => _c5,
        6 => _c6,
        7 => _c7,
        8 => _c8,
        9 => _c9,
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 9.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix10 SetColumn(int column, in Vector10 vector)
    {
        if (column < 0 || column >= 10)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and 9.");

        Vector10[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..10);

    public readonly Matrix10 SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..10, values);

    public readonly Matrix10 SwapColumns(int src_col, int dst_col)
    {
        Vector10 col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly Matrix10 MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly Matrix10 AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly Matrix10 AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly Vector10 GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly Matrix10 SetRow(int row, in Vector10 vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..10, rows);

    public readonly Matrix10 SetRows(Range rows, in MatrixNM values) => SetRegion(0..10, rows, values);

    public readonly Matrix10 SwapRows(int src_row, int dst_row)
    {
        Vector10 row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly Matrix10 AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly Matrix10 AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly Matrix10 MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(10);
        int[] idx_r = rows.GetOffsets(10);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly Matrix10 SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(10);
        int[] idx_r = rows.GetOffsets(10);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new Matrix10(t);
    }

    /// <summary>
    /// Returns the matrix' 9x9-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns>9x9-minor</returns>
    public readonly Matrix9 GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector9(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();

    #endregion
    #region STATIC METHODS

    public static Matrix10 Add(Matrix10 m1, Matrix10 m2) => m1.Add(m2);

    public static Matrix10 Subtract(Matrix10 m1, Matrix10 m2) => m1.Subtract(m2);

    public static Matrix10 Multiply(Matrix10 m1, Matrix10 m2) => m1.Multiply(m2);

    public static Vector10 Multiply(Matrix10 m, Vector10 v) => m.Multiply(v);

    public static Matrix10 Multiply(Matrix10 m, Scalar s) => m.Multiply(s);

    public static Matrix10 Divide(Matrix10 m, Scalar s) => m.Divide(s);

    public static Matrix10 Exp(Matrix10 matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static Matrix10 Sin(Matrix10 matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static Matrix10 Cos(Matrix10 matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static Matrix10 CracovianProduct(in Matrix10 first, in Matrix10 second) => second.Transposed.Multiply(in second);

    public static Matrix10 HadamardProduct(in Matrix10 first, in Matrix10 second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(Matrix10 first, Matrix10 second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static Matrix10 SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[10, 10];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static Matrix10 SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static Matrix10 SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[10, 10];

        m[column, row] = value;

        return FromArray(m);
    }

    public static Matrix10 DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static Matrix10 DiagonalMatrix(in Vector10 diagonal) => DiagonalMatrix(diagonal[0], diagonal[1], diagonal[2], diagonal[3], diagonal[4], diagonal[5], diagonal[6], diagonal[7], diagonal[8], diagonal[9]);

    public static Matrix10 DiagonalMatrix(Scalar d0, Scalar d1, Scalar d2, Scalar d3, Scalar d4, Scalar d5, Scalar d6, Scalar d7, Scalar d8, Scalar d9) => (
        d0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, d1, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, d2, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, d3, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, d4, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, d5, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, d6, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, d7, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, d8, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, d9
    );
    
    public static Matrix10 KacMurdockSzegöMatrix(Scalar a) => new(
        1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5, a.Power(8) * .5, a.Power(9) * .5,
        a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5, a.Power(8) * .5,
        a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5, a.Power(7) * .5,
        a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5, a.Power(6) * .5,
        a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5, a.Power(5) * .5,
        a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5, a.Power(4) * .5,
        a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5, a.Power(3) * .5,
        a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5, a.Power(2) * .5,
        a.Power(8) * .5, a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1, a.Power(1) * .5,
        a.Power(9) * .5, a.Power(8) * .5, a.Power(7) * .5, a.Power(6) * .5, a.Power(5) * .5, a.Power(4) * .5, a.Power(3) * .5, a.Power(2) * .5, a.Power(1) * .5, 1
    );

    public static Matrix10 FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static Matrix10 FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= 10))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and 9.", nameof(column_indices));

        Vector10[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static Matrix10 FromArray(params Scalar[] coefficients) => new(coefficients);

    public static Matrix10 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Matrix10 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Matrix10 FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static Matrix10 FromArray(in Scalar[,] arr) => arr.GetLength(0) < 10 || arr.GetLength(1) < 10 ? throw new ArgumentException("The array must have a minimum size of 10x10.", nameof(arr)) : new Matrix10(arr);

    public static Matrix10 FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < 100 => throw new ArgumentException("The array must have a minimum length of 100.", nameof(arr)),
        _ => new Matrix10(
            arr[ 0], arr[ 1], arr[ 2], arr[ 3], arr[ 4], arr[ 5], arr[ 6], arr[ 7], arr[ 8], arr[ 9],
            arr[10], arr[11], arr[12], arr[13], arr[14], arr[15], arr[16], arr[17], arr[18], arr[19],
            arr[20], arr[21], arr[22], arr[23], arr[24], arr[25], arr[26], arr[27], arr[28], arr[29],
            arr[30], arr[31], arr[32], arr[33], arr[34], arr[35], arr[36], arr[37], arr[38], arr[39],
            arr[40], arr[41], arr[42], arr[43], arr[44], arr[45], arr[46], arr[47], arr[48], arr[49],
            arr[50], arr[51], arr[52], arr[53], arr[54], arr[55], arr[56], arr[57], arr[58], arr[59],
            arr[60], arr[61], arr[62], arr[63], arr[64], arr[65], arr[66], arr[67], arr[68], arr[69],
            arr[70], arr[71], arr[72], arr[73], arr[74], arr[75], arr[76], arr[77], arr[78], arr[79],
            arr[80], arr[81], arr[82], arr[83], arr[84], arr[85], arr[86], arr[87], arr[88], arr[89],
            arr[90], arr[91], arr[92], arr[93], arr[94], arr[95], arr[96], arr[97], arr[98], arr[99]
        )
    };

    public static Matrix10 FromRows(in Vector10[] arr) => FromColumns(arr).Transposed;

    public static Matrix10 FromColumns(in Vector10[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: 10 } => new Matrix10(
            arr[0][0], arr[1][0], arr[2][0], arr[3][0], arr[4][0], arr[5][0], arr[6][0], arr[7][0], arr[8][0], arr[9][0],
            arr[0][1], arr[1][1], arr[2][1], arr[3][1], arr[4][1], arr[5][1], arr[6][1], arr[7][1], arr[8][1], arr[9][1],
            arr[0][2], arr[1][2], arr[2][2], arr[3][2], arr[4][2], arr[5][2], arr[6][2], arr[7][2], arr[8][2], arr[9][2],
            arr[0][3], arr[1][3], arr[2][3], arr[3][3], arr[4][3], arr[5][3], arr[6][3], arr[7][3], arr[8][3], arr[9][3],
            arr[0][4], arr[1][4], arr[2][4], arr[3][4], arr[4][4], arr[5][4], arr[6][4], arr[7][4], arr[8][4], arr[9][4],
            arr[0][5], arr[1][5], arr[2][5], arr[3][5], arr[4][5], arr[5][5], arr[6][5], arr[7][5], arr[8][5], arr[9][5],
            arr[0][6], arr[1][6], arr[2][6], arr[3][6], arr[4][6], arr[5][6], arr[6][6], arr[7][6], arr[8][6], arr[9][6],
            arr[0][7], arr[1][7], arr[2][7], arr[3][7], arr[4][7], arr[5][7], arr[6][7], arr[7][7], arr[8][7], arr[9][7],
            arr[0][8], arr[1][8], arr[2][8], arr[3][8], arr[4][8], arr[5][8], arr[6][8], arr[7][8], arr[8][8], arr[9][8],
            arr[0][9], arr[1][9], arr[2][9], arr[3][9], arr[4][9], arr[5][9], arr[6][9], arr[7][9], arr[8][9], arr[9][9]
        ),
        _ => throw new ArgumentException("The array must have an exact length of 10.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Matrix10 m1, Matrix10 m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Matrix10 m1, Matrix10 m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static Matrix10 operator +(in Matrix10 m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static Matrix10 operator -(in Matrix10 m) => m.Negate();

    public static Matrix10 operator +(Scalar f, in Matrix10 m) => m.Add(f);

    public static Matrix10 operator +(in Matrix10 m, Scalar f) => m.Add(f);

    public static Matrix10 operator -(Scalar f, in Matrix10 m) => new Matrix10(f).Subtract(in m);

    public static Matrix10 operator -(in Matrix10 m, Scalar f) => m.Subtract(f);

    public static Matrix10 operator ++(in Matrix10 m) => m.Increment();

    public static Matrix10 operator --(in Matrix10 m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static Matrix10 operator +(in Matrix10 m1, in Matrix10 m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static Matrix10 operator -(in Matrix10 m1, in Matrix10 m2) => m1.Subtract(in m2);

    public static Vector10 operator *(in Matrix10 m, in Vector10 v) => m.Multiply(in v);

    public static Matrix10 operator *(in Matrix10 m1, in Matrix10 m2) => m1.Multiply(in m2);

    public static Matrix10 operator *(in Matrix10 m, Scalar f) => m.Multiply(f);

    public static Matrix10 operator *(Scalar f, in Matrix10 m) => m.Multiply(f);

    public static Matrix10 operator ^(in Matrix10 m, int c) => m.Power(c);

    public static Matrix10 operator ^(in Matrix10 m1, in Matrix10 m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static VectorSpace10 operator |(Matrix10 A, Vector10 b) => A.Solve(b);

    public static VectorSpace10 operator |(Matrix10 A, VectorSpace10 b) => A.Solve(b);

    public static Matrix10 operator /(Matrix10 m1, Matrix10 m2) => m1.Multiply(m2.Inverse);

    public static Matrix10 operator /(in Matrix10 m, Scalar f) => m.Divide(f);

    public static Matrix10 operator %(in Matrix10 m, Scalar f) => m.Modulus(f);

    public static implicit operator (Vector10 x0, Vector10 x1, Vector10 x2, Vector10 x3, Vector10 x4, Vector10 x5, Vector10 x6, Vector10 x7, Vector10 x8, Vector10 x9) (in Matrix10 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9]);

    public static implicit operator Matrix10((Vector10 x0, Vector10 x1, Vector10 x2, Vector10 x3, Vector10 x4, Vector10 x5, Vector10 x6, Vector10 x7, Vector10 x8, Vector10 x9) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8, t.x9);
/*
    public static explicit operator ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c7, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c8, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c9) (in Matrix10 m) => (m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9]);

    public static explicit operator Matrix10(in ((Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c0, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c1, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c2, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c3, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c4, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c5, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c6, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c7, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c8, (Scalar r0, Scalar r1, Scalar r2, Scalar r3, Scalar r4, Scalar r5, Scalar r6, Scalar r7, Scalar r8, Scalar r9) c9) t) => new(t.c0, t.c1, t.c2, t.c3, t.c4, t.c5, t.c6, t.c7, t.c8, t.c9);
*/
    public static implicit operator (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_8_0, Scalar x_9_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_8_1, Scalar x_9_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_8_2, Scalar x_9_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_8_3, Scalar x_9_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_8_4, Scalar x_9_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_8_5, Scalar x_9_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_8_6, Scalar x_9_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7, Scalar x_8_7, Scalar x_9_7, Scalar x_0_8, Scalar x_1_8, Scalar x_2_8, Scalar x_3_8, Scalar x_4_8, Scalar x_5_8, Scalar x_6_8, Scalar x_7_8, Scalar x_8_8, Scalar x_9_8, Scalar x_0_9, Scalar x_1_9, Scalar x_2_9, Scalar x_3_9, Scalar x_4_9, Scalar x_5_9, Scalar x_6_9, Scalar x_7_9, Scalar x_8_9, Scalar x_9_9) (in Matrix10 m) => (
        m._c0[0], m._c1[0], m._c2[0], m._c3[0], m._c4[0], m._c5[0], m._c6[0], m._c7[0], m._c8[0], m._c9[0],
        m._c0[1], m._c1[1], m._c2[1], m._c3[1], m._c4[1], m._c5[1], m._c6[1], m._c7[1], m._c8[1], m._c9[1],
        m._c0[2], m._c1[2], m._c2[2], m._c3[2], m._c4[2], m._c5[2], m._c6[2], m._c7[2], m._c8[2], m._c9[2],
        m._c0[3], m._c1[3], m._c2[3], m._c3[3], m._c4[3], m._c5[3], m._c6[3], m._c7[3], m._c8[3], m._c9[3],
        m._c0[4], m._c1[4], m._c2[4], m._c3[4], m._c4[4], m._c5[4], m._c6[4], m._c7[4], m._c8[4], m._c9[4],
        m._c0[5], m._c1[5], m._c2[5], m._c3[5], m._c4[5], m._c5[5], m._c6[5], m._c7[5], m._c8[5], m._c9[5],
        m._c0[6], m._c1[6], m._c2[6], m._c3[6], m._c4[6], m._c5[6], m._c6[6], m._c7[6], m._c8[6], m._c9[6],
        m._c0[7], m._c1[7], m._c2[7], m._c3[7], m._c4[7], m._c5[7], m._c6[7], m._c7[7], m._c8[7], m._c9[7],
        m._c0[8], m._c1[8], m._c2[8], m._c3[8], m._c4[8], m._c5[8], m._c6[8], m._c7[8], m._c8[8], m._c9[8],
        m._c0[9], m._c1[9], m._c2[9], m._c3[9], m._c4[9], m._c5[9], m._c6[9], m._c7[9], m._c8[9], m._c9[9]
    );

    public static implicit operator Matrix10(in (Scalar x_0_0, Scalar x_1_0, Scalar x_2_0, Scalar x_3_0, Scalar x_4_0, Scalar x_5_0, Scalar x_6_0, Scalar x_7_0, Scalar x_8_0, Scalar x_9_0, Scalar x_0_1, Scalar x_1_1, Scalar x_2_1, Scalar x_3_1, Scalar x_4_1, Scalar x_5_1, Scalar x_6_1, Scalar x_7_1, Scalar x_8_1, Scalar x_9_1, Scalar x_0_2, Scalar x_1_2, Scalar x_2_2, Scalar x_3_2, Scalar x_4_2, Scalar x_5_2, Scalar x_6_2, Scalar x_7_2, Scalar x_8_2, Scalar x_9_2, Scalar x_0_3, Scalar x_1_3, Scalar x_2_3, Scalar x_3_3, Scalar x_4_3, Scalar x_5_3, Scalar x_6_3, Scalar x_7_3, Scalar x_8_3, Scalar x_9_3, Scalar x_0_4, Scalar x_1_4, Scalar x_2_4, Scalar x_3_4, Scalar x_4_4, Scalar x_5_4, Scalar x_6_4, Scalar x_7_4, Scalar x_8_4, Scalar x_9_4, Scalar x_0_5, Scalar x_1_5, Scalar x_2_5, Scalar x_3_5, Scalar x_4_5, Scalar x_5_5, Scalar x_6_5, Scalar x_7_5, Scalar x_8_5, Scalar x_9_5, Scalar x_0_6, Scalar x_1_6, Scalar x_2_6, Scalar x_3_6, Scalar x_4_6, Scalar x_5_6, Scalar x_6_6, Scalar x_7_6, Scalar x_8_6, Scalar x_9_6, Scalar x_0_7, Scalar x_1_7, Scalar x_2_7, Scalar x_3_7, Scalar x_4_7, Scalar x_5_7, Scalar x_6_7, Scalar x_7_7, Scalar x_8_7, Scalar x_9_7, Scalar x_0_8, Scalar x_1_8, Scalar x_2_8, Scalar x_3_8, Scalar x_4_8, Scalar x_5_8, Scalar x_6_8, Scalar x_7_8, Scalar x_8_8, Scalar x_9_8, Scalar x_0_9, Scalar x_1_9, Scalar x_2_9, Scalar x_3_9, Scalar x_4_9, Scalar x_5_9, Scalar x_6_9, Scalar x_7_9, Scalar x_8_9, Scalar x_9_9) t) => new(
        t.x_0_0, t.x_1_0, t.x_2_0, t.x_3_0, t.x_4_0, t.x_5_0, t.x_6_0, t.x_7_0, t.x_8_0, t.x_9_0,
        t.x_0_1, t.x_1_1, t.x_2_1, t.x_3_1, t.x_4_1, t.x_5_1, t.x_6_1, t.x_7_1, t.x_8_1, t.x_9_1,
        t.x_0_2, t.x_1_2, t.x_2_2, t.x_3_2, t.x_4_2, t.x_5_2, t.x_6_2, t.x_7_2, t.x_8_2, t.x_9_2,
        t.x_0_3, t.x_1_3, t.x_2_3, t.x_3_3, t.x_4_3, t.x_5_3, t.x_6_3, t.x_7_3, t.x_8_3, t.x_9_3,
        t.x_0_4, t.x_1_4, t.x_2_4, t.x_3_4, t.x_4_4, t.x_5_4, t.x_6_4, t.x_7_4, t.x_8_4, t.x_9_4,
        t.x_0_5, t.x_1_5, t.x_2_5, t.x_3_5, t.x_4_5, t.x_5_5, t.x_6_5, t.x_7_5, t.x_8_5, t.x_9_5,
        t.x_0_6, t.x_1_6, t.x_2_6, t.x_3_6, t.x_4_6, t.x_5_6, t.x_6_6, t.x_7_6, t.x_8_6, t.x_9_6,
        t.x_0_7, t.x_1_7, t.x_2_7, t.x_3_7, t.x_4_7, t.x_5_7, t.x_6_7, t.x_7_7, t.x_8_7, t.x_9_7,
        t.x_0_8, t.x_1_8, t.x_2_8, t.x_3_8, t.x_4_8, t.x_5_8, t.x_6_8, t.x_7_8, t.x_8_8, t.x_9_8,
        t.x_0_9, t.x_1_9, t.x_2_9, t.x_3_9, t.x_4_9, t.x_5_9, t.x_6_9, t.x_7_9, t.x_8_9, t.x_9_9
    );

    public static explicit operator Matrix10(Scalar m) => new(m);

    public static implicit operator Matrix10(in Vector10[] arr) => new(arr);

    public static implicit operator Vector10[](in Matrix10 m) => m.Columns;

    public static explicit operator Scalar[](in Matrix10 m) => m.ToArray();

    public static implicit operator Matrix10(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in Matrix10 m) => m.Coefficients;

    public static implicit operator Matrix10(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in Matrix10 m) => new(m.Coefficients);

    public static explicit operator Matrix10(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in Matrix10 m) => CompressedStorageFormat<Scalar>.FromMatrix<Matrix10>(m);

    public static implicit operator Function<Vector10>(in Matrix10 m) => m.ToIsomorphism();

    #endregion

    public sealed class Matrix10EqualityComparer
        : IEqualityComparer<Matrix10>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Matrix10 x, Matrix10 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Matrix10 obj) => obj.GetHashCode();
    }
}

public static class Matrix10Extensions
{
    public static Matrix10 Sum(this IEnumerable<Matrix10> matrices) => Matrix10.Zero.Add(matrices.ToArray());

    public static Matrix10 Average(this IEnumerable<Matrix10> matrices)
    {
        Matrix10 mat = Matrix10.Zero;
        long count = 0;

        foreach (Matrix10 m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
#region MatrixNM (Extensions)

public partial class MatrixNM
{
    public Algebra<Scalar, Polynomial>.IMatrix Cast() => Size switch
    {
        (1, 1) => this[0, 0],
        // (_, 1) => this[0],
        (2, 2) => (Matrix2)this,
        (3, 3) => (Matrix3)this,
        (4, 4) => (Matrix4)this,
        (5, 5) => (Matrix5)this,
        (6, 6) => (Matrix6)this,
        (7, 7) => (Matrix7)this,
        (8, 8) => (Matrix8)this,
        (9, 9) => (Matrix9)this,
        (10, 10) => (Matrix10)this,
        _ => new MatrixNM(this) as Algebra<Scalar, Polynomial>.IMatrix
    };
}

public static class MatrixExtensions
{

    public static Matrix2 ToMatrix(this IEnumerable<Vector2> columns) => new(columns);

    public static Matrix3 ToMatrix(this IEnumerable<Vector3> columns) => new(columns);

    public static Matrix4 ToMatrix(this IEnumerable<Vector4> columns) => new(columns);

    public static Matrix5 ToMatrix(this IEnumerable<Vector5> columns) => new(columns);

    public static Matrix6 ToMatrix(this IEnumerable<Vector6> columns) => new(columns);

    public static Matrix7 ToMatrix(this IEnumerable<Vector7> columns) => new(columns);

    public static Matrix8 ToMatrix(this IEnumerable<Vector8> columns) => new(columns);

    public static Matrix9 ToMatrix(this IEnumerable<Vector9> columns) => new(columns);

    public static Matrix10 ToMatrix(this IEnumerable<Vector10> columns) => new(columns);
}

#endregion
