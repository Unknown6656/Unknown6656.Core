<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System;

using Unknown6656.Mathematics.Analysis;
using Unknown6656.Generics;
using Unknown6656.Common;
using Unknown6656.IO;

using static System.Math;

namespace Unknown6656.Mathematics.LinearAlgebra;

// TODO: schatten-p-norm

<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim < maxdim; ++dim)
    {
        string[] cols = r(0, dim).Select(i => "_c" + i).ToArray();
        string typename = "Matrix" + dim;
        string vecname = "Vector" + dim;
        string vecspace = "VectorSpace" + dim;
#>
#region <#=typename#>

/// <summary>
/// Represents a square <#=dim#>x<#=dim#> matrix.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct <#=typename#>
    : Algebra<Scalar>.IMatrix<<#=vecname#>, <#=typename#>>
    , Algebra<Scalar, Polynomial>.IMatrix<<#=typename#>, MatrixNM>
    , INative<<#=typename#>>
    , IEnumerable<<#=vecname#>>
    // , Function<<#=typename#>, <#=vecname#>>
    , IEnumerable<Scalar>
    , IComparable<<#=typename#>>
    , IComparable
    , IDisplayable
    , ICloneable
#if GENERIC_MATH
    , IIncrementOperators<<#=typename#>>
    , IModulusOperators<<#=typename#>, Scalar, <#=typename#>>
    , IMultiplyOperators<<#=typename#>, <#=typename#>, <#=typename#>>
    , IMultiplyOperators<Scalar, <#=typename#>, <#=typename#>>
    , IMultiplyOperators<<#=typename#>, Scalar, <#=typename#>>
    , IDivisionOperators<<#=typename#>, Scalar, <#=typename#>>
    , IMultiplyOperators<<#=vecname#>, <#=typename#>, <#=vecname#>>
    , IMultiplyOperators<<#=typename#>, <#=vecname#>, <#=vecname#>>
    , IDecrementOperators<<#=typename#>>
    , IAdditionOperators<<#=typename#>, <#=typename#>, <#=typename#>>
    , ISubtractionOperators<<#=typename#>, <#=typename#>, <#=typename#>>
    , IUnaryPlusOperators<<#=typename#>, <#=typename#>>
    , IUnaryNegationOperators<<#=typename#>, <#=typename#>>
    , IAdditiveIdentity<<#=typename#>, <#=typename#>>
    , IMultiplicativeIdentity<<#=typename#>, <#=typename#>>
    , IComparisonOperators<<#=typename#>, <#=typename#>>
    , IEqualityOperators<<#=typename#>, <#=typename#>>
#endif
{
    #region PRIVATE FIELDS

<#
        foreach (string col in cols)
            WriteLine($"    private readonly {vecname} {col};");
#>

    #endregion
    #region STATIC PROPERTIES

    public static (int Columns, int Rows) Dimensions { get; } = (<#=dim#>, <#=dim#>);

    /// <summary>
    /// The <#=dim#>x<#=dim#> zero matrix
    /// </summary>
    public static <#=typename#> Zero { get; } = new <#=typename#>(0);

    /// <summary>
    /// The <#=dim#>x<#=dim#> identity (unit) matrix
    /// </summary>
    public static <#=typename#> Identity { get; } = new(1);

    static <#=typename#> IRing<<#=typename#>>.One => Identity;

    /// <summary>
    /// The default compoonent-wise equality comparer for <see cref="<#=typename#>"/>.
    /// </summary>
    public static <#=typename#>EqualityComparer EqualityComparer { get; } = new <#=typename#>EqualityComparer();

    /// <summary>
    /// The raw memory size of the <see cref="<#=typename#>"/>-structure in bytes.
    /// </summary>
    public static int BinarySize => sizeof(<#=typename#>);

    #endregion
    #region INDEXERS

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly <#=vecname#> this[int column] => GetColumn(column);

    public readonly <#=vecname#> this[Index column] => this[column.GetOffset(<#=dim#>)];

    public readonly MatrixNM this[Range columns] => GetColumns(columns);

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly <#=typename#> this[int column, in <#=vecname#> value] => SetColumn(column, value);

    public readonly <#=typename#> this[Index column, in <#=vecname#> value] => this[column.GetOffset(<#=dim#>), value];

    public readonly <#=typename#> this[Range columns, in MatrixNM values] => SetColumns(columns, values);

    public readonly Scalar this[int column, int row] => this[column][row];

    public readonly Scalar this[Index column, Index row] => this[column][row];

    public readonly MatrixNM this[Range columns, Range rows] => GetRegion(columns, rows);

    public readonly <#=typename#> this[int column, int row, Scalar value]
    {
        get
        {
            if (row < 0 || row >= <#=dim#> || column < 0 || column >= <#=dim#>)
                throw new IndexOutOfRangeException($"The indices ({column}, {row}) is invalid: The indices must each be a value between (inclusive) zero and <#=dim-1#>.");

            Scalar[,] scalars = Coefficients;

            scalars[column, row] = value;

            return new <#=typename#>(scalars);
        }
    }

    public readonly <#=typename#> this[Index column, Index row, Scalar value] => this[column.GetOffset(<#=dim#>), row.GetOffset(<#=dim#>), value];

    public readonly <#=typename#> this[Range columns, Range rows, in MatrixNM values] => SetRegion(columns, rows, values);

    public readonly ReadOnlyIndexer<Range, Range, MatrixNM> Region => new ReadOnlyIndexer<Range, Range, MatrixNM>(GetRegion);

<#
        if (dim == 2)
        {
#>
    public readonly ReadOnlyIndexer<int, int, Scalar> Minors
    {
        get
        {
            Scalar[,] c = Coefficients;

            return new ReadOnlyIndexer<int, int, Scalar>((col, row) => (col, row) switch {
                (0, 0) => c[1, 1],
                (0, 1) => c[1, 0],
                (1, 0) => c[0, 1],
                (1, 1) => c[0, 0],
                _ => throw new ArgumentOutOfRangeException($"The indices ({col}, {row}) are invalid for this matrix: The indices must be values between (inclusive) zero and one.")
            });
        }
    }
<#
        }
        else
        {
#>
    public readonly ReadOnlyIndexer<int, int, Matrix<#=dim - 1#>> Minors => new ReadOnlyIndexer<int, int, Matrix<#=dim-1#>>(GetMinor);
<#
        }
#>

    #endregion
    #region INSTANCE PROPERTIES : BASIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly (int Columns, int Rows) Size => (<#=dim#>, <#=dim#>);

    /// <inheritdoc cref="Dimensions"/>
    readonly (int Columns, int Rows) Algebra<Scalar>.IComposite2D.Dimensions => Size;

    /// <summary>
    /// Returns a two-dimensional array of the matrix' coefficients. The first zero-based index addresses the columns, the second one the rows.
    /// </summary>
    public readonly Scalar[,] Coefficients => new Scalar[<#=dim#>, <#=dim#>]
    {
<#=string.Join(",\n", r(0, dim).Select(col => $"        {{ {string.Join(", ", r(0, dim).Select(row => $"_c{col}[{row}]"))} }}"))#>
    };

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never)]
    public readonly IEnumerable<Scalar> FlattenedCoefficients => new Scalar[<#=dim * dim#>] { <#=string.Join(", ", r(0, dim * dim).Select(i => $"_c{i % dim}[{i / dim}]"))#> };

    /// <summary>
    /// The matrix' main diagonal.
    /// </summary>
    public readonly <#=vecname#> MainDiagonal => (<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}[{i}]"))#>);

    /// <summary>
    /// The matrix' column vectors.
    /// </summary>
    public readonly <#=vecname#>[] Columns => new[] { <#=string.Join(", ", cols)#> };

    /// <summary>
    /// The matrix' row vectors.
    /// </summary>
    public readonly <#=vecname#>[] Rows => Transposed.Columns;

    /// <summary>
    /// The matrix' trace.
    /// </summary>
    public readonly Scalar Trace => MainDiagonal.CoefficientSum;

    public readonly Scalar FrobeniusNorm => Multiply(this).Trace;

    public readonly Scalar SpectralNorm => Transposed.Multiply(this).Eigenvalues.Max().Sqrt();

    public readonly Scalar ColumnSumNorm => Columns.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly Scalar RowSumNorm => Rows.Select(c => c.Select(Scalar.Abs).Sum()).Max();

    public readonly <#=typename#> AdditiveInverse => Negate();

    public readonly Scalar CoefficientSum => FlattenedCoefficients.Aggregate(Scalar.Zero, (a, b) => a.Add(b));

    public readonly Scalar CoefficientAvg => CoefficientSum.Divide(Dimensions.Rows * Dimensions.Columns);

    public readonly Scalar CoefficientMin => FlattenedCoefficients.Min();

    public readonly Scalar CoefficientMax => FlattenedCoefficients.Max();
<#
        if (dim > 3)
        {
            string tstr = string.Join(", ", r(2, dim - 2).Select(i => $"Matrix{i} Sub{i}"));
#>

    /// <summary>
    /// Returns a set of the first <#=dim-2#> principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly (<#=tstr#>) PrincipalSubmatrices => (<#=string.Join(", ", r(2, dim - 2).Select(i => $"ToMatrix{i}()"))#>);
<#
        }
#>

    #endregion
    #region INSTANCE PROPERTIES : TRANSFORMATIONS

    /// <summary>
    /// The transposed matrix.
    /// </summary>
    public readonly <#=typename#> Transposed => (
        <#=string.Join(",\n        ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"_c{y}[{x}]"))))#>
    );

    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never), EditorBrowsable(EditorBrowsableState.Never), Obsolete("Use the member 'Scalar <#=typename#>::Inverse' instead.")]
    public readonly <#=typename#> MultiplicativeInverse => Inverse;

    /// <summary>
    /// Returns the gaussian reduced matrix.
    /// </summary>
    public readonly <#=typename#> GaussianReduced => GetLinearIndependentForm();

    /// <summary>
    /// The matrix' orthonormal basis.
    /// </summary>
    public readonly <#=typename#> OrthonormalBasis
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            <#=vecname#>[] vs = Columns;

            for (int i = 0; i < <#=dim#>; ++i)
            {
                for (int j = 0; j < i; ++j)
                    vs[i] -= this[i].Dot(vs[j]) * vs[j];

                vs[i] = vs[i].Normalized;
            }

            return FromColumns(vs);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES : DETERMINANT + CHAR. POLYNOMIAL

    /// <summary>
    /// The matrix' determinant.
    /// </summary>
    public readonly Scalar Determinant => 
<#
    if (dim == 2)
        WriteLine("        _c0[0] * _c1[1] - _c1[0] * _c0[1];");
    else if (dim == 3)
    {
#>
        _c0[0] * (_c1[1] * _c2[2] - _c2[1] * _c1[2])
        - _c1[0] * (_c0[1] * _c2[2] - _c2[1] * _c0[2])
        + _c2[0] * (_c0[1] * _c1[2] - _c1[1] * _c0[2]);
<#
    }
    else
    {
#>
        <#=string.Join("\n        ", r(0, dim).Select(i => $"{((i % 2) == 0 ? '+' : '-')} GetMinor(0, {i}).Determinant"))#>;
<#
    }
#>

    public readonly <#=typename#> Inverse
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar det = Determinant is { IsZero: false } s ? s.Inverse : throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");
            <#=typename#> m = <#
    if (dim == 2)
    {
#>(
                    _c1[1], -_c0[1],
                -_c1[0],  _c0[0]
            );
<#
    }
    else if (dim == 3)
    {
#>(
            // TODO : verify the following code
                + (_c1[1] * _c2[2] - _c2[1] * _c1[2]),
                - (_c1[0] * _c2[2] - _c2[0] * _c1[2]),
                + (_c1[0] * _c2[1] - _c2[0] * _c1[1]),
                - (_c0[1] * _c2[2] - _c2[1] * _c0[2]),
                + (_c0[0] * _c2[2] - _c2[0] * _c0[2]),
                - (_c0[0] * _c2[1] - _c2[0] * _c0[1]),
                + (_c0[1] * _c1[2] - _c1[1] * _c0[2]),
                - (_c0[0] * _c1[2] - _c1[0] * _c0[2]),
                + (_c0[0] * _c1[1] - _c1[0] * _c0[1])
            );
<#
    }
    else if (dim == 4)
    {
#>Zero;
            var (m00, m10, m20, m30,
                 m01, m11, m21, m31,
                 m02, m12, m22, m32,
                 m03, m13, m23, m33) = this;

            // TODO : verify the following code
            m00 = (m12 * m23 * m31) - (m13 * m22 * m31) + (m13 * m21 * m32) - (m11 * m23 * m32) - (m12 * m21 * m33) + (m11 * m22 * m33);
            m01 = (m03 * m22 * m31) - (m02 * m23 * m31) - (m03 * m21 * m32) + (m01 * m23 * m32) + (m02 * m21 * m33) - (m01 * m22 * m33);
            m02 = (m02 * m13 * m31) - (m03 * m12 * m31) + (m03 * m11 * m32) - (m01 * m13 * m32) - (m02 * m11 * m33) + (m01 * m12 * m33);
            m03 = (m03 * m12 * m21) - (m02 * m13 * m21) - (m03 * m11 * m22) + (m01 * m13 * m22) + (m02 * m11 * m23) - (m01 * m12 * m23);
            m10 = (m13 * m22 * m30) - (m12 * m23 * m30) - (m13 * m20 * m32) + (m10 * m23 * m32) + (m12 * m20 * m33) - (m10 * m22 * m33);
            m11 = (m02 * m23 * m30) - (m03 * m22 * m30) + (m03 * m20 * m32) - (m00 * m23 * m32) - (m02 * m20 * m33) + (m00 * m22 * m33);
            m12 = (m03 * m12 * m30) - (m02 * m13 * m30) - (m03 * m10 * m32) + (m00 * m13 * m32) + (m02 * m10 * m33) - (m00 * m12 * m33);
            m13 = (m02 * m13 * m20) - (m03 * m12 * m20) + (m03 * m10 * m22) - (m00 * m13 * m22) - (m02 * m10 * m23) + (m00 * m12 * m23);
            m20 = (m11 * m23 * m30) - (m13 * m21 * m30) + (m13 * m20 * m31) - (m10 * m23 * m31) - (m11 * m20 * m33) + (m10 * m21 * m33);
            m21 = (m03 * m21 * m30) - (m01 * m23 * m30) - (m03 * m20 * m31) + (m00 * m23 * m31) + (m01 * m20 * m33) - (m00 * m21 * m33);
            m22 = (m01 * m13 * m30) - (m03 * m11 * m30) + (m03 * m10 * m31) - (m00 * m13 * m31) - (m01 * m10 * m33) + (m00 * m11 * m33);
            m23 = (m03 * m11 * m20) - (m01 * m13 * m20) - (m03 * m10 * m21) + (m00 * m13 * m21) + (m01 * m10 * m23) - (m00 * m11 * m23);
            m30 = (m12 * m21 * m30) - (m11 * m22 * m30) - (m12 * m20 * m31) + (m10 * m22 * m31) + (m11 * m20 * m32) - (m10 * m21 * m32);
            m31 = (m01 * m22 * m30) - (m02 * m21 * m30) + (m02 * m20 * m31) - (m00 * m22 * m31) - (m01 * m20 * m32) + (m00 * m21 * m32);
            m32 = (m02 * m11 * m30) - (m01 * m12 * m30) - (m02 * m10 * m31) + (m00 * m12 * m31) + (m01 * m10 * m32) - (m00 * m11 * m32);
            m33 = (m01 * m12 * m20) - (m02 * m11 * m20) + (m02 * m10 * m21) - (m00 * m12 * m21) - (m01 * m10 * m22) + (m00 * m11 * m22);

            m = (
                m00, m10, m20, m30,
                m01, m11, m21, m31,
                m02, m12, m22, m32,
                m03, m13, m23, m33
            );
<#
    }

    if (dim <= 4)
        WriteLine("            return m * det;");
    else
    {
#>this;
            // TODO : verify the following code
            <#=typename#> u = Identity;

            for (int i = 0; i < <#=dim#>; ++i)
            {
                int max = i;

                for (int j = i + 1; j < <#=dim#>; ++j)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                u = u.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                u = u.MultiplyRow(i, top);
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < <#=dim#>; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    u = u.AddRows(i, j, -f);
                }
            }

            for (int i = <#=dim#> - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        u = u.AddRows(i, row, -f);
                    }

            return u;
<#
    }
#>
        }
    }

<#
    if (dim == 2)
        WriteLine("    public readonly Polynomial CharacteristicPolynomial => new Polynomial(Determinant, - _c0[0] - _c1[1], 1);");
    else if (dim == 3)
    {
#>
    /*
             | a b c |                    | a-λ  b   c  |
        φ := | d e f |       CP_φ(λ) = det|  d  e-λ  f  | = (a-λ)[MINOR @ 0,0] - λ(gc + db) - gbf - gce - dbi + dhc
             | g h i |                    |  g   h  i-λ |
                                                          = - λ³
                                                            + λ²(a + e + i)
                                                            + λ(fh + cg + bd - ae - ai - ei)
                                                            + (-afh - ecg - ibd + aei + cdh + bfg)
    */
    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            var (a, b, c,
                    d, e, f,
                    g, h, i) = this;

            return new Polynomial(
                - a * f * h
                - e * c * g
                - i * b * d
                + a * e * i
                + c * d * h
                + b * f * g,
                + f * h
                + c * g
                + b * d
                - a * e
                - a * i
                - e * i,
                a + e + i,
                -1
            );
        }
    }
<#
    }
    else
    {
#>
    public readonly Polynomial CharacteristicPolynomial
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                ; // TODO: CP is linear product of the main diagonal and -λ

            throw new NotImplementedException();
        }
    }
<#
    }
#>

    /// <summary>
    /// The matrix' eigenvalues.
    /// </summary>
    // ∀λ∈Spec(A) : Ax = λx
    [Obsolete("Use '" + nameof(Eigenvalues) + "' instead.")]
    public readonly Scalar[] EigenvaluesUnstable =>
        (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).Distinct().ToArray();

    public readonly Scalar[] Eigenvalues => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvalues;

    public readonly <#=vecname#>[] Eigenvectors => EigenDecompose(Scalar.ComputationalEpsilon).Eigenvectors;

    public readonly Scalar[] Singularvalues => Transposed.Multiply(this).Eigenvalues.ToArray(Scalar.Sqrt);

    /// <summary>
    /// The rank of the matrix.
    /// </summary>
    public readonly int Rank => GetLinearIndependentForm().Rows.Count(c => c != <#=vecname#>.Zero);

    #endregion
    #region INSTANCE PROPERTIES : CHARACTERISTICS

    /// <summary>
    /// Indicates whether the matrix is equal to the <#=dim#>x<#=dim#> identity matrix.
    /// </summary>
    public readonly bool IsIdentity => Is(Identity);

    readonly bool IRing.IsOne => Is(Identity);

    /// <summary>
    /// Indicates whether the matrix is zero.
    /// </summary>
    public readonly bool IsZero => Is(Zero);

    /// <summary>
    /// Indicates whether the matrix has non-zero elements.
    /// </summary>
    public readonly bool IsNonZero => !IsZero;

    public readonly bool IsBinary => <#=string.Join(" && ", r(0, dim).Select(i => $"_c{i}.IsBinary"))#>;

    public readonly bool IsPositiveDefinite => GetPrincipalSubmatrices().All(m => m.Determinant.IsPositive);

    public readonly bool IsPositive => FlattenedCoefficients.All(c => c.IsPositive);

    public readonly bool IsNegative => FlattenedCoefficients.All(c => c.IsNegative);

    public readonly bool HasNaNs => FlattenedCoefficients.Any(c => c.IsNaN);

    public readonly bool HasNegatives => FlattenedCoefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => FlattenedCoefficients.Any(c => c.IsPositive);

    public readonly bool IsDiagonallyDominant
    {
        get
        {
            <#=vecname#>[] rows = Rows;

            for (int i = 0; i < <#=dim#>; ++i)
            {
                Scalar s = rows[i][i].AbsoluteValue;

                for (int j = 0; j < <#=dim#>; ++j)
                    if (j != i)
                        s -= rows[i][j].AbsoluteValue;

                if (s <= 0)
                    return false;
            }

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a diagonal matrix.
    /// </summary>
    public readonly bool IsDiagonal
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < <#=dim#>; ++c)
                for (int r = 0; r < <#=dim#>; ++r)
                    if ((r != c) && !coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is an upper (right) triangular matrix.
    /// </summary>
    public readonly bool IsUpperTriangular
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            Scalar[,] coeff = Coefficients;

            for (int c = 0; c < <#=dim#>; ++c)
                for (int r = c + 1; r < <#=dim#>; ++r)
                    if (!coeff[c, r].IsZero)
                        return false;

            return true;
        }
    }

    /// <summary>
    /// Indicates whether the matrix is a lower (left) triangular matrix.
    /// </summary>
    public readonly bool IsLowerTriangular => Transposed.IsUpperTriangular;

    /// <summary>
    /// Indicates whether the matrix is symmetric, meaning that the matrix is equal to its transposed variant.
    /// </summary>
    public readonly bool IsSymmetric => Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is a projection matrix.
    /// </summary>
    public readonly bool IsProjection => Is(Multiply(this));

    /// <summary>
    /// Indicates whether the current matrix 'A' is a conference matrix, meaning that AᵀA is a multiple of the identity matrix.
    /// </summary>
    public readonly bool IsConferenceMatrix
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        get
        {
            <#=typename#> ctc = Transposed * this;

            return (ctc - new <#=typename#>(ctc._c0[0])).IsZero;
        }
    }

    /// <summary>
    /// Indicated whether the matrix is involutory, meaning that the square of this matrix is equal to the identity matrix.
    /// </summary>
    public readonly bool IsInvolutory => (this * Inverse).IsIdentity;

    /// <summary>
    /// Indicates whether the matrix is stable in the sense of the Hurwitz criterium.
    /// </summary>
    public readonly bool IsHurwitzStable => _c0[0] > 0 &&
<#
        if (dim == 2)
            WriteLine("        Determinant > 0;");
        else
            WriteLine("        GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0);");
#>

    /// <summary>
    /// Indicates whether the matrix is orthogonal, meaning that its inverse is equal to its transposed variant.
    /// </summary>
    public readonly bool IsOrthogonal => Inverse.Is(Transposed);

    /// <summary>
    /// Indicates whether the matrix is skew symmetric, meaning that it is equal to its negated transposed.
    /// </summary>
    public readonly bool IsSkewSymmetric => Is(-Transposed);

    public readonly bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

    public readonly bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);

    /// <summary>
    /// Indicates whether the matrix is invertible, meaning that its determinant is non-zero and that a multiplicative inverse to this matrix exists.
    /// </summary>
    public readonly bool IsInvertible => Determinant.IsNonZero;

    /// <summary>
    /// Indicates whether the matrix is hollow, meaning that its main diagonal is zero.
    /// </summary>
    public readonly bool IsHollow => MainDiagonal.IsZero;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new <#=dim#>x<#=dim#>-matrix where all diagonal elements have the value <paramref name="scale"/>. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
    /// <param name="scale">Scalar factor</param>
    public <#=typename#>(Scalar scale)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => j == i ? "scale" : "0"))))#>)
    {
    }

    /// <summary>
    /// Creates a new <#=dim#>x<#=dim#>-matrix where all diagonal elements are set to the given values. All elements outside the main diagonal are set to <see cref="Scalar.Zero"/>.
    /// </summary>
<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"    /// <param name=\"diag_{i}\">The diagonal element at the position ({i}, {i}).</param>");
#>    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar diag_{i}"))#>)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => j == i ? $"diag_{i}" : "0"))))#>)
    {
    }

    public <#=typename#>(<#=string.Join(", ", r(0, dim * dim).Select(i => $"Scalar s_{i % dim}_{i / dim}"))#>)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => $"new {vecname}({string.Join(", ", r(0, dim).Select(j => $"s_{i}_{j}"))})"))#>)
    {
    }

    public <#=typename#>(Scalar[] values)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => $"values[{i * dim + j}]"))))#>)
    {
    }

    public <#=typename#>(Scalar[,] values)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => $"values[{j}, {i}]"))))#>)
    {
    }

    public <#=typename#>(Scalar[][] values)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => $"values[{j}][{i}]"))))#>)
    {
    }
<#
        for (int i = 2; i < maxdim; ++i)
        {
#>
    public <#=typename#>(in Matrix<#=i#> matrix)
        : this(<#
            if (i < dim)
                Write(string.Join(", ", r(0, dim).Select(c => c < i ? $"new {vecname}(matrix[{c}])" : vecname + ".Zero")));
            else if (i == dim)
                Write("matrix.Columns");
            else
                Write(string.Join(", ", r(0, dim).Select(c => $"new {vecname}(matrix[{c}])")));
#>)
    {
    }
<#
        }
#>

    public <#=typename#>(in MatrixNM matrix)
        : this(matrix.Coefficients)
    {
    }

    public <#=typename#>(<#=typename#>* matrix)
        : this(*matrix)
    {
    }

    public <#=typename#>(Scalar* values)
        : this(<#=string.Join(",\n               ", r(0, dim).Select(i => string.Join(", ", r(0, dim).Select(j => $"values[{i * dim + j}]"))))#>)
    {
    }

    public <#=typename#>(<#=vecname#>* columns)
        : this(<#=string.Join(", ", r(0, dim).Select(i => $"columns[{i}]"))#>)
    {
    }

    public <#=typename#>(IEnumerable<<#=vecname#>> columns)
        : this(columns.ToArray())
    {
    }

    public <#=typename#>(<#=vecname#>[] columns)
        : this(<#=string.Join(", ", r(0, dim).Select(i => $"columns[{i}]"))#>)
    {
    }

    public <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"{vecname} v{i}"))#>)
    {
<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"        {cols[i]} = v{i};");
#>
    }

    #endregion
    #region INSTANCE METHODS : BASIC ARITHMETIC OPERATORS

    /// <summary>
    /// Negates the current instance and returns the result without modifying the current instance.
    /// </summary>
    /// <returns>Negated object</returns>
    public readonly <#=typename#> Negate() => new(<#=string.Join(", ", r(0, dim).Select(i => $"-_c{i}"))#>);

    /// <summary>
    /// Adds the given object to the current instance and returns the addition's result without modifying the current instance.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Addition result</returns>
    public readonly <#=typename#> Add(in <#=typename#> second) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i} + second._c{i}"))#>);

    public readonly <#=typename#> Add(params <#=typename#>[] matrices) => matrices.Aggregate(this, Add);

    public readonly <#=typename#> Add(Scalar Scalar) => Add(new <#=typename#>(Scalar));

    public readonly <#=typename#> Increment() => Add(1);

    public readonly <#=typename#> Decrement() => Add(-1);

    public readonly <#=typename#> Subtract(in <#=typename#> second) => Add(second.Negate());

    public readonly <#=typename#> Subtract(params <#=typename#>[] matrices) => matrices.Aggregate(this, Subtract);

    public <#=typename#> Subtract(Scalar scalar) => Add(scalar.Negate());

<#
        if (dim > 2)
        {
#>
    public readonly Vector<#=dim-1#> HomogeneousMultiply(in Vector<#=dim-1#> second) => Multiply(second.ToHomogeneousCoordinates()).FromHomogeneousCoordinates();
<#
        }
#>

    /// <summary>
    /// Multiplies the given object with the current instance and returns the multiplication's result without modifying the current instance.
    /// <para/>
    /// This method is not to be confused the dot-product for matrices and vectors.
    /// </summary>
    /// <param name="second">Second operand</param>
    /// <returns>Multiplication result</returns>
    public readonly <#=typename#> Multiply(in <#=typename#> second)
    {
        <#=vecname#>[] A = Rows;
        <#=vecname#>[] B = second.Columns;
        Scalar[,] C = new Scalar[<#=dim#>, <#=dim#>];

        for (int r = 0; r < <#=dim#>; ++r)
            for (int c = 0; c < <#=dim#>; ++c)
                C[c, r] = A[r] * B[c];

        return new <#=typename#>(C);
    }

    public readonly <#=typename#> Multiply(params <#=typename#>[] matrices) => matrices.Aggregate(this, Multiply);

    /// <summary>
    /// Multiplies the given vector with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="vector">Vector</param>
    /// <returns>Multiplication result</returns>
    public readonly <#=vecname#> Multiply(in <#=vecname#> vector) => new(
        <#=string.Join(",\n        ", Enumerable.Range(0, dim).Select(i => string.Join(" + ", Enumerable.Range(0, dim).Select(j => $"_c{j}[{i}] * vector[{j}]"))))#>
    );

    /// <summary>
    /// Multiplies the given scalar factor with the current instance and returns the multiplication's result without modifying the current instance.
    /// </summary>
    /// <param name="factor">Scalar factor</param>
    /// <returns>Multiplication result</returns>
    public readonly <#=typename#> Multiply(Scalar factor) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i} * factor"))#>);

    public readonly <#=typename#> Multiply(params Scalar[] factors) => Multiply(factors.Aggregate(Scalar.One, Scalar.Multiply));

    public <#=typename#> Power(int e)
    {
        if (e < 0)
            throw new ArgumentOutOfRangeException(nameof(e));

        <#=typename#> r = Identity;
        <#=typename#> p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.Multiply(p);
            }
            else
            {
                e /= 2;
                p = p.Multiply(p);
            }

        return r;
    }

    public readonly <#=typename#> Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly <#=typename#> Modulus(Scalar factor) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i} % factor"))#>);

    public readonly <#=typename#> Sin(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        <#=typename#> result = this;
        <#=typename#> exponent = this;
        <#=typename#> squared = Multiply(this);
        <#=typename#> last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; i += 2)
        {
            result += factor * exponent;
            factor *= -i * (i + 1);
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly <#=typename#> Cos(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        <#=typename#> result = Identity;
        <#=typename#> exponent = this;
        <#=typename#> squared = Multiply(this);
        <#=typename#> last = result;
        Scalar factor = Scalar.One;

        for (int i = 2; i < settings.MaxIterationCount; i += 2)
        {
            factor *= -i * (i - 1);
            result += factor * exponent;
            exponent *= squared;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly <#=typename#> Exp(InfiniteSeriesSettings? settings = null)
    {
        settings ??= InfiniteSeriesSettings.Default;

        <#=typename#> result = Identity;
        <#=typename#> exponent = this;
        <#=typename#> last = result;
        Scalar factor = Scalar.One;

        for (int i = 1; i < settings.MaxIterationCount; ++i)
        {
            result += factor.Inverse * exponent;
            factor *= i;
            exponent *= this;

            if (result.DistanceTo(last, MatrixNorm.EucledianNorm) < settings.Epsilon)
                break;
            else
                last = result;
        }

        return result;
    }

    public readonly Scalar DistanceTo(<#=typename#> other, MatrixNorm norm) => Subtract(other).ComputeNorm(norm);

    public readonly Scalar ComputeNorm(MatrixNorm norm) => norm switch
    {
        MatrixNorm.EucledianNorm => FrobeniusNorm,
        MatrixNorm.L21_Norm => ComputePQNorm(1, 2),
        // MatrixNorm.MaxNorm => ,
        MatrixNorm.L1_Norm => ColumnSumNorm,
        MatrixNorm.Linf_Norm => RowSumNorm,
        MatrixNorm.L2_Norm => SpectralNorm,
    };

    public readonly Scalar ComputePNorm(Scalar p) => ToArray().Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputePQNorm(Scalar p, Scalar q) => Columns.Select(c => c.Select(v => v.Abs().Power(p)).Sum().Power(q / p)).Sum().Power(q.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixCondition(MatrixNorm norm) => ComputeNorm(norm) * MultiplicativeInverse.ComputeNorm(norm);

    public readonly Scalar ComputePMatrixCondition(Scalar p) => ComputePNorm(p) * MultiplicativeInverse.ComputePNorm(p);

    public readonly Scalar ComputePQMatrixCondition(Scalar p, Scalar q) => ComputePQNorm(p, q) * MultiplicativeInverse.ComputePQNorm(p, q);

    public readonly <#=typename#> ComponentwiseDivide(in <#=typename#> second) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.ComponentwiseDivide(second._c{i})"))#>);

    public readonly <#=typename#> ComponentwiseMultiply(in <#=typename#> second) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.ComponentwiseMultiply(second._c{i})"))#>);

    public readonly <#=typename#> ComponentwiseApply(Func<Scalar, Scalar> function) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.ComponentwiseApply(function)"))#>);

    public readonly <#=typename#> ComponentwiseApply(<#=typename#> second, Func<Scalar, Scalar, Scalar> function) =>
        new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.ComponentwiseApply(second._c{i}, function)"))#>);

    public readonly <#=typename#> ComponentwiseApply(<#=typename#> second, <#=typename#> third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.ComponentwiseApply(second._c{i}, third._c{i}, function)"))#>);

    public readonly <#=typename#> Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly <#=typename#> Clamp(Scalar low, Scalar high) => new(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i}.Clamp(low, high)"))#>);

    public readonly <#=typename#> LinearInterpolate(in <#=typename#> other, Scalar factor) => Multiply(1 - factor).Add(other.Multiply(factor));

    #endregion

    public readonly bool IsLinearDependant(in <#=typename#> other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < <#=dim#>; ++i)
            if (this[i].IsLinearDependant(other[i], out Scalar? f) && f.HasValue)
            {
                if (div.IsZero)
                    div = f.Value;
                else if (div.IsNot(f.Value))
                    return false;
            }

        factor = div;

        return true;
    }

    /// <summary>
    /// Returns a set of the first <#=dim-2#> principal submatrices.
    /// </summary>
    /// <returns>Set of principal submatrices</returns>
    public readonly Algebra<Scalar>.IMatrix[] GetPrincipalSubmatrices()
<#
        if (dim > 3)
        {
#>
    {
        (<#=string.Join(", ", r(2, dim - 2).Select(i => $"Matrix{i} Sub{i}"))#>) = PrincipalSubmatrices;

        return new Algebra<Scalar>.IMatrix[] { _c0[0], <#=string.Join(", ", r(2, dim - 2).Select(i => $"Sub{i}"))#> };
    }
<#
        }
        else if (dim == 3)
            WriteLine("        => new Algebra<Scalar>.IMatrix[] { _c0[0], ToMatrix2() };");
        else
            WriteLine("        => new Algebra<Scalar>.IMatrix[1] { _c0[0] };");
#>

    internal readonly <#=typename#> GetLinearIndependentForm()
    {
        <#=typename#> m = this;

        for (int row = 0; row < <#=dim#>; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < <#=dim#>; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < <#=dim#>; ++col)
                m = m.AddRows(row, col, -m[col, row]);
        }

        return m;
    }

    #region INSTANCE METHODS : SOLVERS

    /// <summary>
    /// Solves the current matrix for the given vector in a linear equation system
    /// </summary>
    /// <param name="vector"><#=vecname#></param>
    /// <returns>Solution</returns>
    public readonly <#=vecspace#> Solve(<#=vecname#> vector)
    {
        if (IsDiagonal)
            return vector.ComponentwiseDivide(MainDiagonal);
        else if (IsLowerTriangular)
        {
            <#=vecname#> x = vector;

            for (int i = 0; i < <#=dim#>; ++i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = i + 1; j < <#=dim#>; ++j)
                    x = x[j, vector[j] - (vector[i] * this[i, j])];
            }

            return x;
        }
        else if (IsUpperTriangular)
        {
            <#=vecname#> x = vector;

            for (int i = <#=dim - 1#>; i >= 0; --i)
            {
                x = x[i, vector[i] / this[i, i]];

                for (int j = 0; j < i; ++j)
                    x = x[j, vector[i] - (vector[i] * this[i, j])];
            }

            return x;
        }

        (<#=typename#> P, <#=typename#> L, <#=typename#> U) = PLUDecompose();
        <#=vecspace#> y = L.Solve(P * vector);

        return U.Solve(y);

        if (IsSymmetric && IsPositiveDefinite)
            return new <#=vecspace#>(SolveCG(vector));
    }

    public readonly <#=vecspace#> Solve(<#=vecspace#> vectorspace)
    {
        <#=vecspace#> result = <#=vecspace#>.Empty;

        if (!vectorspace.IsEmpty)
            foreach (<#=vecspace#> solution in vectorspace.Basis.Select(Solve))
                result = result.Add(solution);

        return result;
    }

    readonly bool Algebra<Scalar>.IMatrix<<#=vecname#>, <#=typename#>>.Solve(<#=vecname#> vector, out <#=vecname#> solution)
    {
        <#=vecspace#> space = Solve(vector);
        solution = <#=vecname#>.Zero;

        if (space.IsEmpty)
            return false;
        else
        {
            solution = space.Basis[0];

            return true;
        }
    }

    public readonly <#=vecname#> SolveCG(<#=vecname#> vector)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The conjugate gradient solver can only be applied defined to symmetric, positive definite matrices.");

        <#=vecname#> x = vector;
        <#=vecname#> r = vector - Multiply(vector);
        <#=vecname#> d = r;

        for (int i = 0; i < <#=dim#>; ++i)
        {
            if (r.Length.IsZero)
                break;

            <#=vecname#> ad = Multiply(d);
            Scalar α = r.SquaredNorm / (ad * d);
            <#=vecname#> rn = r - (α * ad);

            x += α * d;
            d = rn + (rn.SquaredNorm / r.SquaredNorm * d);
            r = rn;
        }

        return x;
    }

/*
    {
        <#=typename#> m = this;
        <#=vecname#> v = vector;

        for (int row = 0; row < <#=dim#>; ++row)
        {
            int max_column_idx = row;

            for (int col = row + 1; col < <#=dim#>; ++col)
                if (Abs(m[col, row]) > Abs(m[max_column_idx, row]))
                    max_column_idx = col;

            m = m.SwapRows(row, max_column_idx);
            v = v.SwapEntries(row, max_column_idx);

            Scalar factor = 1 / m[row, row];

            if (factor.IsInfinity)
                continue;

            v = v[row, v[row] * factor];
            m = m.MultiplyRow(row, factor)[row, row, 1];

            for (int col = row + 1; col < <#=dim#>; ++col)
            {
                Scalar f = m[col, row];

                m = m.AddRows(row, col, -f);
                v = v[col, v[col] - v[row] * f];
            }
        }

        for (int i = <#=dim-1#>; i > 0; --i) // i >= 0 ???
            if (!m[i, i].IsZero)
                for (int row = 0; row < i; ++row)
                {
                    Scalar f = m[i, row];

                    m = m.AddRows(i, row, -f);
                    v = v[row, v[row] - v[i] * f];
                }

        return v;
    }
*/

    #endregion
    #region INSTANCE METHODS : DECOMPOSITIONS

    public readonly (<#=vecname#>[] Eigenvectors, Scalar[] Eigenvalues) EigenDecompose(Scalar tolerance)
    {
        (<#=vecname#> vec, Scalar val)[] pairs = GetEigenpairs(tolerance);
        <#=vecname#>[] vectors = pairs.Select(p => p.vec).Distinct(<#=vecname#>.EqualityComparer).ToArray();
        Scalar[] values = pairs.Select(p => p.val).Distinct(Scalar.EqualityComparer).OrderByDescending(LINQ.id).ToArray();

        return (vectors, values);
    }

    public readonly (<#=vecname#> Eigenvector, Scalar Eigenvalue)[] GetEigenpairs(Scalar tolerance)
    {
        if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
            return Identity.Columns.Zip(MainDiagonal).ToArray();

        (<#=vecname#> vec, Scalar val)[] pairs = new (<#=vecname#>, Scalar)[<#=dim#>];

        pairs[^1] = DoInverseVectoriteration(0, tolerance);

        for (int i = 2; i >= <#=dim#>; --i)
            pairs[^i] = DoInverseVectoriteration(pairs[^(i - 1)].val, tolerance);

        return pairs;
    }

    private readonly (<#=vecname#> Eigenvector, Scalar Eigenvalue) DoInverseVectoriteration(Scalar offset, Scalar tolerance)
    {
        <#=vecname#> v_old = default;
        <#=vecname#> v_new = <#=vecname#>.GetRandomCartesianUnitVector();
        <#=vecname#> v_init = v_new;
        <#=typename#> A = (this - (offset * Identity)).Inverse;

        while ((v_old - v_new).Length > tolerance)
            (v_old, v_new) = (v_new, A * v_new);

        v_new = ~v_new;
        v_old = ~v_old;

        <#=vecname#> w = default;

        while ((w * v_init).IsZero)
            w = <#=vecname#>.GetRandomCartesianUnitVector();

        Scalar λ = (v_new * w) / (v_old * w);

        return (v_new, 1 / (λ - offset));
    }

    public readonly <#=vecspace#> GetEigenspace(Scalar eigenvalue) => <#=vecspace#>.FromVectors(Subtract(DiagonalMatrix(eigenvalue)).Columns.Select(v => v.Normalized)); // TODO : fix this shite

    public readonly int GetAlgebraicMulticiplity(Scalar eigenvalue) => GetEigenspace(eigenvalue).Dimension;

    /// <summary>
    /// Computes the matrices P, S, and Pn, such that the equation Pn*A*P=S is fulfilled (with A being the current matrix).
    /// </summary>
    /// <param name="tolerance"></param>
    /// <returns>The matrices P, S, and Pn</returns>
    public readonly (<#=typename#> P, <#=typename#> S, <#=typename#> Pn) Diagonalize(Scalar tolerance)
    {
        (<#=vecname#> v, Scalar λ)[] pairs = GetEigenpairs(tolerance);
        <#=typename#> P = new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"pairs[{i}].v"))#>);
        <#=typename#> S = new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"pairs[{i}].λ"))#>);

        return (P, S, P.MultiplicativeInverse);
    }

    /// <summary>
    /// Decomposes the current matrix (in a non-destructive fashion) into three matrices: A permutation-matrix P, an upper-triangular matrix U, and a lower-triangular matrix L.
    /// </summary>
    /// <returns>A tuple consisting of the permutation-matrix P, the upper-triangular matrix U, and the lower-triangular matrix L.</returns>
    public readonly (<#=typename#> P, <#=typename#> L, <#=typename#> U) PLUDecompose()
    {
        int[] perm = { <#=string.Join(", ", r(0, dim))#> };
        <#=typename#> U = Identity;
        <#=typename#> L = this;

        for (int i = 0; i < <#=dim - 1#>; ++i)
        {
            <#=vecname#> column = U[i];
            Scalar lead = column[i];

            for (int j = i + 1; j < <#=dim#>; ++j)
            {
                Scalar v = Scalar.Abs(column[j]);

                if (v > lead)
                {
                    lead = v;
                    perm[i] = j;
                }
            }

            if (perm[i] != i)
            {
                U = U.SwapRows(i, perm[i]);
                perm[perm[i]] = i;
            }

            column = U[i];
            lead = column[i];

            for (int j = i + 1; j < <#=dim#>; ++j)
            {
                Scalar fac = column[j] / lead;

                L = L[i, j, fac];
                U = U.AddRows(j, i, -fac);
            }
        }

        return (FromRowPermutation(perm), L, U);
    }

<#
        var schur1 = $"Matrix{dim / 2}".Replace("Matrix1", "Scalar");
        var schur2 = $"Matrix{dim - dim / 2}".Replace("Matrix1", "Scalar");
#>
    public readonly (<#=schur1#> A, <#=schur2#> C) SchurComplement()
    {
        (MatrixNM A, MatrixNM C) = SchurComplement(<#=dim / 2#>);

        return ((<#=schur1#>)A, (<#=schur2#>)C);
    }

    public readonly (MatrixNM A, MatrixNM C) SchurComplement(int size)
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The Schur-complement is only defined for symmetric, positive definite matrices.");
        else if (size < 1 || size >= <#=dim#>)
            throw new ArgumentOutOfRangeException("The size must be a positive integer value between 1 and <#=dim#>.", nameof(size));

        MatrixNM A = this[0..size, 0..size];
        MatrixNM B = this[size.., 0..size];
        MatrixNM C = this[size.., size..];

        return (
            A - B * C.Inverse * B.Transposed,
            C - B.Transposed * A.Inverse * B
        );
    }

    /// <summary>
    /// Decomposes the current matrix instance into a lower triangular matrix 'L'. The product of L with its transposed results in the current matrix.
    /// </summary>
    public readonly <#=typename#> CholeskyDecompose()
    {
        if (!IsSymmetric && !IsPositiveDefinite)
            throw new InvalidOperationException("The cholesky decomposition is only defined for symmetric, positive definite matrices.");

<#
        if (dim == 2)
        {
#>
        var (a, _, b, c) = this;
        Scalar u = a.Sqrt();

        return (
            u, 0,
            (c - u).Sqrt(), b / u
        );
<#
        }
        else if (dim == 3)
        {
#>
        var (
            a, _, _,
            b, c, _,
            d, e, f
        ) = this;
        Scalar u = a.Sqrt();
        Scalar v = b / u;
        Scalar x = d / u;
        Scalar w = (c - u).Sqrt();

        return (
            u, 0, 0,
            v, w, 0,
            x, (e - v * w) / x, (f - w).Sqrt()
        );
<#
        }
        else
        {
#>
        // TODO : cholesky decomposition
        /*
        <#=typename#> res = default;

        for (int i = 0; i < res.Size; ++i)
            for (int j = i; j >= 0; --j)
                res = i == j ? res[i, i, 1] : res[j, i, 2];

        // res[i, i] = Math.Sqrt(a[i, i] + );

        return res;
        */
        throw new NotImplementedException();
<#
        }
#>
    }

    public readonly (<#=typename#> Q, <#=typename#> R) QRDecompose()
    {
        <#=typename#> A = this;
<#
        for (int k = 0; k < dim - 1; ++k)
        {
            string mat = "Matrix" + (dim - k);
            string vec = "Vector" + (dim - k);
            string mat_n = "A" + k;
            string col_n = mat_n.ToLower();
            string vec_n = "v" + k;
            string[] a_vec_n = r(0, dim - k).Select(i => $"{vec_n}_{i}").ToArray();

            if (k == 0)
            {
#>
        (<#=string.Join(", ", a_vec_n.Select(v => $"{vec} {v}"))#>) = A;
<#
            }
            else
                for (int j = 0; j < dim - k; ++j)
                {
#>
        <#=vec#> <#=a_vec_n[j]#> = (<#=string.Join(", ", r(1, dim - k).Select(l => $"v{k-1}_{j+1}[{l}]"))#>);
<#
                }
#>
        <#=vec#> <#=vec_n#> = <#=a_vec_n[0]#> + new Vector<#=dim-k#>(<#=a_vec_n[0]#>[0].Sign * <#=a_vec_n[0]#>.Length, <#=string.Join(", ", Enumerable.Repeat(0, dim - k - 1))#>);

        <#=vec_n#> = ~<#=vec_n#>;
<#
            for (int j = 0; j < dim - k; ++j)
            {
#>
        <#=a_vec_n[j]#> -= (2 * (<#=vec_n#> * <#=a_vec_n[j]#>)) * <#=vec_n#>;
<#
            }

            Write("\r\n");
        }
#>
        <#=typename#> R = (
<#=string.Join(",\n", r(0, dim - 1).Select(i => "            " + string.Join(", ", r(0, dim).Select(j => i > j ? "0" : $"v{i}_{j-i}[0]"))))#>,
            <#=string.Join(", ", r(0, dim).Select(i => i < dim - 1 ? "0" : $"v{dim - 2}_1[1]"))#>
        );
        <#=typename#> Q = v0.HouseholderMatrix;

<#
        for (int k = 1; k < dim - 1; ++k)
            WriteLine($"        Q *= Identity[{k}.., {k}.., v{k}.HouseholderMatrix];");
#>

        return (Q.Transposed, R);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining), Obsolete("Use '" + nameof(QRDecompose) + "' instead.")]
    public readonly (<#=typename#> Q, <#=typename#> R) QRDecomposeUnstable()
    {
<#
        for (int k = 0; k < dim - 1; ++k)
        {
            string mat = "Matrix" + (dim - k);
            string vec = "Vector" + (dim - k);
            string mat_n = "A" + k;
            string col_n = mat_n.ToLower();
            string vec_n = "v" + k;
#>
        <#=mat#> H<#=k#>;
        <#=mat#> <#=mat_n#> = <#=k == 0 ? "this" : $"A{k - 1}.Minors[0, 0]"#>;
        <#=vec#> <#=vec_n#> = <#=mat_n#>[0];

        <#=vec_n#> += new Vector<#=dim-k#>(<#=mat_n#>[0, 0].Sign * <#=vec_n#>.Length, <#=string.Join(", ", Enumerable.Repeat(0, dim - k - 1))#>);
        H<#=k#> = <#=vec_n#>.HouseholderMatrix;
        <#=mat_n#> = H<#=k#> * <#=mat_n#>;

<#
        }
#>
        Scalar A<#=dim - 1#> = -A<#=dim - 2#>[1, 1]; // TODO : ????????
        <#=typename#>[] H = new <#=typename#>[<#=dim#>];

        H[0] = H0;
<#
        for (int k = 1; k < dim - 1; ++k)
            WriteLine($"        H[{k}] = H[{k}][{k}.., {k}.., H{k}];");
#>
        H[<#=dim - 1#>] = H[<#=dim - 1#>][<#=dim - 1#>, <#=dim - 1#>, -1];

        return (
            Q: <#=string.Join(" * ", r(0, dim).Select(i => $"H[{dim - 1 - i}]"))#> * A0,
            R: <#=string.Join(" * ", r(0, dim).Select(i => $"H[{i}].Transposed"))#>
        );
    }

    public readonly (<#=typename#> U, <#=typename#> D) IwasawaDecompose()
    {
        <#=typename#> ONB = OrthonormalBasis;
        <#=typename#> D = ONB.Transposed.Multiply(this);

        return (ONB, D);
    }

    #endregion

    public readonly <#=vecspace#> GetKrylovSpace(<#=vecname#> vector) => <#=vecspace#>.KrylovSpace(vector, this);

    #region INSTANCE METHODS : COMPARISONS

    public readonly bool Is(<#=typename#> o, Scalar tolerance) => <#=string.Join(" && ", cols.Select(s => $"{s}.Is(o.{s}, tolerance)"))#>;

    public readonly bool Is(<#=typename#> o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(<#=typename#> o) => !Is(o);

    public readonly override bool Equals(object? obj) => obj is <#=typename#> v && Equals(v);

    public readonly bool Equals(<#=typename#> other) => Is(other);

    public readonly int CompareTo(<#=typename#> other) => Is(other) ? 0 : throw new NotImplementedException();

    public readonly int CompareTo(object? other) => other is <#=typename#> m ? CompareTo(m) : throw new ArgumentException($"The given value must be a Matrix of the type '{typeof(<#=typename#>)}'.", nameof(other));

    public readonly override int GetHashCode() => LINQ.GetHashCode(Columns);

    #endregion
    #region INSTANCE METHODS : TO_STRING

    public readonly string ToString(bool @short) => @short ? ToShortString() : ToString();

    public readonly string ToString(string? format) => ToString(format, null);
    
    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? provider) =>
        Rows.Select(c => $"| {c.ToArray().Select(f => f.ToString(format, provider)).StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The <#=dim#>x<#=dim#>-matrix' string representation
    /// </summary>
    /// <returns>String representation</returns>
    public readonly override string ToString() => Rows.Select(c => $"| {c.ToArray().Select(f => $"{f,22:F16}").StringJoin(", ")} |").StringJoinLines();

    /// <summary>
    /// The <#=dim#>x<#=dim#>-matrix' short string representation
    /// </summary>
    /// <returns>Short string representation</returns>
    public readonly string ToShortString() => (from col in Columns
                                               let strings = (from entry in col.ToArray().Select(f => f.ToShortString("F25").PadRight(27).PadLeft(34))
                                                              let end = entry.Reverse().TakeWhile(c => c == '0' || c == ' ').Count()
                                                              select new
                                                              {
                                                                  entry,
                                                                  front = entry.TakeWhile(c => c == ' ').Count(),
                                                                  back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                              }).ToArray()
                                               let f = strings.Min(c => c.front)
                                               let b = strings.Min(c => c.back)
                                               select strings.Select(e =>
                                               {
                                                   string s = e.entry!.Substring(f, e.entry.Length - f - b);

                                                   return string.IsNullOrWhiteSpace(s) || s == "0" ? "0" : s;
                                               }).ToArray())
                                              .Transpose()
                                              .Select(r => $"| {r.StringJoin(", ")} |")
                                              .StringJoinLines();

    #endregion
    #region INSTANCE METHODS : CONVERTING / CASTING / DECONSTRUCTION
<#
        for (int i = 2; i <= dim - 1; ++i)
        {
#>

    /// <summary>
    /// Returns the upper-left <#=i#>x<#=i#> sub-matrix by copying all respective coefficients.
    /// </summary>
    /// <returns><#=i#>x<#=i#> sub-matrix</returns>
    public readonly Matrix<#=i#> ToMatrix<#=i#>() => (
<#
            for (int j = 0; j < i; ++j)
                WriteLine("        " + string.Join(", ", r(0, i).Select(k => $"_c{k}[{j}]")) + (j < i - 1 ? "," : ""));
#>
    );
<#
        }

        if (dim < maxdim - 1)
        {
#>

    /// <summary>
    /// Creates the homogeneous <#=dim+1#>x<#=dim+1#> transformation matrix from the current matrix.
    /// </summary>
    /// <returns>Homogeneous <#=dim+1#>x<#=dim+1#> transformation matrix.</returns>
    public readonly Matrix<#=dim+1#> ToHomogeneousTransformationMatrix() => (
<#
            for (int i = 0; i < dim; ++i)
                WriteLine($"        _c{i}.ToHomogeneousCoordinates(),");
#>
        Vector<#=dim+1#>.UnitVectors[<#=dim#>]
    );
<#
        }
#>

    /// <summary>
    /// Returns the matrix as a flat array of matrix elements in column major format.
    /// </summary>
    /// <returns>Column major representation of the matrix</returns>
    public readonly Scalar[] ToArray() => FlattenedCoefficients.ToArray();

    /// <summary>
    /// Returns the isomorphism associated with the current matrix.
    /// This isomorphism is a simple multiplication of a given vector with the current matrix.
    /// </summary>
    /// <returns>The isomorphism.</returns>
    public readonly Function<<#=vecname#>> ToIsomorphism()
    {
        <#=typename#> copy = this;

        return new Function<<#=vecname#>>(v => copy.Multiply(v));
    }

    public readonly CompressedStorageFormat<Scalar> ToCompressedStorageFormat() => CompressedStorageFormat<Scalar>.FromMatrix(this);

    public readonly T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public readonly void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly IEnumerator<<#=vecname#>> GetEnumerator() => ((IEnumerable<<#=vecname#>>)Columns).GetEnumerator();

    readonly IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly void Deconstruct(<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"out Scalar x_{j}_{i}")))#>) =>
        (<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"x_{j}_{i}")))#>) = (<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"_c{j}[{i}]")))#>);

    public readonly void Deconstruct(<#=string.Join(", ", r(0, dim).Select(i => $"out {vecname} v{i}"))#>) =>
        (<#=string.Join(", ", r(0, dim).Select(i => "v" + i))#>) = (<#=string.Join(", ", r(0, dim).Select(i => "_c" + i))#>);

    public readonly object Clone() => new <#=typename#>(this);

    #endregion
    #region INSTANCE METHODS : SET/GET COLUMNS/ROWS/REGIONS/VALUES

    /// <summary>
    /// Gets the matrix' column vector at the given index.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <returns>Column vector</returns>
    public readonly <#=vecname#> GetColumn(int column) => column switch
    {
<#=string.Join("\n", r(0, dim).Select(i => $"        {i} => {cols[i]},"))#>
        _ => throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and <#=dim-1#>.")
    };

    /// <summary>
    /// Sets the matrix' column vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="column">Column vector index (zero-based)</param>
    /// <param name="vector">New column vector</param>
    /// <returns>Modified matrix</returns>
    public readonly <#=typename#> SetColumn(int column, in <#=vecname#> vector)
    {
        if (column < 0 || column >= <#=dim#>)
            throw new IndexOutOfRangeException($"The index {column} is invalid: It must be a value between (inclusive) zero and <#=dim-1#>.");

        <#=vecname#>[] cols = Columns;

        cols[column] = vector;

        return FromColumns(cols);
    }

    public readonly MatrixNM GetColumns(Range columns) => GetRegion(columns, 0..<#=dim#>);

    public readonly <#=typename#> SetColumns(Range columns, in MatrixNM values) => SetRegion(columns, 0..<#=dim#>, values);

    public readonly <#=typename#> SwapColumns(int src_col, int dst_col)
    {
        <#=vecname#> col = GetColumn(src_col);

        return SetColumn(src_col, GetColumn(dst_col))
                .SetColumn(dst_col, col);
    }

    public readonly <#=typename#> MultiplyColumn(int col, Scalar factor) => SetColumn(col, GetColumn(col).Multiply(factor));

    public readonly <#=typename#> AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

    public readonly <#=typename#> AddColumns(int src_col, int dst_col, Scalar factor) => SetColumn(dst_col, GetColumn(src_col).Multiply(factor).Add(GetColumn(dst_col)));

    /// <summary>
    /// Gets the matrix' row vector at the given index.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <returns>Row vector</returns>
    public readonly <#=vecname#> GetRow(int row) => Transposed.GetColumn(row);

    /// <summary>
    /// Sets the matrix' row vector at the given index and returns the modified matrix.
    /// </summary>
    /// <param name="row">Row vector index (zero-based)</param>
    /// <param name="vector">New row vector</param>
    /// <returns>Modified matrix</returns>
    public readonly <#=typename#> SetRow(int row, in <#=vecname#> vector) => Transposed.SetColumn(row, vector).Transposed;

    public readonly MatrixNM GetRows(Range rows) => GetRegion(0..<#=dim#>, rows);

    public readonly <#=typename#> SetRows(Range rows, in MatrixNM values) => SetRegion(0..<#=dim#>, rows, values);

    public readonly <#=typename#> SwapRows(int src_row, int dst_row)
    {
        <#=vecname#> row = GetRow(src_row);

        return SetRow(src_row, GetRow(dst_row))
                .SetRow(dst_row, row);
    }

    public readonly <#=typename#> AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

    public readonly <#=typename#> AddRows(int src_row, int dst_row, Scalar factor) => SetRow(dst_row, GetRow(src_row).Multiply(factor).Add(GetRow(dst_row)));

    public readonly <#=typename#> MultiplyRow(int row, Scalar factor) => SetRow(row, GetRow(row).Multiply(factor));

    public readonly MatrixNM GetRegion(Range columns, Range rows)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(<#=dim#>);
        int[] idx_r = rows.GetOffsets(<#=dim#>);
        Scalar[,] t = Coefficients;
        Scalar[,] m = new Scalar[idx_c.Length, idx_r.Length];

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                m[c, r] = t[idx_c[c], idx_r[r]];

        return new MatrixNM(m);
    }

    public readonly <#=typename#> SetRegion(Range columns, Range rows, in MatrixNM values)
    {
        // TODO : range checks

        int[] idx_c = columns.GetOffsets(<#=dim#>);
        int[] idx_r = rows.GetOffsets(<#=dim#>);
        Scalar[,] t = Coefficients;
        Scalar[,] m = values;

        for (int c = 0; c < idx_c.Length; ++c)
            for (int r = 0; r < idx_r.Length; ++r)
                t[idx_c[c], idx_r[r]] = m[c, r];

        return new <#=typename#>(t);
    }

<#
        if (dim > 2)
        {
#>
    /// <summary>
    /// Returns the matrix' <#=dim-1#>x<#=dim-1#>-minor at the given indices
    /// </summary>
    /// <param name="column">Zero-based column index</param>
    /// <param name="row">Zero-based row index</param>
    /// <returns><#=dim-1#>x<#=dim-1#>-minor</returns>
    public readonly Matrix<#=dim-1#> GetMinor(int column, int row) =>
        Columns
        .Take(column)
        .Concat(Columns.Skip(column + 1))
        .Select(v =>
        {
            Scalar[] f = v.ToArray();

            return new Vector<#=dim-1#>(f.Take(row).Concat(f.Skip(row + 1)));
        }).ToMatrix();
<#
        }
#>

    #endregion
    #region STATIC METHODS

    public static <#=typename#> Add(<#=typename#> m1, <#=typename#> m2) => m1.Add(m2);

    public static <#=typename#> Subtract(<#=typename#> m1, <#=typename#> m2) => m1.Subtract(m2);

    public static <#=typename#> Multiply(<#=typename#> m1, <#=typename#> m2) => m1.Multiply(m2);

    public static <#=vecname#> Multiply(<#=typename#> m, <#=vecname#> v) => m.Multiply(v);

    public static <#=typename#> Multiply(<#=typename#> m, Scalar s) => m.Multiply(s);

    public static <#=typename#> Divide(<#=typename#> m, Scalar s) => m.Divide(s);

    public static <#=typename#> Exp(<#=typename#> matrix, InfiniteSeriesSettings? settings = null) => matrix.Exp(settings);

    public static <#=typename#> Sin(<#=typename#> matrix, InfiniteSeriesSettings? settings = null) => matrix.Sin(settings);

    public static <#=typename#> Cos(<#=typename#> matrix, InfiniteSeriesSettings? settings = null) => matrix.Cos(settings);

    public static <#=typename#> CracovianProduct(in <#=typename#> first, in <#=typename#> second) => second.Transposed.Multiply(in second);

    public static <#=typename#> HadamardProduct(in <#=typename#> first, in <#=typename#> second) => first.ComponentwiseMultiply(in second);

    public static Scalar DistanceBetween(<#=typename#> first, <#=typename#> second, MatrixNorm norm) => first.DistanceTo(second, norm);

    public static <#=typename#> SparseMatrix(params (int column, int row, Scalar value)[] entries)
    {
        Scalar[,] m = new Scalar[<#=dim#>, <#=dim#>];

        foreach ((int c, int r, Scalar v) in entries)
            m[c, r] = v;

        return FromArray(m);
    }

    public static <#=typename#> SingleEntryMatrix(int column, int row) => SingleEntryMatrix(column, row, 1);

    public static <#=typename#> SingleEntryMatrix(int column, int row, Scalar value)
    {
        Scalar[,] m = new Scalar[<#=dim#>, <#=dim#>];

        m[column, row] = value;

        return FromArray(m);
    }

    public static <#=typename#> DiagonalMatrix(Scalar scalar) => Identity * scalar;

    public static <#=typename#> DiagonalMatrix(in <#=vecname#> diagonal) => DiagonalMatrix(<#=string.Join(", ", r(0, dim).Select(i => $"diagonal[{i}]"))#>);

    public static <#=typename#> DiagonalMatrix(<#=string.Join(", ", r(0, dim).Select(i => "Scalar d" + i))#>) => (
<#
            for (int i = 0; i < dim; ++i)
            {
#>
        <#=string.Join(", ", r(0, dim).Select(j => i == j ? $"d{j}" : "0")) + (i < dim - 1 ? "," : "")#>
<#
            }
#>
    );
    
    public static <#=typename#> KacMurdockSzegöMatrix(Scalar a) => new(
<#
            for (int i = 0; i < dim; ++i)
            {
#>
        <#=string.Join(", ", r(0, dim).Select(j => i == j ? "1" : $"a.Power({Math.Abs(i - j)}) * .5")) + (i < dim - 1 ? "," : "")#>
<#
            }
#>    );

    public static <#=typename#> FromRowPermutation(int[] row_indices) => FromColumnPermutation(row_indices).Transposed;

    public static <#=typename#> FromColumnPermutation(int[] column_indices)
    {
        if (column_indices.Distinct().Count() != column_indices.Length)
            throw new ArgumentException("All indices must be unique.", nameof(column_indices));
        else if (column_indices.Any(i => i < 0 || i >= <#=dim#>))
            throw new ArgumentException("All indices must be a positive integer between (inclusive) 0 and <#=dim - 1#>.", nameof(column_indices));

        <#=vecname#>[] cols = Identity.Columns;

        return FromColumns(column_indices.ToArray(i => cols[i]));
    }

    public static <#=typename#> FromArray(params Scalar[] coefficients) => new(coefficients);

    public static <#=typename#> FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static <#=typename#> FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static <#=typename#> FromCompressedStorageFormat(CompressedStorageFormat<Scalar> compressed) => FromArray(compressed.ToMatrix());

    public static <#=typename#> FromArray(in Scalar[,] arr) => arr.GetLength(0) < <#=dim#> || arr.GetLength(1) < <#=dim#> ? throw new ArgumentException("The array must have a minimum size of <#=dim#>x<#=dim#>.", nameof(arr)) : new <#=typename#>(arr);

    public static <#=typename#> FromArray(in Scalar[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        _ when arr.Length < <#=dim * dim#> => throw new ArgumentException("The array must have a minimum length of <#=dim * dim#>.", nameof(arr)),
        _ => new <#=typename#>(
            <#=string.Join(",\n            ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"arr[{y * dim + x,2}]"))))#>
        )
    };

    public static <#=typename#> FromRows(in <#=vecname#>[] arr) => FromColumns(arr).Transposed;

    public static <#=typename#> FromColumns(in <#=vecname#>[] arr) => arr switch {
        null => throw new ArgumentNullException(nameof(arr)),
        { Length: <#=dim#> } => new <#=typename#>(
            <#=string.Join(",\n            ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"arr[{x}][{y}]"))))#>
        ),
        _ => throw new ArgumentException("The array must have an exact length of <#=dim#>.", nameof(arr))
    };

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given matrices are equal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(<#=typename#> m1, <#=typename#> m2) => m1.Is(m2);

    /// <summary>
    /// Compares whether the two given matrices are unequal regarding their coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(<#=typename#> m1, <#=typename#> m2) => !(m1 == m2);

    /// <summary>
    /// Identity function (returns the given matrix unchanged)
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Unchanged matrix</returns>
    public static <#=typename#> operator +(in <#=typename#> m) => m;

    /// <summary>
    /// Negates the given matrix
    /// </summary>
    /// <param name="m">Original matrix</param>
    /// <returns>Negated matrix</returns>
    public static <#=typename#> operator -(in <#=typename#> m) => m.Negate();

    public static <#=typename#> operator +(Scalar f, in <#=typename#> m) => m.Add(f);

    public static <#=typename#> operator +(in <#=typename#> m, Scalar f) => m.Add(f);

    public static <#=typename#> operator -(Scalar f, in <#=typename#> m) => new <#=typename#>(f).Subtract(in m);

    public static <#=typename#> operator -(in <#=typename#> m, Scalar f) => m.Subtract(f);

    public static <#=typename#> operator ++(in <#=typename#> m) => m.Increment();

    public static <#=typename#> operator --(in <#=typename#> m) => m.Decrement();

    /// <summary>
    /// Performs the addition of two matrices by adding their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Addition result</returns>
    public static <#=typename#> operator +(in <#=typename#> m1, in <#=typename#> m2) => m1.Add(in m2);

    /// <summary>
    /// Performs the subtraction of two matrices by subtracting their respective coefficients.
    /// </summary>
    /// <param name="m1">First matrix</param>
    /// <param name="m2">Second matrix</param>
    /// <returns>Subtraction result</returns>
    public static <#=typename#> operator -(in <#=typename#> m1, in <#=typename#> m2) => m1.Subtract(in m2);

    public static <#=vecname#> operator *(in <#=typename#> m, in <#=vecname#> v) => m.Multiply(in v);

    public static <#=typename#> operator *(in <#=typename#> m1, in <#=typename#> m2) => m1.Multiply(in m2);

    public static <#=typename#> operator *(in <#=typename#> m, Scalar f) => m.Multiply(f);

    public static <#=typename#> operator *(Scalar f, in <#=typename#> m) => m.Multiply(f);

    public static <#=typename#> operator ^(in <#=typename#> m, int c) => m.Power(c);

    public static <#=typename#> operator ^(in <#=typename#> m1, in <#=typename#> m2) => CracovianProduct(in m1, in m2);

    /// <summary>
    /// Solves the linear equation system Ax=b with the provided matrix A and vector b.
    /// </summary>
    /// <param name="A">Matrix A</param>
    /// <param name="b">Vector b</param>
    /// <returns>Solution x</returns>
    public static <#=vecspace#> operator |(<#=typename#> A, <#=vecname#> b) => A.Solve(b);

    public static <#=vecspace#> operator |(<#=typename#> A, <#=vecspace#> b) => A.Solve(b);

    public static <#=typename#> operator /(<#=typename#> m1, <#=typename#> m2) => m1.Multiply(m2.Inverse);

    public static <#=typename#> operator /(in <#=typename#> m, Scalar f) => m.Divide(f);

    public static <#=typename#> operator %(in <#=typename#> m, Scalar f) => m.Modulus(f);

<#
        string _vecs = string.Join(", ", r(0, dim).Select(i => $"Vector{dim} x{i}"));
        string _scals = string.Join(", ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => $"Scalar r{j}"))}) c{i}"));
        string _flats = string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"Scalar x_{j}_{i}")));
#>
    public static implicit operator (<#=_vecs#>) (in <#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

    public static implicit operator <#=typename#>((<#=_vecs#>) t) => new(<#=string.Join(", ", r(0, dim).Select(i => $"t.x{i}"))#>);
/*
    public static explicit operator (<#=_scals#>) (in <#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

    public static explicit operator <#=typename#>(in (<#=_scals#>) t) => new(<#=string.Join(", ", r(0, dim).Select(i => $"t.c{i}"))#>);
*/
    public static implicit operator (<#=_flats#>) (in <#=typename#> m) => (
<#
        for (int i = 0; i < dim; ++i)
        {
#>
        <#=string.Join(", ", r(0, dim).Select(j => $"m._c{j}[{i}]"))#><#=i < dim - 1 ? "," : ""#>
<#
        }
#>
    );

    public static implicit operator <#=typename#>(in (<#=_flats#>) t) => new(
<#
        for (int i = 0; i < dim; ++i)
        {
#>
        <#=string.Join(", ", r(0, dim).Select(j => $"t.x_{j}_{i}"))#><#=i < dim - 1 ? "," : ""#>
<#
        }
#>
    );

    public static explicit operator <#=typename#>(Scalar m) => new(m);

    public static implicit operator <#=typename#>(in <#=vecname#>[] arr) => new(arr);

    public static implicit operator <#=vecname#>[](in <#=typename#> m) => m.Columns;

    public static explicit operator Scalar[](in <#=typename#> m) => m.ToArray();

    public static implicit operator <#=typename#>(Scalar[] arr) => new(arr);

    public static implicit operator Scalar[,](in <#=typename#> m) => m.Coefficients;

    public static implicit operator <#=typename#>(Scalar[,] arr) => new(arr);

    public static implicit operator MatrixNM(in <#=typename#> m) => new(m.Coefficients);

    public static explicit operator <#=typename#>(in MatrixNM m) => new(m);

    public static implicit operator CompressedStorageFormat<Scalar>(in <#=typename#> m) => CompressedStorageFormat<Scalar>.FromMatrix<<#=typename#>>(m);

    public static implicit operator Function<<#=vecname#>>(in <#=typename#> m) => m.ToIsomorphism();

    #endregion

    public sealed class <#=typename#>EqualityComparer
        : IEqualityComparer<<#=typename#>>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=typename#> x, <#=typename#> y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(<#=typename#> obj) => obj.GetHashCode();
    }
}

public static class <#=typename#>Extensions
{
    public static <#=typename#> Sum(this IEnumerable<<#=typename#>> matrices) => <#=typename#>.Zero.Add(matrices.ToArray());

    public static <#=typename#> Average(this IEnumerable<<#=typename#>> matrices)
    {
        <#=typename#> mat = <#=typename#>.Zero;
        long count = 0;

        foreach (<#=typename#> m in matrices)
        {
            mat = mat.Add(in m);
            ++count;
        }

        return mat.Divide(count);
    }
}

#endregion
<#
    }
#>
#region MatrixNM (Extensions)

public partial class MatrixNM
{
    public Algebra<Scalar, Polynomial>.IMatrix Cast() => Size switch
    {
        (1, 1) => this[0, 0],
        // (_, 1) => this[0],
<#
    for (int i = 2; i < maxdim; ++i)
    {
#>
        (<#=i#>, <#=i#>) => (Matrix<#=i#>)this,
<#
    }
#>
        _ => new MatrixNM(this) as Algebra<Scalar, Polynomial>.IMatrix
    };
}

public static class MatrixExtensions
{
<#
    for (int dim = 2; dim < maxdim; ++dim)
    {
#>

    public static Matrix<#=dim#> ToMatrix(this IEnumerable<Vector<#=dim#>> columns) => new(columns);
<#
    }
#>
}

#endregion
