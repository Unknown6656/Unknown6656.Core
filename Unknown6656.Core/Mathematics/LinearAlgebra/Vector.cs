///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED 2023-11-13 10:26:32.374465              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

// #define GENERIC_MATH

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System;

using Unknown6656.Mathematics.Analysis;
using Unknown6656.Mathematics.Numerics;
using Unknown6656.Generics;
using Unknown6656.Common;
using Unknown6656.IO;

namespace Unknown6656.Mathematics.LinearAlgebra;

// TODO : fix coefficient naming 'XYZWVU'

#region Vector2

/// <summary>
/// Represents a 2-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector2(Scalar x0, Scalar x1)
    : Algebra<Scalar>.IVector<Vector2, Matrix2>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector2>
    , IEnumerable<Scalar>
    , IComparable<Vector2>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector2>
    , IModulusOperators<Vector2, Scalar, Vector2>
    , IMultiplyOperators<Vector2, Vector2, Scalar>
    , IMultiplyOperators<Vector2, Scalar, Vector2>
    , IDivisionOperators<Vector2, Scalar, Vector2>
    , IMultiplyOperators<Scalar, Vector2, Vector2>
    , IDecrementOperators<Vector2>
    , IAdditionOperators<Vector2, Vector2, Vector2>
    , ISubtractionOperators<Vector2, Vector2, Vector2>
    , IUnaryPlusOperators<Vector2, Vector2>
    , IUnaryNegationOperators<Vector2, Vector2>
    , IAdditiveIdentity<Vector2, Vector2>
    , IMultiplicativeIdentity<Vector2, Vector2>
    , IComparisonOperators<Vector2, Vector2>
    , IEqualityOperators<Vector2, Vector2>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 2;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector2 Zero { get; } = new(0);

    public static Vector2[] UnitVectors { get; } = Matrix2.Identity.Columns;

    /// <summary>
    /// The unit vector in X-direction
    /// </summary>
    public static Vector2 UnitX { get; } = (1, 0);

    /// <summary>
    /// The unit vector in Y-direction
    /// </summary>
    public static Vector2 UnitY { get; } = (0, 1);

    /// <summary>
    /// The raw memory size of the <see cref="Vector2"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector2);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector2"/>.
    /// </summary>
    public static Vector2EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace2 UnitSpace { get; } = VectorSpace2.FromMatrixColumns(Matrix2.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(2)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector2 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector2 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <summary>
    /// Returns the vector's X-coefficient (Index = 0).
    /// </summary>
    public readonly Scalar X => _0;

    /// <summary>
    /// Returns the vector's Y-coefficient (Index = 1).
    /// </summary>
    public readonly Scalar Y => _1;

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(2, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector2 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector2 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix2 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 2-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector2(Scalar s = default)
        : this(s, s)
    {
    }

    public Vector2(Scalar* values)
        : this((Vector2*)values)
    {
    }

    public Vector2(Vector2* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 2-dimensional one
    /// </summary>
    /// <param name="v">The 2-dimensional vector</param>
    public Vector2(in Vector2 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 3-dimensional one
    /// </summary>
    /// <param name="v">The 3-dimensional vector</param>
    public Vector2(in Vector3 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 4-dimensional one
    /// </summary>
    /// <param name="v">The 4-dimensional vector</param>
    public Vector2(in Vector4 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 5-dimensional one
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    public Vector2(in Vector5 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 6-dimensional one
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector2(in Vector6 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector2(in Vector7 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector2(in Vector8 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector2(in Vector9 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector2(in Vector10 v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector2(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[2])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector2(Scalar[] v)
        : this(v[0], v[1])
    {
    }

    /// <summary>
    /// Creates a new 2-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector2(IEnumerable<double>? v)
        : this((v ?? new double[2]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector2 Negate() => new(-_0, -_1);

    public readonly Vector2 Add(in Vector2 second) => new(_0 + second._0, _1 + second._1);

    public readonly Vector2 Add(Scalar s0, Scalar s1) => new(_0 + s0, _1 + s1);

    public readonly Vector2 Add(params Vector2[] others) => others.Aggregate(this, Add);

    public readonly Vector2 MoveBy(in Vector2 second) => Add(in second);

    public readonly Vector2 MoveBy(Scalar s0, Scalar s1) => Add(s0, s1);

    public readonly Vector2 Subtract(in Vector2 second) => Add(second.AdditiveInverse);

    public readonly Vector2 Subtract(Scalar s0, Scalar s1) => new(_0 - s0, _1 - s1);

    public readonly Vector2 Subtract(params Vector2[] others) => others.Aggregate(this, Subtract);

    public readonly Vector2 Increment() => Add(new Vector2(1));

    public readonly Vector2 Decrement() => Subtract(new Vector2(1));

    public readonly Vector2 Multiply(Scalar factor) => new(_0 * factor, _1 * factor);

    public readonly Vector2 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector2 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector2 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector2 Modulus(Scalar factor) => new(_0 % factor, _1 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        _ => throw new InvalidOperationException($"A vector of the type 'Vector2' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix2 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector2 ComponentwiseMultiply(in Vector2 second) => new(_0 * second._0, _1 * second._1);

    public readonly Vector2 ComponentwiseMultiply(Scalar s0, Scalar s1) => new(_0 * s0, _1 * s1);

    public readonly Vector2 ComponentwiseDivide(in Vector2 second) => new(_0 / second._0, _1 / second._1);

    public readonly Vector2 ComponentwiseDivide(Scalar s0, Scalar s1) => new(_0 / s0, _1 / s1);

    public readonly Vector2 ComponentwiseModulus(in Vector2 second) => new(_0 % second._0, _1 % second._1);

    public readonly Vector2 ComponentwiseModulus(Scalar s0, Scalar s1) => new(_0 % s0, _1 % s1);

    readonly Vector2 Algebra<Scalar>.IVectorSpace<Vector2>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar);

    public readonly Vector2 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs());

    public readonly Vector2 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt());

    public readonly Vector2 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1));

    public readonly Vector2 ComponentwiseApply(Vector2 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1));

    public readonly Vector2 ComponentwiseApply(Vector2 second, Vector2 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1));

    public readonly Vector2 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector2 r = (1, 1);
        Vector2 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector2 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector2 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 2; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector2 LinearInterpolate(in Vector2 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector2 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector2 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector2 second) => Dot(second).Acos();

    public readonly Matrix2 OuterProduct(in Vector2 second) => new(
        _0 * second._0, _1 * second._1,
        _0 * second._0, _1 * second._1
    );

    /// <summary>
    /// Returns the vector' 1D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>1D-minor</returns>
    public readonly Scalar Minor(int row) => row switch
    {
        0 => _1,
        1 => _0,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly bool Equals(Vector2 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector2 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector2 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector2)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector2(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1) => (x0, x1) = (_0, _1);

    public readonly bool Is(Vector2 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance);

    public readonly bool Is(Vector2 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector2 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector2 second) => Dot(second).IsZero;

    public readonly Vector2 Reflect(in Vector2 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector2 normal, Scalar eta, out Vector2 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector2 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector2 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector3 ToHomogeneousCoordinates() => new(_0, _1, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector2 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(2);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector2 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector2 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector2(v[0], v[1])
    };

    public static Vector2 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector2 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector2 FromHomogeneousCoordinates(Vector3 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector2 Add(Vector2 m1, Vector2 m2) => m1.Add(m2);

    public static Vector2 Subtract(Vector2 m1, Vector2 m2) => m1.Subtract(m2);

    public static Vector2 Multiply(Vector2 m, Scalar s) => m.Multiply(s);

    public static Vector2 Divide(Vector2 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector2 v1, in Vector2 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector2 v1, in Vector2 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector2 v1, in Vector2 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix2 OuterProduct(in Vector2 v1, in Vector2 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector2 LinearInterpolate(in Vector2 v1, in Vector2 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector2, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector2 v1, in Vector2 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector2 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector2(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector2 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector2 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 2)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 1.");

        Scalar[] coeff = new Scalar[2];

        coeff[n] = Scalar.One;

        return new Vector2(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector2 first, Vector2 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector2 first, Vector2 second) => first.IsNot(second);

    public static bool operator true(Vector2 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector2 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector2 v1, in Vector2 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector2 v1, in Vector2 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector2 v1, in Vector2 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector2 v1, in Vector2 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector2 operator ~(in Vector2 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector2 operator -(in Vector2 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector2 operator +(in Vector2 v) => v;

    public static Vector2 operator ++(in Vector2 v) => v.Increment();

    public static Vector2 operator --(in Vector2 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector2 operator +(in Vector2 v1, in Vector2 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector2 operator +(in Vector2 v, Scalar f) => v + new Vector2(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector2 operator +(Scalar f, in Vector2 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector2 operator -(in Vector2 v1, in Vector2 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector2 operator -(in Vector2 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector2 operator -(Scalar f, in Vector2 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector2 operator *(in Vector2 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector2 operator *(Scalar f, in Vector2 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector2 v1, in Vector2 v2) => v1.Dot(in v2);

    public static Vector2 operator ^(in Vector2 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector2 operator /(in Vector2 v, Scalar f) => v.Divide(f);

    public static Vector2 operator /(Scalar f, in Vector2 v) => new Vector2(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector2 v1, in Vector2 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector2 operator %(in Vector2 v, Scalar f) => v.Modulus(f);

    public static Vector2 operator %(in Vector2 v1, in Vector2 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector2 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector2 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector2 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector2 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector2 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector2(num.Vector<Scalar> v) => new(v[0], v[1]);

    public static implicit operator Vector2(num.Vector<double> v) => new(v[0], v[1]);

    public static implicit operator Vector2(num.Vector<float> v) => new(v[0], v[1]);

    public static implicit operator Vector2(num.Vector<long> v) => new(v[0], v[1]);

    public static implicit operator Vector2(num.Vector<int> v) => new(v[0], v[1]);

    public static implicit operator Scalar[](in Vector2 v) => v.Coefficients;

    public static explicit operator Vector2(Scalar[] arr) => new(arr);

    public static explicit operator Vector2(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1) (in Vector2 v) => (v._0, v._1);

    public static implicit operator Vector2((Scalar x0, Scalar x1) t) => new(t.x0, t.x1);

    public static implicit operator Polynomial(in Vector2 v) => v.ToPolynomial();

    public static explicit operator Vector2(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector2 v) => new(v.ToArray());

    public static explicit operator Vector2(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector2EqualityComparer
        : IEqualityComparer<Vector2>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector2 x, Vector2 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector2 obj) => obj.GetHashCode();
    }
}

public static class Vector2Extensions
{
    public static Vector2 Sum(this IEnumerable<Vector2> vectors) => Vector2.Zero.Add(vectors.ToArray());

    public static Vector2 Average(this IEnumerable<Vector2> vectors)
    {
        Vector2 vec = Vector2.Zero;
        long count = 0;

        foreach (Vector2 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector3

/// <summary>
/// Represents a crossable 3-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector3(Scalar x0, Scalar x1, Scalar x2)
    : Algebra<Scalar>.IVector<Vector3, Matrix3>
    , Algebra<Scalar>.ICrossableVector<Vector3>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector3>
    , IEnumerable<Scalar>
    , IComparable<Vector3>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector3>
    , IModulusOperators<Vector3, Scalar, Vector3>
    , IMultiplyOperators<Vector3, Vector3, Scalar>
    , IMultiplyOperators<Vector3, Scalar, Vector3>
    , IDivisionOperators<Vector3, Scalar, Vector3>
    , IMultiplyOperators<Scalar, Vector3, Vector3>
    , IDecrementOperators<Vector3>
    , IAdditionOperators<Vector3, Vector3, Vector3>
    , ISubtractionOperators<Vector3, Vector3, Vector3>
    , IUnaryPlusOperators<Vector3, Vector3>
    , IUnaryNegationOperators<Vector3, Vector3>
    , IAdditiveIdentity<Vector3, Vector3>
    , IMultiplicativeIdentity<Vector3, Vector3>
    , IComparisonOperators<Vector3, Vector3>
    , IEqualityOperators<Vector3, Vector3>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 3;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector3 Zero { get; } = new(0);

    public static Vector3[] UnitVectors { get; } = Matrix3.Identity.Columns;

    /// <summary>
    /// The unit vector in X-direction
    /// </summary>
    public static Vector3 UnitX { get; } = (1, 0, 0);

    /// <summary>
    /// The unit vector in Y-direction
    /// </summary>
    public static Vector3 UnitY { get; } = (0, 1, 0);

    /// <summary>
    /// The unit vector in Z-direction
    /// </summary>
    public static Vector3 UnitZ { get; } = (0, 0, 1);

    /// <summary>
    /// The raw memory size of the <see cref="Vector3"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector3);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector3"/>.
    /// </summary>
    public static Vector3EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace3 UnitSpace { get; } = VectorSpace3.FromMatrixColumns(Matrix3.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(3)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector3 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector3 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <summary>
    /// Returns the vector's X-coefficient (Index = 0).
    /// </summary>
    public readonly Scalar X => _0;

    /// <summary>
    /// Returns the vector's Y-coefficient (Index = 1).
    /// </summary>
    public readonly Scalar Y => _1;

    /// <summary>
    /// Returns the vector's Z-coefficient (Index = 2).
    /// </summary>
    public readonly Scalar Z => _2;

    /// <summary>
    /// Returns the combination of the vector's XY-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XY => new(X, Y);

    /// <summary>
    /// Returns the combination of the vector's XZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XZ => new(X, Z);

    /// <summary>
    /// Returns the combination of the vector's YZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YZ => new(Y, Z);

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(3, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector3 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector3 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix3 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 3-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector3(Scalar s = default)
        : this(s, s, s)
    {
    }

    public Vector3(Scalar* values)
        : this((Vector3*)values)
    {
    }

    public Vector3(Vector3* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 3-dimensional one
    /// </summary>
    /// <param name="v">The 3-dimensional vector</param>
    public Vector3(in Vector3 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 4-dimensional one
    /// </summary>
    /// <param name="v">The 4-dimensional vector</param>
    public Vector3(in Vector4 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 5-dimensional one
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    public Vector3(in Vector5 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 6-dimensional one
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector3(in Vector6 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector3(in Vector7 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector3(in Vector8 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector3(in Vector9 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector3(in Vector10 v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 2-dimensional one.
    /// </summary>
    /// <param name="v">The 2-dimensional vector</param>
    public Vector3(in Vector2 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given 2-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 2-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector3(in Vector2 v, Scalar c)
        : this(v[0], v[1], c)
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector3(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[3])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector3(Scalar[] v)
        : this(v[0], v[1], v[2])
    {
    }

    /// <summary>
    /// Creates a new 3-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector3(IEnumerable<double>? v)
        : this((v ?? new double[3]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector3 Negate() => new(-_0, -_1, -_2);

    public readonly Vector3 Add(in Vector3 second) => new(_0 + second._0, _1 + second._1, _2 + second._2);

    public readonly Vector3 Add(Scalar s0, Scalar s1, Scalar s2) => new(_0 + s0, _1 + s1, _2 + s2);

    public readonly Vector3 Add(params Vector3[] others) => others.Aggregate(this, Add);

    public readonly Vector3 MoveBy(in Vector3 second) => Add(in second);

    public readonly Vector3 MoveBy(Scalar s0, Scalar s1, Scalar s2) => Add(s0, s1, s2);

    public readonly Vector3 Subtract(in Vector3 second) => Add(second.AdditiveInverse);

    public readonly Vector3 Subtract(Scalar s0, Scalar s1, Scalar s2) => new(_0 - s0, _1 - s1, _2 - s2);

    public readonly Vector3 Subtract(params Vector3[] others) => others.Aggregate(this, Subtract);

    public readonly Vector3 Increment() => Add(new Vector3(1));

    public readonly Vector3 Decrement() => Subtract(new Vector3(1));

    public readonly Vector3 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor);

    public readonly Vector3 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector3 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector3 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector3 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        _ => throw new InvalidOperationException($"A vector of the type 'Vector3' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix3 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector3 ComponentwiseMultiply(in Vector3 second) => new(_0 * second._0, _1 * second._1, _2 * second._2);

    public readonly Vector3 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2) => new(_0 * s0, _1 * s1, _2 * s2);

    public readonly Vector3 ComponentwiseDivide(in Vector3 second) => new(_0 / second._0, _1 / second._1, _2 / second._2);

    public readonly Vector3 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2) => new(_0 / s0, _1 / s1, _2 / s2);

    public readonly Vector3 ComponentwiseModulus(in Vector3 second) => new(_0 % second._0, _1 % second._1, _2 % second._2);

    public readonly Vector3 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2) => new(_0 % s0, _1 % s1, _2 % s2);

    readonly Vector3 Algebra<Scalar>.IVectorSpace<Vector3>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar);

    public readonly Vector3 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs());

    public readonly Vector3 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt());

    public readonly Vector3 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2));

    public readonly Vector3 ComponentwiseApply(Vector3 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2));

    public readonly Vector3 ComponentwiseApply(Vector3 second, Vector3 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2));

    public readonly Vector3 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector3 r = (1, 1, 1);
        Vector3 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector3 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly Vector3 Cross(in Vector3 v) => Cross(this, v);

    public readonly Scalar TripleProduct(in Vector3 b, in Vector3 c) => TripleProduct(this, b, c);

    public readonly bool IsLinearDependant(in Vector3 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 3; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector3 LinearInterpolate(in Vector3 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector3 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector3 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector3 second) => Dot(second).Acos();

    public readonly Matrix3 OuterProduct(in Vector3 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2,
        _0 * second._0, _1 * second._1, _2 * second._2,
        _0 * second._0, _1 * second._1, _2 * second._2
    );

    /// <summary>
    /// Returns the vector' 2D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>2D-minor</returns>
    public readonly Vector2 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector2(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector3 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector3 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector3 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector3)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector3(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2) => (x0, x1, x2) = (_0, _1, _2);

    // public readonly void Deconstruct(out Scalar x0, out Vector2 v1) => (x0, v1) = (_0, (_1, _2));
    //
    // public readonly void Deconstruct(out Vector2 v0, out Scalar x1) => (v0, x1) = ((_0, _1), _2);

    public readonly bool Is(Vector3 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance);

    public readonly bool Is(Vector3 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector3 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector3 second) => Dot(second).IsZero;

    public readonly Vector3 Reflect(in Vector3 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector3 normal, Scalar eta, out Vector3 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector3 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector3 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector2 FromHomogeneousCoordinates() => new(_0 / _2, _1 / _2);

    public readonly Vector4 ToHomogeneousCoordinates() => new(_0, _1, _2, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector3 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(3);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector3 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    /// <inheritdoc cref="ICrossableVector{V, S}.Cross(V)"/>
    public static Vector3 Cross(in Vector3 x, in Vector3 y)
 => (
        x.Y * y.Z - y.Y * x.Z,
        x.Z * y.X - y.Z * x.X,
        x.X * y.Y - y.X * x.Y
    );

    /// <inheritdoc cref="ICrossableVector{V, S}.TripleProduct(V, V)"/>
    public static Scalar TripleProduct(in Vector3 a, in Vector3 b, in Vector3 c) => Dot(a, Cross(b, c));

    public static Vector3 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector3(v[0], v[1], v[2])
    };

    public static Vector3 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector3 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector3 FromHomogeneousCoordinates(Vector4 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector3 Add(Vector3 m1, Vector3 m2) => m1.Add(m2);

    public static Vector3 Subtract(Vector3 m1, Vector3 m2) => m1.Subtract(m2);

    public static Vector3 Multiply(Vector3 m, Scalar s) => m.Multiply(s);

    public static Vector3 Divide(Vector3 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector3 v1, in Vector3 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector3 v1, in Vector3 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector3 v1, in Vector3 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix3 OuterProduct(in Vector3 v1, in Vector3 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector3 LinearInterpolate(in Vector3 v1, in Vector3 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector3, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector3 v1, in Vector3 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector3 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector3(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector3 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector3 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 3)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 2.");

        Scalar[] coeff = new Scalar[3];

        coeff[n] = Scalar.One;

        return new Vector3(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector3 first, Vector3 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector3 first, Vector3 second) => first.IsNot(second);

    public static bool operator true(Vector3 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector3 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector3 v1, in Vector3 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector3 v1, in Vector3 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector3 v1, in Vector3 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector3 v1, in Vector3 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector3 operator ~(in Vector3 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector3 operator -(in Vector3 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector3 operator +(in Vector3 v) => v;

    public static Vector3 operator ++(in Vector3 v) => v.Increment();

    public static Vector3 operator --(in Vector3 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector3 operator +(in Vector3 v1, in Vector3 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector3 operator +(in Vector3 v, Scalar f) => v + new Vector3(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector3 operator +(Scalar f, in Vector3 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector3 operator -(in Vector3 v1, in Vector3 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector3 operator -(in Vector3 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector3 operator -(Scalar f, in Vector3 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector3 operator *(in Vector3 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector3 operator *(Scalar f, in Vector3 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector3 v1, in Vector3 v2) => v1.Dot(in v2);

    public static Vector3 operator ^(in Vector3 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector3 operator /(in Vector3 v, Scalar f) => v.Divide(f);

    public static Vector3 operator /(Scalar f, in Vector3 v) => new Vector3(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector3 v1, in Vector3 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector3 operator %(in Vector3 v, Scalar f) => v.Modulus(f);

    public static Vector3 operator %(in Vector3 v1, in Vector3 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector3 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector3 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector3 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector3 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector3 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector3(num.Vector<Scalar> v) => new(v[0], v[1], v[2]);

    public static implicit operator Vector3(num.Vector<double> v) => new(v[0], v[1], v[2]);

    public static implicit operator Vector3(num.Vector<float> v) => new(v[0], v[1], v[2]);

    public static implicit operator Vector3(num.Vector<long> v) => new(v[0], v[1], v[2]);

    public static implicit operator Vector3(num.Vector<int> v) => new(v[0], v[1], v[2]);

    public static implicit operator Scalar[](in Vector3 v) => v.Coefficients;

    public static explicit operator Vector3(Scalar[] arr) => new(arr);

    public static explicit operator Vector3(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2) (in Vector3 v) => (v._0, v._1, v._2);

    public static implicit operator Vector3((Scalar x0, Scalar x1, Scalar x2) t) => new(t.x0, t.x1, t.x2);

    public static implicit operator (Scalar x0, Vector2 v1)(in Vector3 v) => (v._0, (v._1, v._2));

    public static implicit operator (Vector2 v0, Scalar x1)(in Vector3 v) => ((v._0, v._1), v._2);

    public static implicit operator Polynomial(in Vector3 v) => v.ToPolynomial();

    public static explicit operator Vector3(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector3 v) => new(v.ToArray());

    public static explicit operator Vector3(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector3EqualityComparer
        : IEqualityComparer<Vector3>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector3 x, Vector3 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector3 obj) => obj.GetHashCode();
    }
}

public static class Vector3Extensions
{
    public static Vector3 Sum(this IEnumerable<Vector3> vectors) => Vector3.Zero.Add(vectors.ToArray());

    public static Vector3 Average(this IEnumerable<Vector3> vectors)
    {
        Vector3 vec = Vector3.Zero;
        long count = 0;

        foreach (Vector3 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector4

/// <summary>
/// Represents a 4-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector4(Scalar x0, Scalar x1, Scalar x2, Scalar x3)
    : Algebra<Scalar>.IVector<Vector4, Matrix4>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector4>
    , IEnumerable<Scalar>
    , IComparable<Vector4>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector4>
    , IModulusOperators<Vector4, Scalar, Vector4>
    , IMultiplyOperators<Vector4, Vector4, Scalar>
    , IMultiplyOperators<Vector4, Scalar, Vector4>
    , IDivisionOperators<Vector4, Scalar, Vector4>
    , IMultiplyOperators<Scalar, Vector4, Vector4>
    , IDecrementOperators<Vector4>
    , IAdditionOperators<Vector4, Vector4, Vector4>
    , ISubtractionOperators<Vector4, Vector4, Vector4>
    , IUnaryPlusOperators<Vector4, Vector4>
    , IUnaryNegationOperators<Vector4, Vector4>
    , IAdditiveIdentity<Vector4, Vector4>
    , IMultiplicativeIdentity<Vector4, Vector4>
    , IComparisonOperators<Vector4, Vector4>
    , IEqualityOperators<Vector4, Vector4>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 4;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector4 Zero { get; } = new(0);

    public static Vector4[] UnitVectors { get; } = Matrix4.Identity.Columns;

    /// <summary>
    /// The unit vector in X-direction
    /// </summary>
    public static Vector4 UnitX { get; } = (1, 0, 0, 0);

    /// <summary>
    /// The unit vector in Y-direction
    /// </summary>
    public static Vector4 UnitY { get; } = (0, 1, 0, 0);

    /// <summary>
    /// The unit vector in Z-direction
    /// </summary>
    public static Vector4 UnitZ { get; } = (0, 0, 1, 0);

    /// <summary>
    /// The unit vector in W-direction
    /// </summary>
    public static Vector4 UnitW { get; } = (0, 0, 0, 1);

    /// <summary>
    /// The raw memory size of the <see cref="Vector4"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector4);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector4"/>.
    /// </summary>
    public static Vector4EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace4 UnitSpace { get; } = VectorSpace4.FromMatrixColumns(Matrix4.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(4)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector4 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector4 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <summary>
    /// Returns the vector's X-coefficient (Index = 0).
    /// </summary>
    public readonly Scalar X => _0;

    /// <summary>
    /// Returns the vector's Y-coefficient (Index = 1).
    /// </summary>
    public readonly Scalar Y => _1;

    /// <summary>
    /// Returns the vector's Z-coefficient (Index = 2).
    /// </summary>
    public readonly Scalar Z => _2;

    /// <summary>
    /// Returns the vector's W-coefficient (Index = 3).
    /// </summary>
    public readonly Scalar W => _3;

    /// <summary>
    /// Returns the combination of the vector's XY-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XY => new(X, Y);

    /// <summary>
    /// Returns the combination of the vector's XZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XZ => new(X, Z);

    /// <summary>
    /// Returns the combination of the vector's YZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YZ => new(Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XW => new(X, W);

    /// <summary>
    /// Returns the combination of the vector's YW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YW => new(Y, W);

    /// <summary>
    /// Returns the combination of the vector's ZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZW => new(Z, W);

    /// <summary>
    /// Returns the combination of the vector's XYZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYZ => new(X, Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XYW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYW => new(X, Y, W);

    /// <summary>
    /// Returns the combination of the vector's XZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZW => new(X, Z, W);

    /// <summary>
    /// Returns the combination of the vector's YZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZW => new(Y, Z, W);

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(4, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector4 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector4 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix4 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 4-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector4(Scalar s = default)
        : this(s, s, s, s)
    {
    }

    public Vector4(Scalar* values)
        : this((Vector4*)values)
    {
    }

    public Vector4(Vector4* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 4-dimensional one
    /// </summary>
    /// <param name="v">The 4-dimensional vector</param>
    public Vector4(in Vector4 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 5-dimensional one
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    public Vector4(in Vector5 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 6-dimensional one
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector4(in Vector6 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector4(in Vector7 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector4(in Vector8 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector4(in Vector9 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector4(in Vector10 v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 3-dimensional one.
    /// </summary>
    /// <param name="v">The 3-dimensional vector</param>
    public Vector4(in Vector3 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given 3-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 3-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector4(in Vector3 v, Scalar c)
        : this(v[0], v[1], v[2], c)
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector4(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[4])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector4(Scalar[] v)
        : this(v[0], v[1], v[2], v[3])
    {
    }

    /// <summary>
    /// Creates a new 4-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector4(IEnumerable<double>? v)
        : this((v ?? new double[4]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector4 Negate() => new(-_0, -_1, -_2, -_3);

    public readonly Vector4 Add(in Vector4 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3);

    public readonly Vector4 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3);

    public readonly Vector4 Add(params Vector4[] others) => others.Aggregate(this, Add);

    public readonly Vector4 MoveBy(in Vector4 second) => Add(in second);

    public readonly Vector4 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => Add(s0, s1, s2, s3);

    public readonly Vector4 Subtract(in Vector4 second) => Add(second.AdditiveInverse);

    public readonly Vector4 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3);

    public readonly Vector4 Subtract(params Vector4[] others) => others.Aggregate(this, Subtract);

    public readonly Vector4 Increment() => Add(new Vector4(1));

    public readonly Vector4 Decrement() => Subtract(new Vector4(1));

    public readonly Vector4 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor);

    public readonly Vector4 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector4 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector4 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector4 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        _ => throw new InvalidOperationException($"A vector of the type 'Vector4' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix4 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector4 ComponentwiseMultiply(in Vector4 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3);

    public readonly Vector4 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3);

    public readonly Vector4 ComponentwiseDivide(in Vector4 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3);

    public readonly Vector4 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3);

    public readonly Vector4 ComponentwiseModulus(in Vector4 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3);

    public readonly Vector4 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3);

    readonly Vector4 Algebra<Scalar>.IVectorSpace<Vector4>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar);

    public readonly Vector4 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs());

    public readonly Vector4 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt());

    public readonly Vector4 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3));

    public readonly Vector4 ComponentwiseApply(Vector4 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3));

    public readonly Vector4 ComponentwiseApply(Vector4 second, Vector4 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3));

    public readonly Vector4 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector4 r = (1, 1, 1, 1);
        Vector4 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector4 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector4 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 4; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector4 LinearInterpolate(in Vector4 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector4 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector4 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector4 second) => Dot(second).Acos();

    public readonly Matrix4 OuterProduct(in Vector4 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3
    );

    /// <summary>
    /// Returns the vector' 3D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>3D-minor</returns>
    public readonly Vector3 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector3(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector4 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector4 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector4 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector4)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector4(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3) => (x0, x1, x2, x3) = (_0, _1, _2, _3);

    // public readonly void Deconstruct(out Scalar x0, out Vector3 v1) => (x0, v1) = (_0, (_1, _2, _3));
    //
    // public readonly void Deconstruct(out Vector3 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2), _3);

    public readonly bool Is(Vector4 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance);

    public readonly bool Is(Vector4 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector4 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector4 second) => Dot(second).IsZero;

    public readonly Vector4 Reflect(in Vector4 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector4 normal, Scalar eta, out Vector4 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector4 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector4 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector3 FromHomogeneousCoordinates() => new(_0 / _3, _1 / _3, _2 / _3);

    public readonly Vector5 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector4 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(4);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector4 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector4 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector4(v[0], v[1], v[2], v[3])
    };

    public static Vector4 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector4 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector4 FromHomogeneousCoordinates(Vector5 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector4 Add(Vector4 m1, Vector4 m2) => m1.Add(m2);

    public static Vector4 Subtract(Vector4 m1, Vector4 m2) => m1.Subtract(m2);

    public static Vector4 Multiply(Vector4 m, Scalar s) => m.Multiply(s);

    public static Vector4 Divide(Vector4 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector4 v1, in Vector4 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector4 v1, in Vector4 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector4 v1, in Vector4 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix4 OuterProduct(in Vector4 v1, in Vector4 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector4 LinearInterpolate(in Vector4 v1, in Vector4 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector4, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector4 v1, in Vector4 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector4 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector4(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector4 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector4 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 4)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 3.");

        Scalar[] coeff = new Scalar[4];

        coeff[n] = Scalar.One;

        return new Vector4(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector4 first, Vector4 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector4 first, Vector4 second) => first.IsNot(second);

    public static bool operator true(Vector4 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector4 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector4 v1, in Vector4 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector4 v1, in Vector4 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector4 v1, in Vector4 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector4 v1, in Vector4 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector4 operator ~(in Vector4 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector4 operator -(in Vector4 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector4 operator +(in Vector4 v) => v;

    public static Vector4 operator ++(in Vector4 v) => v.Increment();

    public static Vector4 operator --(in Vector4 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector4 operator +(in Vector4 v1, in Vector4 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector4 operator +(in Vector4 v, Scalar f) => v + new Vector4(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector4 operator +(Scalar f, in Vector4 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector4 operator -(in Vector4 v1, in Vector4 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector4 operator -(in Vector4 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector4 operator -(Scalar f, in Vector4 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector4 operator *(in Vector4 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector4 operator *(Scalar f, in Vector4 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector4 v1, in Vector4 v2) => v1.Dot(in v2);

    public static Vector4 operator ^(in Vector4 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector4 operator /(in Vector4 v, Scalar f) => v.Divide(f);

    public static Vector4 operator /(Scalar f, in Vector4 v) => new Vector4(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector4 v1, in Vector4 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector4 operator %(in Vector4 v, Scalar f) => v.Modulus(f);

    public static Vector4 operator %(in Vector4 v1, in Vector4 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector4 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector4 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector4 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector4 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector4 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector4(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3]);

    public static implicit operator Vector4(num.Vector<double> v) => new(v[0], v[1], v[2], v[3]);

    public static implicit operator Vector4(num.Vector<float> v) => new(v[0], v[1], v[2], v[3]);

    public static implicit operator Vector4(num.Vector<long> v) => new(v[0], v[1], v[2], v[3]);

    public static implicit operator Vector4(num.Vector<int> v) => new(v[0], v[1], v[2], v[3]);

    public static implicit operator Scalar[](in Vector4 v) => v.Coefficients;

    public static explicit operator Vector4(Scalar[] arr) => new(arr);

    public static explicit operator Vector4(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3) (in Vector4 v) => (v._0, v._1, v._2, v._3);

    public static implicit operator Vector4((Scalar x0, Scalar x1, Scalar x2, Scalar x3) t) => new(t.x0, t.x1, t.x2, t.x3);

    public static implicit operator (Scalar x0, Vector3 v1)(in Vector4 v) => (v._0, (v._1, v._2, v._3));

    public static implicit operator (Vector3 v0, Scalar x1)(in Vector4 v) => ((v._0, v._1, v._2), v._3);

    public static implicit operator Polynomial(in Vector4 v) => v.ToPolynomial();

    public static explicit operator Vector4(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector4 v) => new(v.ToArray());

    public static explicit operator Vector4(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector4EqualityComparer
        : IEqualityComparer<Vector4>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector4 x, Vector4 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector4 obj) => obj.GetHashCode();
    }
}

public static class Vector4Extensions
{
    public static Vector4 Sum(this IEnumerable<Vector4> vectors) => Vector4.Zero.Add(vectors.ToArray());

    public static Vector4 Average(this IEnumerable<Vector4> vectors)
    {
        Vector4 vec = Vector4.Zero;
        long count = 0;

        foreach (Vector4 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector5

/// <summary>
/// Represents a 5-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector5(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4)
    : Algebra<Scalar>.IVector<Vector5, Matrix5>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector5>
    , IEnumerable<Scalar>
    , IComparable<Vector5>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector5>
    , IModulusOperators<Vector5, Scalar, Vector5>
    , IMultiplyOperators<Vector5, Vector5, Scalar>
    , IMultiplyOperators<Vector5, Scalar, Vector5>
    , IDivisionOperators<Vector5, Scalar, Vector5>
    , IMultiplyOperators<Scalar, Vector5, Vector5>
    , IDecrementOperators<Vector5>
    , IAdditionOperators<Vector5, Vector5, Vector5>
    , ISubtractionOperators<Vector5, Vector5, Vector5>
    , IUnaryPlusOperators<Vector5, Vector5>
    , IUnaryNegationOperators<Vector5, Vector5>
    , IAdditiveIdentity<Vector5, Vector5>
    , IMultiplicativeIdentity<Vector5, Vector5>
    , IComparisonOperators<Vector5, Vector5>
    , IEqualityOperators<Vector5, Vector5>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 5;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector5 Zero { get; } = new(0);

    public static Vector5[] UnitVectors { get; } = Matrix5.Identity.Columns;

    /// <summary>
    /// The unit vector in X-direction
    /// </summary>
    public static Vector5 UnitX { get; } = (1, 0, 0, 0, 0);

    /// <summary>
    /// The unit vector in Y-direction
    /// </summary>
    public static Vector5 UnitY { get; } = (0, 1, 0, 0, 0);

    /// <summary>
    /// The unit vector in Z-direction
    /// </summary>
    public static Vector5 UnitZ { get; } = (0, 0, 1, 0, 0);

    /// <summary>
    /// The unit vector in W-direction
    /// </summary>
    public static Vector5 UnitW { get; } = (0, 0, 0, 1, 0);

    /// <summary>
    /// The unit vector in V-direction
    /// </summary>
    public static Vector5 UnitV { get; } = (0, 0, 0, 0, 1);

    /// <summary>
    /// The raw memory size of the <see cref="Vector5"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector5);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector5"/>.
    /// </summary>
    public static Vector5EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace5 UnitSpace { get; } = VectorSpace5.FromMatrixColumns(Matrix5.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(5)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector5 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector5 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <summary>
    /// Returns the vector's X-coefficient (Index = 0).
    /// </summary>
    public readonly Scalar X => _0;

    /// <summary>
    /// Returns the vector's Y-coefficient (Index = 1).
    /// </summary>
    public readonly Scalar Y => _1;

    /// <summary>
    /// Returns the vector's Z-coefficient (Index = 2).
    /// </summary>
    public readonly Scalar Z => _2;

    /// <summary>
    /// Returns the vector's W-coefficient (Index = 3).
    /// </summary>
    public readonly Scalar W => _3;

    /// <summary>
    /// Returns the vector's V-coefficient (Index = 4).
    /// </summary>
    public readonly Scalar V => _4;

    /// <summary>
    /// Returns the combination of the vector's XY-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XY => new(X, Y);

    /// <summary>
    /// Returns the combination of the vector's XZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XZ => new(X, Z);

    /// <summary>
    /// Returns the combination of the vector's YZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YZ => new(Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XW => new(X, W);

    /// <summary>
    /// Returns the combination of the vector's YW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YW => new(Y, W);

    /// <summary>
    /// Returns the combination of the vector's ZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZW => new(Z, W);

    /// <summary>
    /// Returns the combination of the vector's XV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XV => new(X, V);

    /// <summary>
    /// Returns the combination of the vector's YV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YV => new(Y, V);

    /// <summary>
    /// Returns the combination of the vector's ZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZV => new(Z, V);

    /// <summary>
    /// Returns the combination of the vector's WV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 WV => new(W, V);

    /// <summary>
    /// Returns the combination of the vector's XYZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYZ => new(X, Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XYW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYW => new(X, Y, W);

    /// <summary>
    /// Returns the combination of the vector's XZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZW => new(X, Z, W);

    /// <summary>
    /// Returns the combination of the vector's YZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZW => new(Y, Z, W);

    /// <summary>
    /// Returns the combination of the vector's XYV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYV => new(X, Y, V);

    /// <summary>
    /// Returns the combination of the vector's XZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZV => new(X, Z, V);

    /// <summary>
    /// Returns the combination of the vector's YZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZV => new(Y, Z, V);

    /// <summary>
    /// Returns the combination of the vector's XWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XWV => new(X, W, V);

    /// <summary>
    /// Returns the combination of the vector's YWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YWV => new(Y, W, V);

    /// <summary>
    /// Returns the combination of the vector's ZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 ZWV => new(Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's XYZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYZW => new(X, Y, Z, W);

    /// <summary>
    /// Returns the combination of the vector's XYZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYZV => new(X, Y, Z, V);

    /// <summary>
    /// Returns the combination of the vector's XYWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYWV => new(X, Y, W, V);

    /// <summary>
    /// Returns the combination of the vector's XZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XZWV => new(X, Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's YZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 YZWV => new(Y, Z, W, V);

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(5, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector5 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector5 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix5 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 5-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector5(Scalar s = default)
        : this(s, s, s, s, s)
    {
    }

    public Vector5(Scalar* values)
        : this((Vector5*)values)
    {
    }

    public Vector5(Vector5* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 5-dimensional one
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    public Vector5(in Vector5 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 6-dimensional one
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector5(in Vector6 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector5(in Vector7 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector5(in Vector8 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector5(in Vector9 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector5(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 4-dimensional one.
    /// </summary>
    /// <param name="v">The 4-dimensional vector</param>
    public Vector5(in Vector4 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given 4-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 4-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector5(in Vector4 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], c)
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector5(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[5])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector5(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4])
    {
    }

    /// <summary>
    /// Creates a new 5-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector5(IEnumerable<double>? v)
        : this((v ?? new double[5]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector5 Negate() => new(-_0, -_1, -_2, -_3, -_4);

    public readonly Vector5 Add(in Vector5 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4);

    public readonly Vector5 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4);

    public readonly Vector5 Add(params Vector5[] others) => others.Aggregate(this, Add);

    public readonly Vector5 MoveBy(in Vector5 second) => Add(in second);

    public readonly Vector5 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => Add(s0, s1, s2, s3, s4);

    public readonly Vector5 Subtract(in Vector5 second) => Add(second.AdditiveInverse);

    public readonly Vector5 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4);

    public readonly Vector5 Subtract(params Vector5[] others) => others.Aggregate(this, Subtract);

    public readonly Vector5 Increment() => Add(new Vector5(1));

    public readonly Vector5 Decrement() => Subtract(new Vector5(1));

    public readonly Vector5 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor);

    public readonly Vector5 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector5 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector5 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector5 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        _ => throw new InvalidOperationException($"A vector of the type 'Vector5' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix5 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector5 ComponentwiseMultiply(in Vector5 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4);

    public readonly Vector5 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4);

    public readonly Vector5 ComponentwiseDivide(in Vector5 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4);

    public readonly Vector5 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4);

    public readonly Vector5 ComponentwiseModulus(in Vector5 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4);

    public readonly Vector5 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4);

    readonly Vector5 Algebra<Scalar>.IVectorSpace<Vector5>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar);

    public readonly Vector5 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs());

    public readonly Vector5 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt());

    public readonly Vector5 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4));

    public readonly Vector5 ComponentwiseApply(Vector5 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4));

    public readonly Vector5 ComponentwiseApply(Vector5 second, Vector5 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4));

    public readonly Vector5 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector5 r = (1, 1, 1, 1, 1);
        Vector5 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector5 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector5 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 5; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector5 LinearInterpolate(in Vector5 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector5 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector5 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector5 second) => Dot(second).Acos();

    public readonly Matrix5 OuterProduct(in Vector5 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4
    );

    /// <summary>
    /// Returns the vector' 4D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>4D-minor</returns>
    public readonly Vector4 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector4(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector5 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector5 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector5 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector5)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector5(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4) => (x0, x1, x2, x3, x4) = (_0, _1, _2, _3, _4);

    // public readonly void Deconstruct(out Scalar x0, out Vector4 v1) => (x0, v1) = (_0, (_1, _2, _3, _4));
    //
    // public readonly void Deconstruct(out Vector4 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3), _4);

    public readonly bool Is(Vector5 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance);

    public readonly bool Is(Vector5 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector5 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector5 second) => Dot(second).IsZero;

    public readonly Vector5 Reflect(in Vector5 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector5 normal, Scalar eta, out Vector5 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector5 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector5 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector4 FromHomogeneousCoordinates() => new(_0 / _4, _1 / _4, _2 / _4, _3 / _4);

    public readonly Vector6 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, _4, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector5 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(5);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector5 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector5 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector5(v[0], v[1], v[2], v[3], v[4])
    };

    public static Vector5 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector5 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector5 FromHomogeneousCoordinates(Vector6 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector5 Add(Vector5 m1, Vector5 m2) => m1.Add(m2);

    public static Vector5 Subtract(Vector5 m1, Vector5 m2) => m1.Subtract(m2);

    public static Vector5 Multiply(Vector5 m, Scalar s) => m.Multiply(s);

    public static Vector5 Divide(Vector5 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector5 v1, in Vector5 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector5 v1, in Vector5 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector5 v1, in Vector5 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix5 OuterProduct(in Vector5 v1, in Vector5 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector5 LinearInterpolate(in Vector5 v1, in Vector5 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector5, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector5 v1, in Vector5 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector5 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector5(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector5 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector5 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 5)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 4.");

        Scalar[] coeff = new Scalar[5];

        coeff[n] = Scalar.One;

        return new Vector5(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector5 first, Vector5 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector5 first, Vector5 second) => first.IsNot(second);

    public static bool operator true(Vector5 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector5 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector5 v1, in Vector5 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector5 v1, in Vector5 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector5 v1, in Vector5 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector5 v1, in Vector5 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector5 operator ~(in Vector5 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector5 operator -(in Vector5 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector5 operator +(in Vector5 v) => v;

    public static Vector5 operator ++(in Vector5 v) => v.Increment();

    public static Vector5 operator --(in Vector5 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector5 operator +(in Vector5 v1, in Vector5 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector5 operator +(in Vector5 v, Scalar f) => v + new Vector5(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector5 operator +(Scalar f, in Vector5 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector5 operator -(in Vector5 v1, in Vector5 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector5 operator -(in Vector5 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector5 operator -(Scalar f, in Vector5 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector5 operator *(in Vector5 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector5 operator *(Scalar f, in Vector5 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector5 v1, in Vector5 v2) => v1.Dot(in v2);

    public static Vector5 operator ^(in Vector5 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector5 operator /(in Vector5 v, Scalar f) => v.Divide(f);

    public static Vector5 operator /(Scalar f, in Vector5 v) => new Vector5(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector5 v1, in Vector5 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector5 operator %(in Vector5 v, Scalar f) => v.Modulus(f);

    public static Vector5 operator %(in Vector5 v1, in Vector5 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector5 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector5 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector5 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector5 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector5 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector5(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4]);

    public static implicit operator Vector5(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4]);

    public static implicit operator Vector5(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4]);

    public static implicit operator Vector5(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4]);

    public static implicit operator Vector5(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4]);

    public static implicit operator Scalar[](in Vector5 v) => v.Coefficients;

    public static explicit operator Vector5(Scalar[] arr) => new(arr);

    public static explicit operator Vector5(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4) (in Vector5 v) => (v._0, v._1, v._2, v._3, v._4);

    public static implicit operator Vector5((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4);

    public static implicit operator (Scalar x0, Vector4 v1)(in Vector5 v) => (v._0, (v._1, v._2, v._3, v._4));

    public static implicit operator (Vector4 v0, Scalar x1)(in Vector5 v) => ((v._0, v._1, v._2, v._3), v._4);

    public static implicit operator Polynomial(in Vector5 v) => v.ToPolynomial();

    public static explicit operator Vector5(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector5 v) => new(v.ToArray());

    public static explicit operator Vector5(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector5EqualityComparer
        : IEqualityComparer<Vector5>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector5 x, Vector5 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector5 obj) => obj.GetHashCode();
    }
}

public static class Vector5Extensions
{
    public static Vector5 Sum(this IEnumerable<Vector5> vectors) => Vector5.Zero.Add(vectors.ToArray());

    public static Vector5 Average(this IEnumerable<Vector5> vectors)
    {
        Vector5 vec = Vector5.Zero;
        long count = 0;

        foreach (Vector5 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector6

/// <summary>
/// Represents a 6-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector6(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5)
    : Algebra<Scalar>.IVector<Vector6, Matrix6>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector6>
    , IEnumerable<Scalar>
    , IComparable<Vector6>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector6>
    , IModulusOperators<Vector6, Scalar, Vector6>
    , IMultiplyOperators<Vector6, Vector6, Scalar>
    , IMultiplyOperators<Vector6, Scalar, Vector6>
    , IDivisionOperators<Vector6, Scalar, Vector6>
    , IMultiplyOperators<Scalar, Vector6, Vector6>
    , IDecrementOperators<Vector6>
    , IAdditionOperators<Vector6, Vector6, Vector6>
    , ISubtractionOperators<Vector6, Vector6, Vector6>
    , IUnaryPlusOperators<Vector6, Vector6>
    , IUnaryNegationOperators<Vector6, Vector6>
    , IAdditiveIdentity<Vector6, Vector6>
    , IMultiplicativeIdentity<Vector6, Vector6>
    , IComparisonOperators<Vector6, Vector6>
    , IEqualityOperators<Vector6, Vector6>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;
    private readonly Scalar _5 = x5;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 6;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector6 Zero { get; } = new(0);

    public static Vector6[] UnitVectors { get; } = Matrix6.Identity.Columns;

    /// <summary>
    /// The unit vector in X-direction
    /// </summary>
    public static Vector6 UnitX { get; } = (1, 0, 0, 0, 0, 0);

    /// <summary>
    /// The unit vector in Y-direction
    /// </summary>
    public static Vector6 UnitY { get; } = (0, 1, 0, 0, 0, 0);

    /// <summary>
    /// The unit vector in Z-direction
    /// </summary>
    public static Vector6 UnitZ { get; } = (0, 0, 1, 0, 0, 0);

    /// <summary>
    /// The unit vector in W-direction
    /// </summary>
    public static Vector6 UnitW { get; } = (0, 0, 0, 1, 0, 0);

    /// <summary>
    /// The unit vector in V-direction
    /// </summary>
    public static Vector6 UnitV { get; } = (0, 0, 0, 0, 1, 0);

    /// <summary>
    /// The unit vector in U-direction
    /// </summary>
    public static Vector6 UnitU { get; } = (0, 0, 0, 0, 0, 1);

    /// <summary>
    /// The raw memory size of the <see cref="Vector6"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector6);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector6"/>.
    /// </summary>
    public static Vector6EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace6 UnitSpace { get; } = VectorSpace6.FromMatrixColumns(Matrix6.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        5 => _5,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(6)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector6 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector6 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <summary>
    /// Returns the vector's X-coefficient (Index = 0).
    /// </summary>
    public readonly Scalar X => _0;

    /// <summary>
    /// Returns the vector's Y-coefficient (Index = 1).
    /// </summary>
    public readonly Scalar Y => _1;

    /// <summary>
    /// Returns the vector's Z-coefficient (Index = 2).
    /// </summary>
    public readonly Scalar Z => _2;

    /// <summary>
    /// Returns the vector's W-coefficient (Index = 3).
    /// </summary>
    public readonly Scalar W => _3;

    /// <summary>
    /// Returns the vector's V-coefficient (Index = 4).
    /// </summary>
    public readonly Scalar V => _4;

    /// <summary>
    /// Returns the vector's U-coefficient (Index = 5).
    /// </summary>
    public readonly Scalar U => _5;

    /// <summary>
    /// Returns the combination of the vector's XY-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XY => new(X, Y);

    /// <summary>
    /// Returns the combination of the vector's XZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XZ => new(X, Z);

    /// <summary>
    /// Returns the combination of the vector's YZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YZ => new(Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XW => new(X, W);

    /// <summary>
    /// Returns the combination of the vector's YW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YW => new(Y, W);

    /// <summary>
    /// Returns the combination of the vector's ZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZW => new(Z, W);

    /// <summary>
    /// Returns the combination of the vector's XV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XV => new(X, V);

    /// <summary>
    /// Returns the combination of the vector's YV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YV => new(Y, V);

    /// <summary>
    /// Returns the combination of the vector's ZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZV => new(Z, V);

    /// <summary>
    /// Returns the combination of the vector's WV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 WV => new(W, V);

    /// <summary>
    /// Returns the combination of the vector's XU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 XU => new(X, U);

    /// <summary>
    /// Returns the combination of the vector's YU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 YU => new(Y, U);

    /// <summary>
    /// Returns the combination of the vector's ZU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 ZU => new(Z, U);

    /// <summary>
    /// Returns the combination of the vector's WU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 WU => new(W, U);

    /// <summary>
    /// Returns the combination of the vector's VU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector2 VU => new(V, U);

    /// <summary>
    /// Returns the combination of the vector's XYZ-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYZ => new(X, Y, Z);

    /// <summary>
    /// Returns the combination of the vector's XYW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYW => new(X, Y, W);

    /// <summary>
    /// Returns the combination of the vector's XZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZW => new(X, Z, W);

    /// <summary>
    /// Returns the combination of the vector's YZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZW => new(Y, Z, W);

    /// <summary>
    /// Returns the combination of the vector's XYV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYV => new(X, Y, V);

    /// <summary>
    /// Returns the combination of the vector's XZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZV => new(X, Z, V);

    /// <summary>
    /// Returns the combination of the vector's YZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZV => new(Y, Z, V);

    /// <summary>
    /// Returns the combination of the vector's XWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XWV => new(X, W, V);

    /// <summary>
    /// Returns the combination of the vector's YWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YWV => new(Y, W, V);

    /// <summary>
    /// Returns the combination of the vector's ZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 ZWV => new(Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's XYU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XYU => new(X, Y, U);

    /// <summary>
    /// Returns the combination of the vector's XZU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XZU => new(X, Z, U);

    /// <summary>
    /// Returns the combination of the vector's YZU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YZU => new(Y, Z, U);

    /// <summary>
    /// Returns the combination of the vector's XWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XWU => new(X, W, U);

    /// <summary>
    /// Returns the combination of the vector's YWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YWU => new(Y, W, U);

    /// <summary>
    /// Returns the combination of the vector's ZWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 ZWU => new(Z, W, U);

    /// <summary>
    /// Returns the combination of the vector's XVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 XVU => new(X, V, U);

    /// <summary>
    /// Returns the combination of the vector's YVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 YVU => new(Y, V, U);

    /// <summary>
    /// Returns the combination of the vector's ZVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 ZVU => new(Z, V, U);

    /// <summary>
    /// Returns the combination of the vector's WVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector3 WVU => new(W, V, U);

    /// <summary>
    /// Returns the combination of the vector's XYZW-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYZW => new(X, Y, Z, W);

    /// <summary>
    /// Returns the combination of the vector's XYZV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYZV => new(X, Y, Z, V);

    /// <summary>
    /// Returns the combination of the vector's XYWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYWV => new(X, Y, W, V);

    /// <summary>
    /// Returns the combination of the vector's XZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XZWV => new(X, Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's YZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 YZWV => new(Y, Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's XYZU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYZU => new(X, Y, Z, U);

    /// <summary>
    /// Returns the combination of the vector's XYWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYWU => new(X, Y, W, U);

    /// <summary>
    /// Returns the combination of the vector's XZWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XZWU => new(X, Z, W, U);

    /// <summary>
    /// Returns the combination of the vector's YZWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 YZWU => new(Y, Z, W, U);

    /// <summary>
    /// Returns the combination of the vector's XYVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XYVU => new(X, Y, V, U);

    /// <summary>
    /// Returns the combination of the vector's XZVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XZVU => new(X, Z, V, U);

    /// <summary>
    /// Returns the combination of the vector's YZVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 YZVU => new(Y, Z, V, U);

    /// <summary>
    /// Returns the combination of the vector's XWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 XWVU => new(X, W, V, U);

    /// <summary>
    /// Returns the combination of the vector's YWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 YWVU => new(Y, W, V, U);

    /// <summary>
    /// Returns the combination of the vector's ZWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector4 ZWVU => new(Z, W, V, U);

    /// <summary>
    /// Returns the combination of the vector's XYZWV-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 XYZWV => new(X, Y, Z, W, V);

    /// <summary>
    /// Returns the combination of the vector's XYZWU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 XYZWU => new(X, Y, Z, W, U);

    /// <summary>
    /// Returns the combination of the vector's XYZVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 XYZVU => new(X, Y, Z, V, U);

    /// <summary>
    /// Returns the combination of the vector's XYWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 XYWVU => new(X, Y, W, V, U);

    /// <summary>
    /// Returns the combination of the vector's XZWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 XZWVU => new(X, Z, W, V, U);

    /// <summary>
    /// Returns the combination of the vector's YZWVU-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector5 YZWVU => new(Y, Z, W, V, U);

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(6, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4, _5 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector6 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary && _5.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4 + _5;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector6 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix6 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 6-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector6(Scalar s = default)
        : this(s, s, s, s, s, s)
    {
    }

    public Vector6(Scalar* values)
        : this((Vector6*)values)
    {
    }

    public Vector6(Vector6* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 6-dimensional one
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector6(in Vector6 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector6(in Vector7 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector6(in Vector8 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector6(in Vector9 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector6(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 5-dimensional one.
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    public Vector6(in Vector5 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given 5-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 5-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector6(in Vector5 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], v[4], c)
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector6(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[6])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector6(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5])
    {
    }

    /// <summary>
    /// Creates a new 6-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector6(IEnumerable<double>? v)
        : this((v ?? new double[6]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector6 Negate() => new(-_0, -_1, -_2, -_3, -_4, -_5);

    public readonly Vector6 Add(in Vector6 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4, _5 + second._5);

    public readonly Vector6 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4, _5 + s5);

    public readonly Vector6 Add(params Vector6[] others) => others.Aggregate(this, Add);

    public readonly Vector6 MoveBy(in Vector6 second) => Add(in second);

    public readonly Vector6 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => Add(s0, s1, s2, s3, s4, s5);

    public readonly Vector6 Subtract(in Vector6 second) => Add(second.AdditiveInverse);

    public readonly Vector6 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4, _5 - s5);

    public readonly Vector6 Subtract(params Vector6[] others) => others.Aggregate(this, Subtract);

    public readonly Vector6 Increment() => Add(new Vector6(1));

    public readonly Vector6 Decrement() => Subtract(new Vector6(1));

    public readonly Vector6 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor, _5 * factor);

    public readonly Vector6 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector6 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector6 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector6 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor, _5 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        VectorNorm.UCoordinate => _5.Abs(),
        _ => throw new InvalidOperationException($"A vector of the type 'Vector6' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix6 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector6 ComponentwiseMultiply(in Vector6 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5);

    public readonly Vector6 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4, _5 * s5);

    public readonly Vector6 ComponentwiseDivide(in Vector6 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4, _5 / second._5);

    public readonly Vector6 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4, _5 / s5);

    public readonly Vector6 ComponentwiseModulus(in Vector6 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4, _5 % second._5);

    public readonly Vector6 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4, _5 % s5);

    readonly Vector6 Algebra<Scalar>.IVectorSpace<Vector6>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar, scalar);

    public readonly Vector6 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs(), _5.Abs());

    public readonly Vector6 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt(), _5.Sqrt());

    public readonly Vector6 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4), function(_5));

    public readonly Vector6 ComponentwiseApply(Vector6 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4), function(_5, second._5));

    public readonly Vector6 ComponentwiseApply(Vector6 second, Vector6 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4), function(_5, second._5, third._5));

    public readonly Vector6 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector6 r = (1, 1, 1, 1, 1, 1);
        Vector6 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector6 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector6 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 6; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector6 LinearInterpolate(in Vector6 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector6 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector6 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high), _5.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector6 second) => Dot(second).Acos();

    public readonly Matrix6 OuterProduct(in Vector6 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5
    );

    /// <summary>
    /// Returns the vector' 5D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>5D-minor</returns>
    public readonly Vector5 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector5(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector6 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector6 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ", ", _5.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector6 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector6)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
        yield return _5;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector6(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4, out Scalar x5) => (x0, x1, x2, x3, x4, x5) = (_0, _1, _2, _3, _4, _5);

    // public readonly void Deconstruct(out Scalar x0, out Vector5 v1) => (x0, v1) = (_0, (_1, _2, _3, _4, _5));
    //
    // public readonly void Deconstruct(out Vector5 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3, _4), _5);

    public readonly bool Is(Vector6 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance) && _5.Is(o._5, tolerance);

    public readonly bool Is(Vector6 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector6 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector6 second) => Dot(second).IsZero;

    public readonly Vector6 Reflect(in Vector6 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector6 normal, Scalar eta, out Vector6 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector6 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector6 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector5 FromHomogeneousCoordinates() => new(_0 / _5, _1 / _5, _2 / _5, _3 / _5, _4 / _5);

    public readonly Vector7 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, _4, _5, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector6 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(6);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector6 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector6 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector6(v[0], v[1], v[2], v[3], v[4], v[5])
    };

    public static Vector6 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector6 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector6 FromHomogeneousCoordinates(Vector7 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector6 Add(Vector6 m1, Vector6 m2) => m1.Add(m2);

    public static Vector6 Subtract(Vector6 m1, Vector6 m2) => m1.Subtract(m2);

    public static Vector6 Multiply(Vector6 m, Scalar s) => m.Multiply(s);

    public static Vector6 Divide(Vector6 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector6 v1, in Vector6 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector6 v1, in Vector6 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector6 v1, in Vector6 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix6 OuterProduct(in Vector6 v1, in Vector6 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector6 LinearInterpolate(in Vector6 v1, in Vector6 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector6, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector6 v1, in Vector6 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector6 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector6(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector6 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector6 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 6)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 5.");

        Scalar[] coeff = new Scalar[6];

        coeff[n] = Scalar.One;

        return new Vector6(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector6 first, Vector6 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector6 first, Vector6 second) => first.IsNot(second);

    public static bool operator true(Vector6 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector6 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector6 v1, in Vector6 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector6 v1, in Vector6 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector6 v1, in Vector6 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector6 v1, in Vector6 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector6 operator ~(in Vector6 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector6 operator -(in Vector6 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector6 operator +(in Vector6 v) => v;

    public static Vector6 operator ++(in Vector6 v) => v.Increment();

    public static Vector6 operator --(in Vector6 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector6 operator +(in Vector6 v1, in Vector6 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector6 operator +(in Vector6 v, Scalar f) => v + new Vector6(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector6 operator +(Scalar f, in Vector6 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector6 operator -(in Vector6 v1, in Vector6 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector6 operator -(in Vector6 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector6 operator -(Scalar f, in Vector6 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector6 operator *(in Vector6 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector6 operator *(Scalar f, in Vector6 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector6 v1, in Vector6 v2) => v1.Dot(in v2);

    public static Vector6 operator ^(in Vector6 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector6 operator /(in Vector6 v, Scalar f) => v.Divide(f);

    public static Vector6 operator /(Scalar f, in Vector6 v) => new Vector6(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector6 v1, in Vector6 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector6 operator %(in Vector6 v, Scalar f) => v.Modulus(f);

    public static Vector6 operator %(in Vector6 v1, in Vector6 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector6 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector6 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector6 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector6 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector6 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector6(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4], v[5]);

    public static implicit operator Vector6(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4], v[5]);

    public static implicit operator Vector6(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4], v[5]);

    public static implicit operator Vector6(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4], v[5]);

    public static implicit operator Vector6(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4], v[5]);

    public static implicit operator Scalar[](in Vector6 v) => v.Coefficients;

    public static explicit operator Vector6(Scalar[] arr) => new(arr);

    public static explicit operator Vector6(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5) (in Vector6 v) => (v._0, v._1, v._2, v._3, v._4, v._5);

    public static implicit operator Vector6((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5);

    public static implicit operator (Scalar x0, Vector5 v1)(in Vector6 v) => (v._0, (v._1, v._2, v._3, v._4, v._5));

    public static implicit operator (Vector5 v0, Scalar x1)(in Vector6 v) => ((v._0, v._1, v._2, v._3, v._4), v._5);

    public static implicit operator Polynomial(in Vector6 v) => v.ToPolynomial();

    public static explicit operator Vector6(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector6 v) => new(v.ToArray());

    public static explicit operator Vector6(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector6EqualityComparer
        : IEqualityComparer<Vector6>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector6 x, Vector6 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector6 obj) => obj.GetHashCode();
    }
}

public static class Vector6Extensions
{
    public static Vector6 Sum(this IEnumerable<Vector6> vectors) => Vector6.Zero.Add(vectors.ToArray());

    public static Vector6 Average(this IEnumerable<Vector6> vectors)
    {
        Vector6 vec = Vector6.Zero;
        long count = 0;

        foreach (Vector6 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector7

/// <summary>
/// Represents a crossable 7-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector7(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6)
    : Algebra<Scalar>.IVector<Vector7, Matrix7>
    , Algebra<Scalar>.ICrossableVector<Vector7>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector7>
    , IEnumerable<Scalar>
    , IComparable<Vector7>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector7>
    , IModulusOperators<Vector7, Scalar, Vector7>
    , IMultiplyOperators<Vector7, Vector7, Scalar>
    , IMultiplyOperators<Vector7, Scalar, Vector7>
    , IDivisionOperators<Vector7, Scalar, Vector7>
    , IMultiplyOperators<Scalar, Vector7, Vector7>
    , IDecrementOperators<Vector7>
    , IAdditionOperators<Vector7, Vector7, Vector7>
    , ISubtractionOperators<Vector7, Vector7, Vector7>
    , IUnaryPlusOperators<Vector7, Vector7>
    , IUnaryNegationOperators<Vector7, Vector7>
    , IAdditiveIdentity<Vector7, Vector7>
    , IMultiplicativeIdentity<Vector7, Vector7>
    , IComparisonOperators<Vector7, Vector7>
    , IEqualityOperators<Vector7, Vector7>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;
    private readonly Scalar _5 = x5;
    private readonly Scalar _6 = x6;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 7;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector7 Zero { get; } = new(0);

    public static Vector7[] UnitVectors { get; } = Matrix7.Identity.Columns;

    /// <summary>
    /// The raw memory size of the <see cref="Vector7"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector7);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector7"/>.
    /// </summary>
    public static Vector7EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace7 UnitSpace { get; } = VectorSpace7.FromMatrixColumns(Matrix7.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        5 => _5,
        6 => _6,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(7)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector7 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector7 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(7, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4, _5, _6 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector7 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary && _5.IsBinary && _6.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4 + _5 + _6;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector7 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix7 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 7-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector7(Scalar s = default)
        : this(s, s, s, s, s, s, s)
    {
    }

    public Vector7(Scalar* values)
        : this((Vector7*)values)
    {
    }

    public Vector7(Vector7* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 7-dimensional one
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector7(in Vector7 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector7(in Vector8 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector7(in Vector9 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector7(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 6-dimensional one.
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    public Vector7(in Vector6 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given 6-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 6-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector7(in Vector6 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], c)
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector7(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[7])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector7(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    {
    }

    /// <summary>
    /// Creates a new 7-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector7(IEnumerable<double>? v)
        : this((v ?? new double[7]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector7 Negate() => new(-_0, -_1, -_2, -_3, -_4, -_5, -_6);

    public readonly Vector7 Add(in Vector7 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4, _5 + second._5, _6 + second._6);

    public readonly Vector7 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4, _5 + s5, _6 + s6);

    public readonly Vector7 Add(params Vector7[] others) => others.Aggregate(this, Add);

    public readonly Vector7 MoveBy(in Vector7 second) => Add(in second);

    public readonly Vector7 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => Add(s0, s1, s2, s3, s4, s5, s6);

    public readonly Vector7 Subtract(in Vector7 second) => Add(second.AdditiveInverse);

    public readonly Vector7 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4, _5 - s5, _6 - s6);

    public readonly Vector7 Subtract(params Vector7[] others) => others.Aggregate(this, Subtract);

    public readonly Vector7 Increment() => Add(new Vector7(1));

    public readonly Vector7 Decrement() => Subtract(new Vector7(1));

    public readonly Vector7 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor, _5 * factor, _6 * factor);

    public readonly Vector7 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector7 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector7 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector7 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor, _5 % factor, _6 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        VectorNorm.UCoordinate => _5.Abs(),
        // VectorNorm.7 => ,
        _ => throw new InvalidOperationException($"A vector of the type 'Vector7' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix7 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector7 ComponentwiseMultiply(in Vector7 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6);

    public readonly Vector7 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4, _5 * s5, _6 * s6);

    public readonly Vector7 ComponentwiseDivide(in Vector7 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4, _5 / second._5, _6 / second._6);

    public readonly Vector7 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4, _5 / s5, _6 / s6);

    public readonly Vector7 ComponentwiseModulus(in Vector7 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4, _5 % second._5, _6 % second._6);

    public readonly Vector7 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4, _5 % s5, _6 % s6);

    readonly Vector7 Algebra<Scalar>.IVectorSpace<Vector7>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar, scalar, scalar);

    public readonly Vector7 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs(), _5.Abs(), _6.Abs());

    public readonly Vector7 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt(), _5.Sqrt(), _6.Sqrt());

    public readonly Vector7 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4), function(_5), function(_6));

    public readonly Vector7 ComponentwiseApply(Vector7 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4), function(_5, second._5), function(_6, second._6));

    public readonly Vector7 ComponentwiseApply(Vector7 second, Vector7 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4), function(_5, second._5, third._5), function(_6, second._6, third._6));

    public readonly Vector7 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector7 r = (1, 1, 1, 1, 1, 1, 1);
        Vector7 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector7 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly Vector7 Cross(in Vector7 v) => Cross(this, v);

    public readonly Scalar TripleProduct(in Vector7 b, in Vector7 c) => TripleProduct(this, b, c);

    public readonly bool IsLinearDependant(in Vector7 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 7; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector7 LinearInterpolate(in Vector7 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector7 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector7 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high), _5.Clamp(low, high), _6.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector7 second) => Dot(second).Acos();

    public readonly Matrix7 OuterProduct(in Vector7 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6
    );

    /// <summary>
    /// Returns the vector' 6D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>6D-minor</returns>
    public readonly Vector6 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector6(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector7 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector7 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ", ", _5.ToString(format, prov), ", ", _6.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector7 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector7)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
        yield return _5;
        yield return _6;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector7(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4, out Scalar x5, out Scalar x6) => (x0, x1, x2, x3, x4, x5, x6) = (_0, _1, _2, _3, _4, _5, _6);

    // public readonly void Deconstruct(out Scalar x0, out Vector6 v1) => (x0, v1) = (_0, (_1, _2, _3, _4, _5, _6));
    //
    // public readonly void Deconstruct(out Vector6 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3, _4, _5), _6);

    public readonly bool Is(Vector7 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance) && _5.Is(o._5, tolerance) && _6.Is(o._6, tolerance);

    public readonly bool Is(Vector7 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector7 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector7 second) => Dot(second).IsZero;

    public readonly Vector7 Reflect(in Vector7 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector7 normal, Scalar eta, out Vector7 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector7 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector7 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector6 FromHomogeneousCoordinates() => new(_0 / _6, _1 / _6, _2 / _6, _3 / _6, _4 / _6, _5 / _6);

    public readonly Vector8 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, _4, _5, _6, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector7 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(7);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector7 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    /// <inheritdoc cref="ICrossableVector{V, S}.Cross(V)"/>
    public static Vector7 Cross(in Vector7 x, in Vector7 y)
    {
        var (a, b, c, d, e, f, g) = x;
        Matrix7 T = (
            0, -d, -g, b, -f, e, c,
            d, 0, -e, -a, c, -g, f,
            g, e, 0, -f, -b, d, -a,
            -b, a, f, 0, -g, -c, e,
            f, -c, b, g, 0, -a, -d,
            -e, g, -d, c, a, 0, -b,
            -c, -f, a, -e, d, b, 0
        );

        return T * y;
    }

    /// <inheritdoc cref="ICrossableVector{V, S}.TripleProduct(V, V)"/>
    public static Scalar TripleProduct(in Vector7 a, in Vector7 b, in Vector7 c) => Dot(a, Cross(b, c));

    public static Vector7 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector7(v[0], v[1], v[2], v[3], v[4], v[5], v[6])
    };

    public static Vector7 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector7 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector7 FromHomogeneousCoordinates(Vector8 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector7 Add(Vector7 m1, Vector7 m2) => m1.Add(m2);

    public static Vector7 Subtract(Vector7 m1, Vector7 m2) => m1.Subtract(m2);

    public static Vector7 Multiply(Vector7 m, Scalar s) => m.Multiply(s);

    public static Vector7 Divide(Vector7 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector7 v1, in Vector7 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector7 v1, in Vector7 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector7 v1, in Vector7 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix7 OuterProduct(in Vector7 v1, in Vector7 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector7 LinearInterpolate(in Vector7 v1, in Vector7 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector7, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector7 v1, in Vector7 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector7 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector7(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector7 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector7 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 7)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 6.");

        Scalar[] coeff = new Scalar[7];

        coeff[n] = Scalar.One;

        return new Vector7(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector7 first, Vector7 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector7 first, Vector7 second) => first.IsNot(second);

    public static bool operator true(Vector7 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector7 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector7 v1, in Vector7 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector7 v1, in Vector7 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector7 v1, in Vector7 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector7 v1, in Vector7 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector7 operator ~(in Vector7 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector7 operator -(in Vector7 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector7 operator +(in Vector7 v) => v;

    public static Vector7 operator ++(in Vector7 v) => v.Increment();

    public static Vector7 operator --(in Vector7 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector7 operator +(in Vector7 v1, in Vector7 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector7 operator +(in Vector7 v, Scalar f) => v + new Vector7(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector7 operator +(Scalar f, in Vector7 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector7 operator -(in Vector7 v1, in Vector7 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector7 operator -(in Vector7 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector7 operator -(Scalar f, in Vector7 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector7 operator *(in Vector7 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector7 operator *(Scalar f, in Vector7 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector7 v1, in Vector7 v2) => v1.Dot(in v2);

    public static Vector7 operator ^(in Vector7 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector7 operator /(in Vector7 v, Scalar f) => v.Divide(f);

    public static Vector7 operator /(Scalar f, in Vector7 v) => new Vector7(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector7 v1, in Vector7 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector7 operator %(in Vector7 v, Scalar f) => v.Modulus(f);

    public static Vector7 operator %(in Vector7 v1, in Vector7 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector7 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector7 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector7 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector7 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector7 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector7(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);

    public static implicit operator Vector7(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);

    public static implicit operator Vector7(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);

    public static implicit operator Vector7(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);

    public static implicit operator Vector7(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6]);

    public static implicit operator Scalar[](in Vector7 v) => v.Coefficients;

    public static explicit operator Vector7(Scalar[] arr) => new(arr);

    public static explicit operator Vector7(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6) (in Vector7 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6);

    public static implicit operator Vector7((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6);

    public static implicit operator (Scalar x0, Vector6 v1)(in Vector7 v) => (v._0, (v._1, v._2, v._3, v._4, v._5, v._6));

    public static implicit operator (Vector6 v0, Scalar x1)(in Vector7 v) => ((v._0, v._1, v._2, v._3, v._4, v._5), v._6);

    public static implicit operator Polynomial(in Vector7 v) => v.ToPolynomial();

    public static explicit operator Vector7(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector7 v) => new(v.ToArray());

    public static explicit operator Vector7(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector7EqualityComparer
        : IEqualityComparer<Vector7>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector7 x, Vector7 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector7 obj) => obj.GetHashCode();
    }
}

public static class Vector7Extensions
{
    public static Vector7 Sum(this IEnumerable<Vector7> vectors) => Vector7.Zero.Add(vectors.ToArray());

    public static Vector7 Average(this IEnumerable<Vector7> vectors)
    {
        Vector7 vec = Vector7.Zero;
        long count = 0;

        foreach (Vector7 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector8

/// <summary>
/// Represents a 8-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector8(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7)
    : Algebra<Scalar>.IVector<Vector8, Matrix8>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector8>
    , IEnumerable<Scalar>
    , IComparable<Vector8>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector8>
    , IModulusOperators<Vector8, Scalar, Vector8>
    , IMultiplyOperators<Vector8, Vector8, Scalar>
    , IMultiplyOperators<Vector8, Scalar, Vector8>
    , IDivisionOperators<Vector8, Scalar, Vector8>
    , IMultiplyOperators<Scalar, Vector8, Vector8>
    , IDecrementOperators<Vector8>
    , IAdditionOperators<Vector8, Vector8, Vector8>
    , ISubtractionOperators<Vector8, Vector8, Vector8>
    , IUnaryPlusOperators<Vector8, Vector8>
    , IUnaryNegationOperators<Vector8, Vector8>
    , IAdditiveIdentity<Vector8, Vector8>
    , IMultiplicativeIdentity<Vector8, Vector8>
    , IComparisonOperators<Vector8, Vector8>
    , IEqualityOperators<Vector8, Vector8>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;
    private readonly Scalar _5 = x5;
    private readonly Scalar _6 = x6;
    private readonly Scalar _7 = x7;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 8;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector8 Zero { get; } = new(0);

    public static Vector8[] UnitVectors { get; } = Matrix8.Identity.Columns;

    /// <summary>
    /// The raw memory size of the <see cref="Vector8"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector8);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector8"/>.
    /// </summary>
    public static Vector8EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace8 UnitSpace { get; } = VectorSpace8.FromMatrixColumns(Matrix8.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        5 => _5,
        6 => _6,
        7 => _7,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(8)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector8 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector8 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(8, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4, _5, _6, _7 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector8 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary && _5.IsBinary && _6.IsBinary && _7.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4 + _5 + _6 + _7;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector8 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix8 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 8-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector8(Scalar s = default)
        : this(s, s, s, s, s, s, s, s)
    {
    }

    public Vector8(Scalar* values)
        : this((Vector8*)values)
    {
    }

    public Vector8(Vector8* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given 8-dimensional one
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector8(in Vector8 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector8(in Vector9 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector8(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given 7-dimensional one.
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    public Vector8(in Vector7 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given 7-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 7-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector8(in Vector7 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], c)
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector8(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[8])
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector8(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    {
    }

    /// <summary>
    /// Creates a new 8-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector8(IEnumerable<double>? v)
        : this((v ?? new double[8]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector8 Negate() => new(-_0, -_1, -_2, -_3, -_4, -_5, -_6, -_7);

    public readonly Vector8 Add(in Vector8 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4, _5 + second._5, _6 + second._6, _7 + second._7);

    public readonly Vector8 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4, _5 + s5, _6 + s6, _7 + s7);

    public readonly Vector8 Add(params Vector8[] others) => others.Aggregate(this, Add);

    public readonly Vector8 MoveBy(in Vector8 second) => Add(in second);

    public readonly Vector8 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => Add(s0, s1, s2, s3, s4, s5, s6, s7);

    public readonly Vector8 Subtract(in Vector8 second) => Add(second.AdditiveInverse);

    public readonly Vector8 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4, _5 - s5, _6 - s6, _7 - s7);

    public readonly Vector8 Subtract(params Vector8[] others) => others.Aggregate(this, Subtract);

    public readonly Vector8 Increment() => Add(new Vector8(1));

    public readonly Vector8 Decrement() => Subtract(new Vector8(1));

    public readonly Vector8 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor, _5 * factor, _6 * factor, _7 * factor);

    public readonly Vector8 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector8 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector8 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector8 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor, _5 % factor, _6 % factor, _7 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        VectorNorm.UCoordinate => _5.Abs(),
        // VectorNorm.7 => ,
        // VectorNorm.8 => ,
        _ => throw new InvalidOperationException($"A vector of the type 'Vector8' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix8 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector8 ComponentwiseMultiply(in Vector8 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7);

    public readonly Vector8 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4, _5 * s5, _6 * s6, _7 * s7);

    public readonly Vector8 ComponentwiseDivide(in Vector8 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4, _5 / second._5, _6 / second._6, _7 / second._7);

    public readonly Vector8 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4, _5 / s5, _6 / s6, _7 / s7);

    public readonly Vector8 ComponentwiseModulus(in Vector8 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4, _5 % second._5, _6 % second._6, _7 % second._7);

    public readonly Vector8 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4, _5 % s5, _6 % s6, _7 % s7);

    readonly Vector8 Algebra<Scalar>.IVectorSpace<Vector8>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

    public readonly Vector8 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs(), _5.Abs(), _6.Abs(), _7.Abs());

    public readonly Vector8 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt(), _5.Sqrt(), _6.Sqrt(), _7.Sqrt());

    public readonly Vector8 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4), function(_5), function(_6), function(_7));

    public readonly Vector8 ComponentwiseApply(Vector8 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4), function(_5, second._5), function(_6, second._6), function(_7, second._7));

    public readonly Vector8 ComponentwiseApply(Vector8 second, Vector8 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4), function(_5, second._5, third._5), function(_6, second._6, third._6), function(_7, second._7, third._7));

    public readonly Vector8 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector8 r = (1, 1, 1, 1, 1, 1, 1, 1);
        Vector8 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector8 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector8 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 8; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector8 LinearInterpolate(in Vector8 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector8 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector8 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high), _5.Clamp(low, high), _6.Clamp(low, high), _7.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector8 second) => Dot(second).Acos();

    public readonly Matrix8 OuterProduct(in Vector8 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7
    );

    /// <summary>
    /// Returns the vector' 7D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>7D-minor</returns>
    public readonly Vector7 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector7(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector8 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector8 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ", ", _5.ToString(format, prov), ", ", _6.ToString(format, prov), ", ", _7.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector8 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector8)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
        yield return _5;
        yield return _6;
        yield return _7;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector8(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4, out Scalar x5, out Scalar x6, out Scalar x7) => (x0, x1, x2, x3, x4, x5, x6, x7) = (_0, _1, _2, _3, _4, _5, _6, _7);

    // public readonly void Deconstruct(out Scalar x0, out Vector7 v1) => (x0, v1) = (_0, (_1, _2, _3, _4, _5, _6, _7));
    //
    // public readonly void Deconstruct(out Vector7 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3, _4, _5, _6), _7);

    public readonly bool Is(Vector8 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance) && _5.Is(o._5, tolerance) && _6.Is(o._6, tolerance) && _7.Is(o._7, tolerance);

    public readonly bool Is(Vector8 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector8 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector8 second) => Dot(second).IsZero;

    public readonly Vector8 Reflect(in Vector8 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector8 normal, Scalar eta, out Vector8 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector8 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector8 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector7 FromHomogeneousCoordinates() => new(_0 / _7, _1 / _7, _2 / _7, _3 / _7, _4 / _7, _5 / _7, _6 / _7);

    public readonly Vector9 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, _4, _5, _6, _7, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector8 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(8);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector8 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector8 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector8(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7])
    };

    public static Vector8 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector8 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector8 FromHomogeneousCoordinates(Vector9 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector8 Add(Vector8 m1, Vector8 m2) => m1.Add(m2);

    public static Vector8 Subtract(Vector8 m1, Vector8 m2) => m1.Subtract(m2);

    public static Vector8 Multiply(Vector8 m, Scalar s) => m.Multiply(s);

    public static Vector8 Divide(Vector8 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector8 v1, in Vector8 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector8 v1, in Vector8 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector8 v1, in Vector8 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix8 OuterProduct(in Vector8 v1, in Vector8 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector8 LinearInterpolate(in Vector8 v1, in Vector8 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector8, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector8 v1, in Vector8 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector8 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector8(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector8 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector8 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 8)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 7.");

        Scalar[] coeff = new Scalar[8];

        coeff[n] = Scalar.One;

        return new Vector8(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector8 first, Vector8 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector8 first, Vector8 second) => first.IsNot(second);

    public static bool operator true(Vector8 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector8 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector8 v1, in Vector8 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector8 v1, in Vector8 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector8 v1, in Vector8 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector8 v1, in Vector8 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector8 operator ~(in Vector8 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector8 operator -(in Vector8 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector8 operator +(in Vector8 v) => v;

    public static Vector8 operator ++(in Vector8 v) => v.Increment();

    public static Vector8 operator --(in Vector8 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector8 operator +(in Vector8 v1, in Vector8 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector8 operator +(in Vector8 v, Scalar f) => v + new Vector8(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector8 operator +(Scalar f, in Vector8 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector8 operator -(in Vector8 v1, in Vector8 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector8 operator -(in Vector8 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector8 operator -(Scalar f, in Vector8 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector8 operator *(in Vector8 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector8 operator *(Scalar f, in Vector8 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector8 v1, in Vector8 v2) => v1.Dot(in v2);

    public static Vector8 operator ^(in Vector8 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector8 operator /(in Vector8 v, Scalar f) => v.Divide(f);

    public static Vector8 operator /(Scalar f, in Vector8 v) => new Vector8(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector8 v1, in Vector8 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector8 operator %(in Vector8 v, Scalar f) => v.Modulus(f);

    public static Vector8 operator %(in Vector8 v1, in Vector8 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector8 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector8 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector8 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector8 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector8 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector8(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

    public static implicit operator Vector8(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

    public static implicit operator Vector8(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

    public static implicit operator Vector8(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

    public static implicit operator Vector8(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7]);

    public static implicit operator Scalar[](in Vector8 v) => v.Coefficients;

    public static explicit operator Vector8(Scalar[] arr) => new(arr);

    public static explicit operator Vector8(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7) (in Vector8 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7);

    public static implicit operator Vector8((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7);

    public static implicit operator (Scalar x0, Vector7 v1)(in Vector8 v) => (v._0, (v._1, v._2, v._3, v._4, v._5, v._6, v._7));

    public static implicit operator (Vector7 v0, Scalar x1)(in Vector8 v) => ((v._0, v._1, v._2, v._3, v._4, v._5, v._6), v._7);

    public static implicit operator Polynomial(in Vector8 v) => v.ToPolynomial();

    public static explicit operator Vector8(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector8 v) => new(v.ToArray());

    public static explicit operator Vector8(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector8EqualityComparer
        : IEqualityComparer<Vector8>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector8 x, Vector8 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector8 obj) => obj.GetHashCode();
    }
}

public static class Vector8Extensions
{
    public static Vector8 Sum(this IEnumerable<Vector8> vectors) => Vector8.Zero.Add(vectors.ToArray());

    public static Vector8 Average(this IEnumerable<Vector8> vectors)
    {
        Vector8 vec = Vector8.Zero;
        long count = 0;

        foreach (Vector8 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector9

/// <summary>
/// Represents a 9-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector9(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8)
    : Algebra<Scalar>.IVector<Vector9, Matrix9>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector9>
    , IEnumerable<Scalar>
    , IComparable<Vector9>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector9>
    , IModulusOperators<Vector9, Scalar, Vector9>
    , IMultiplyOperators<Vector9, Vector9, Scalar>
    , IMultiplyOperators<Vector9, Scalar, Vector9>
    , IDivisionOperators<Vector9, Scalar, Vector9>
    , IMultiplyOperators<Scalar, Vector9, Vector9>
    , IDecrementOperators<Vector9>
    , IAdditionOperators<Vector9, Vector9, Vector9>
    , ISubtractionOperators<Vector9, Vector9, Vector9>
    , IUnaryPlusOperators<Vector9, Vector9>
    , IUnaryNegationOperators<Vector9, Vector9>
    , IAdditiveIdentity<Vector9, Vector9>
    , IMultiplicativeIdentity<Vector9, Vector9>
    , IComparisonOperators<Vector9, Vector9>
    , IEqualityOperators<Vector9, Vector9>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;
    private readonly Scalar _5 = x5;
    private readonly Scalar _6 = x6;
    private readonly Scalar _7 = x7;
    private readonly Scalar _8 = x8;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 9;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector9 Zero { get; } = new(0);

    public static Vector9[] UnitVectors { get; } = Matrix9.Identity.Columns;

    /// <summary>
    /// The raw memory size of the <see cref="Vector9"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector9);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector9"/>.
    /// </summary>
    public static Vector9EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace9 UnitSpace { get; } = VectorSpace9.FromMatrixColumns(Matrix9.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        5 => _5,
        6 => _6,
        7 => _7,
        8 => _8,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(9)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector9 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector9 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(9, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4, _5, _6, _7, _8 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector9 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary && _5.IsBinary && _6.IsBinary && _7.IsBinary && _8.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector9 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix9 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 9-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector9(Scalar s = default)
        : this(s, s, s, s, s, s, s, s, s)
    {
    }

    public Vector9(Scalar* values)
        : this((Vector9*)values)
    {
    }

    public Vector9(Vector9* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given 9-dimensional one
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector9(in Vector9 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector9(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given 8-dimensional one.
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    public Vector9(in Vector8 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given 8-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 8-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector9(in Vector8 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], c)
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector9(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[9])
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector9(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
    {
    }

    /// <summary>
    /// Creates a new 9-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector9(IEnumerable<double>? v)
        : this((v ?? new double[9]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector9 Negate() => new(-_0, -_1, -_2, -_3, -_4, -_5, -_6, -_7, -_8);

    public readonly Vector9 Add(in Vector9 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4, _5 + second._5, _6 + second._6, _7 + second._7, _8 + second._8);

    public readonly Vector9 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4, _5 + s5, _6 + s6, _7 + s7, _8 + s8);

    public readonly Vector9 Add(params Vector9[] others) => others.Aggregate(this, Add);

    public readonly Vector9 MoveBy(in Vector9 second) => Add(in second);

    public readonly Vector9 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => Add(s0, s1, s2, s3, s4, s5, s6, s7, s8);

    public readonly Vector9 Subtract(in Vector9 second) => Add(second.AdditiveInverse);

    public readonly Vector9 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4, _5 - s5, _6 - s6, _7 - s7, _8 - s8);

    public readonly Vector9 Subtract(params Vector9[] others) => others.Aggregate(this, Subtract);

    public readonly Vector9 Increment() => Add(new Vector9(1));

    public readonly Vector9 Decrement() => Subtract(new Vector9(1));

    public readonly Vector9 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor, _5 * factor, _6 * factor, _7 * factor, _8 * factor);

    public readonly Vector9 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector9 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector9 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector9 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor, _5 % factor, _6 % factor, _7 % factor, _8 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        VectorNorm.UCoordinate => _5.Abs(),
        // VectorNorm.7 => ,
        // VectorNorm.8 => ,
        // VectorNorm.9 => ,
        _ => throw new InvalidOperationException($"A vector of the type 'Vector9' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix9 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector9 ComponentwiseMultiply(in Vector9 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8);

    public readonly Vector9 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4, _5 * s5, _6 * s6, _7 * s7, _8 * s8);

    public readonly Vector9 ComponentwiseDivide(in Vector9 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4, _5 / second._5, _6 / second._6, _7 / second._7, _8 / second._8);

    public readonly Vector9 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4, _5 / s5, _6 / s6, _7 / s7, _8 / s8);

    public readonly Vector9 ComponentwiseModulus(in Vector9 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4, _5 % second._5, _6 % second._6, _7 % second._7, _8 % second._8);

    public readonly Vector9 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4, _5 % s5, _6 % s6, _7 % s7, _8 % s8);

    readonly Vector9 Algebra<Scalar>.IVectorSpace<Vector9>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

    public readonly Vector9 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs(), _5.Abs(), _6.Abs(), _7.Abs(), _8.Abs());

    public readonly Vector9 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt(), _5.Sqrt(), _6.Sqrt(), _7.Sqrt(), _8.Sqrt());

    public readonly Vector9 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4), function(_5), function(_6), function(_7), function(_8));

    public readonly Vector9 ComponentwiseApply(Vector9 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4), function(_5, second._5), function(_6, second._6), function(_7, second._7), function(_8, second._8));

    public readonly Vector9 ComponentwiseApply(Vector9 second, Vector9 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4), function(_5, second._5, third._5), function(_6, second._6, third._6), function(_7, second._7, third._7), function(_8, second._8, third._8));

    public readonly Vector9 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector9 r = (1, 1, 1, 1, 1, 1, 1, 1, 1);
        Vector9 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector9 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector9 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 9; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector9 LinearInterpolate(in Vector9 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector9 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector9 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high), _5.Clamp(low, high), _6.Clamp(low, high), _7.Clamp(low, high), _8.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector9 second) => Dot(second).Acos();

    public readonly Matrix9 OuterProduct(in Vector9 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8
    );

    /// <summary>
    /// Returns the vector' 8D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>8D-minor</returns>
    public readonly Vector8 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector8(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector9 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector9 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7}, {_8})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ", ", _5.ToString(format, prov), ", ", _6.ToString(format, prov), ", ", _7.ToString(format, prov), ", ", _8.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector9 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector9)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
        yield return _5;
        yield return _6;
        yield return _7;
        yield return _8;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector9(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4, out Scalar x5, out Scalar x6, out Scalar x7, out Scalar x8) => (x0, x1, x2, x3, x4, x5, x6, x7, x8) = (_0, _1, _2, _3, _4, _5, _6, _7, _8);

    // public readonly void Deconstruct(out Scalar x0, out Vector8 v1) => (x0, v1) = (_0, (_1, _2, _3, _4, _5, _6, _7, _8));
    //
    // public readonly void Deconstruct(out Vector8 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3, _4, _5, _6, _7), _8);

    public readonly bool Is(Vector9 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance) && _5.Is(o._5, tolerance) && _6.Is(o._6, tolerance) && _7.Is(o._7, tolerance) && _8.Is(o._8, tolerance);

    public readonly bool Is(Vector9 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector9 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector9 second) => Dot(second).IsZero;

    public readonly Vector9 Reflect(in Vector9 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector9 normal, Scalar eta, out Vector9 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector9 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector9 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector8 FromHomogeneousCoordinates() => new(_0 / _8, _1 / _8, _2 / _8, _3 / _8, _4 / _8, _5 / _8, _6 / _8, _7 / _8);

    public readonly Vector10 ToHomogeneousCoordinates() => new(_0, _1, _2, _3, _4, _5, _6, _7, _8, Scalar.One);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector9 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(9);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector9 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector9 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector9(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8])
    };

    public static Vector9 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector9 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
    public readonly Vector9 FromHomogeneousCoordinates(Vector10 homogeneous) => homogeneous.FromHomogeneousCoordinates();

    public static Vector9 Add(Vector9 m1, Vector9 m2) => m1.Add(m2);

    public static Vector9 Subtract(Vector9 m1, Vector9 m2) => m1.Subtract(m2);

    public static Vector9 Multiply(Vector9 m, Scalar s) => m.Multiply(s);

    public static Vector9 Divide(Vector9 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector9 v1, in Vector9 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector9 v1, in Vector9 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector9 v1, in Vector9 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix9 OuterProduct(in Vector9 v1, in Vector9 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector9 LinearInterpolate(in Vector9 v1, in Vector9 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector9, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector9 v1, in Vector9 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector9 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector9(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector9 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector9 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 9)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 8.");

        Scalar[] coeff = new Scalar[9];

        coeff[n] = Scalar.One;

        return new Vector9(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector9 first, Vector9 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector9 first, Vector9 second) => first.IsNot(second);

    public static bool operator true(Vector9 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector9 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector9 v1, in Vector9 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector9 v1, in Vector9 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector9 v1, in Vector9 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector9 v1, in Vector9 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector9 operator ~(in Vector9 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector9 operator -(in Vector9 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector9 operator +(in Vector9 v) => v;

    public static Vector9 operator ++(in Vector9 v) => v.Increment();

    public static Vector9 operator --(in Vector9 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector9 operator +(in Vector9 v1, in Vector9 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector9 operator +(in Vector9 v, Scalar f) => v + new Vector9(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector9 operator +(Scalar f, in Vector9 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector9 operator -(in Vector9 v1, in Vector9 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector9 operator -(in Vector9 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector9 operator -(Scalar f, in Vector9 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector9 operator *(in Vector9 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector9 operator *(Scalar f, in Vector9 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector9 v1, in Vector9 v2) => v1.Dot(in v2);

    public static Vector9 operator ^(in Vector9 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector9 operator /(in Vector9 v, Scalar f) => v.Divide(f);

    public static Vector9 operator /(Scalar f, in Vector9 v) => new Vector9(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector9 v1, in Vector9 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector9 operator %(in Vector9 v, Scalar f) => v.Modulus(f);

    public static Vector9 operator %(in Vector9 v1, in Vector9 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector9 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector9 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector9 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector9 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector9 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector9(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);

    public static implicit operator Vector9(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);

    public static implicit operator Vector9(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);

    public static implicit operator Vector9(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);

    public static implicit operator Vector9(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8]);

    public static implicit operator Scalar[](in Vector9 v) => v.Coefficients;

    public static explicit operator Vector9(Scalar[] arr) => new(arr);

    public static explicit operator Vector9(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8) (in Vector9 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8);

    public static implicit operator Vector9((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8);

    public static implicit operator (Scalar x0, Vector8 v1)(in Vector9 v) => (v._0, (v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8));

    public static implicit operator (Vector8 v0, Scalar x1)(in Vector9 v) => ((v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7), v._8);

    public static implicit operator Polynomial(in Vector9 v) => v.ToPolynomial();

    public static explicit operator Vector9(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector9 v) => new(v.ToArray());

    public static explicit operator Vector9(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector9EqualityComparer
        : IEqualityComparer<Vector9>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector9 x, Vector9 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector9 obj) => obj.GetHashCode();
    }
}

public static class Vector9Extensions
{
    public static Vector9 Sum(this IEnumerable<Vector9> vectors) => Vector9.Zero.Add(vectors.ToArray());

    public static Vector9 Average(this IEnumerable<Vector9> vectors)
    {
        Vector9 vec = Vector9.Zero;
        long count = 0;

        foreach (Vector9 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region Vector10

/// <summary>
/// Represents a 10-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct Vector10(Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8, Scalar x9)
    : Algebra<Scalar>.IVector<Vector10, Matrix10>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<Vector10>
    , IEnumerable<Scalar>
    , IComparable<Vector10>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<Vector10>
    , IModulusOperators<Vector10, Scalar, Vector10>
    , IMultiplyOperators<Vector10, Vector10, Scalar>
    , IMultiplyOperators<Vector10, Scalar, Vector10>
    , IDivisionOperators<Vector10, Scalar, Vector10>
    , IMultiplyOperators<Scalar, Vector10, Vector10>
    , IDecrementOperators<Vector10>
    , IAdditionOperators<Vector10, Vector10, Vector10>
    , ISubtractionOperators<Vector10, Vector10, Vector10>
    , IUnaryPlusOperators<Vector10, Vector10>
    , IUnaryNegationOperators<Vector10, Vector10>
    , IAdditiveIdentity<Vector10, Vector10>
    , IMultiplicativeIdentity<Vector10, Vector10>
    , IComparisonOperators<Vector10, Vector10>
    , IEqualityOperators<Vector10, Vector10>
#endif
{
    #region PRIVATE FIELDS

    private readonly Scalar _0 = x0;
    private readonly Scalar _1 = x1;
    private readonly Scalar _2 = x2;
    private readonly Scalar _3 = x3;
    private readonly Scalar _4 = x4;
    private readonly Scalar _5 = x5;
    private readonly Scalar _6 = x6;
    private readonly Scalar _7 = x7;
    private readonly Scalar _8 = x8;
    private readonly Scalar _9 = x9;

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = 10;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static Vector10 Zero { get; } = new(0);

    public static Vector10[] UnitVectors { get; } = Matrix10.Identity.Columns;

    /// <summary>
    /// The raw memory size of the <see cref="Vector10"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(Vector10);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="Vector10"/>.
    /// </summary>
    public static Vector10EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace10 UnitSpace { get; } = VectorSpace10.FromMatrixColumns(Matrix10.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
        0 => _0,
        1 => _1,
        2 => _2,
        3 => _3,
        4 => _4,
        5 => _5,
        6 => _6,
        7 => _7,
        8 => _8,
        9 => _9,
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(10)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly Vector10 this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly Vector10 this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(10, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { _0, _1, _2, _3, _4, _5, _6, _7, _8, _9 };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly Vector10 AdditiveInverse => Negate();

    public readonly bool IsBinary => _0.IsBinary && _1.IsBinary && _2.IsBinary && _3.IsBinary && _4.IsBinary && _5.IsBinary && _6.IsBinary && _7.IsBinary && _8.IsBinary && _9.IsBinary;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => _0 + _1 + _2 + _3 + _4 + _5 + _6 + _7 + _8 + _9;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly Vector10 Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly Matrix10 HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new 10-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public Vector10(Scalar s = default)
        : this(s, s, s, s, s, s, s, s, s, s)
    {
    }

    public Vector10(Scalar* values)
        : this((Vector10*)values)
    {
    }

    public Vector10(Vector10* vector)
        : this(*vector)
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given 10-dimensional one
    /// </summary>
    /// <param name="v">The 10-dimensional vector</param>
    public Vector10(in Vector10 v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9])
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given 9-dimensional one.
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    public Vector10(in Vector9 v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given 9-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The 9-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public Vector10(in Vector9 v, Scalar c)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], c)
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector10(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[10])
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector10(Scalar[] v)
        : this(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9])
    {
    }

    /// <summary>
    /// Creates a new 10-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public Vector10(IEnumerable<double>? v)
        : this((v ?? new double[10]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly Vector10 Negate() => new(-_0, -_1, -_2, -_3, -_4, -_5, -_6, -_7, -_8, -_9);

    public readonly Vector10 Add(in Vector10 second) => new(_0 + second._0, _1 + second._1, _2 + second._2, _3 + second._3, _4 + second._4, _5 + second._5, _6 + second._6, _7 + second._7, _8 + second._8, _9 + second._9);

    public readonly Vector10 Add(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => new(_0 + s0, _1 + s1, _2 + s2, _3 + s3, _4 + s4, _5 + s5, _6 + s6, _7 + s7, _8 + s8, _9 + s9);

    public readonly Vector10 Add(params Vector10[] others) => others.Aggregate(this, Add);

    public readonly Vector10 MoveBy(in Vector10 second) => Add(in second);

    public readonly Vector10 MoveBy(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => Add(s0, s1, s2, s3, s4, s5, s6, s7, s8, s9);

    public readonly Vector10 Subtract(in Vector10 second) => Add(second.AdditiveInverse);

    public readonly Vector10 Subtract(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => new(_0 - s0, _1 - s1, _2 - s2, _3 - s3, _4 - s4, _5 - s5, _6 - s6, _7 - s7, _8 - s8, _9 - s9);

    public readonly Vector10 Subtract(params Vector10[] others) => others.Aggregate(this, Subtract);

    public readonly Vector10 Increment() => Add(new Vector10(1));

    public readonly Vector10 Decrement() => Subtract(new Vector10(1));

    public readonly Vector10 Multiply(Scalar factor) => new(_0 * factor, _1 * factor, _2 * factor, _3 * factor, _4 * factor, _5 * factor, _6 * factor, _7 * factor, _8 * factor, _9 * factor);

    public readonly Vector10 Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly Vector10 Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly Vector10 Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly Vector10 Modulus(Scalar factor) => new(_0 % factor, _1 % factor, _2 % factor, _3 % factor, _4 % factor, _5 % factor, _6 % factor, _7 % factor, _8 % factor, _9 % factor);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
        VectorNorm.XCoordinate => _0.Abs(),
        VectorNorm.YCoordinate => _1.Abs(),
        VectorNorm.ZCoordinate => _2.Abs(),
        VectorNorm.WCoordinate => _3.Abs(),
        VectorNorm.VCoordinate => _4.Abs(),
        VectorNorm.UCoordinate => _5.Abs(),
        // VectorNorm.7 => ,
        // VectorNorm.8 => ,
        // VectorNorm.9 => ,
        // VectorNorm.10 => ,
        _ => throw new InvalidOperationException($"A vector of the type 'Vector10' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(Matrix10 matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly Vector10 ComponentwiseMultiply(in Vector10 second) => new(_0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9);

    public readonly Vector10 ComponentwiseMultiply(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => new(_0 * s0, _1 * s1, _2 * s2, _3 * s3, _4 * s4, _5 * s5, _6 * s6, _7 * s7, _8 * s8, _9 * s9);

    public readonly Vector10 ComponentwiseDivide(in Vector10 second) => new(_0 / second._0, _1 / second._1, _2 / second._2, _3 / second._3, _4 / second._4, _5 / second._5, _6 / second._6, _7 / second._7, _8 / second._8, _9 / second._9);

    public readonly Vector10 ComponentwiseDivide(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => new(_0 / s0, _1 / s1, _2 / s2, _3 / s3, _4 / s4, _5 / s5, _6 / s6, _7 / s7, _8 / s8, _9 / s9);

    public readonly Vector10 ComponentwiseModulus(in Vector10 second) => new(_0 % second._0, _1 % second._1, _2 % second._2, _3 % second._3, _4 % second._4, _5 % second._5, _6 % second._6, _7 % second._7, _8 % second._8, _9 % second._9);

    public readonly Vector10 ComponentwiseModulus(Scalar s0, Scalar s1, Scalar s2, Scalar s3, Scalar s4, Scalar s5, Scalar s6, Scalar s7, Scalar s8, Scalar s9) => new(_0 % s0, _1 % s1, _2 % s2, _3 % s3, _4 % s4, _5 % s5, _6 % s6, _7 % s7, _8 % s8, _9 % s9);

    readonly Vector10 Algebra<Scalar>.IVectorSpace<Vector10>.Modulus(Scalar scalar) => ComponentwiseModulus(scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar, scalar);

    public readonly Vector10 ComponentwiseAbsolute() => new(_0.Abs(), _1.Abs(), _2.Abs(), _3.Abs(), _4.Abs(), _5.Abs(), _6.Abs(), _7.Abs(), _8.Abs(), _9.Abs());

    public readonly Vector10 ComponentwiseSqrt() => new(_0.Sqrt(), _1.Sqrt(), _2.Sqrt(), _3.Sqrt(), _4.Sqrt(), _5.Sqrt(), _6.Sqrt(), _7.Sqrt(), _8.Sqrt(), _9.Sqrt());

    public readonly Vector10 ComponentwiseApply(Func<Scalar, Scalar> function) => new(function(_0), function(_1), function(_2), function(_3), function(_4), function(_5), function(_6), function(_7), function(_8), function(_9));

    public readonly Vector10 ComponentwiseApply(Vector10 second, Func<Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0), function(_1, second._1), function(_2, second._2), function(_3, second._3), function(_4, second._4), function(_5, second._5), function(_6, second._6), function(_7, second._7), function(_8, second._8), function(_9, second._9));

    public readonly Vector10 ComponentwiseApply(Vector10 second, Vector10 third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(function(_0, second._0, third._0), function(_1, second._1, third._1), function(_2, second._2, third._2), function(_3, second._3, third._3), function(_4, second._4, third._4), function(_5, second._5, third._5), function(_6, second._6, third._6), function(_7, second._7, third._7), function(_8, second._8, third._8), function(_9, second._9, third._9));

    public readonly Vector10 Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        Vector10 r = (1, 1, 1, 1, 1, 1, 1, 1, 1, 1);
        Vector10 p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in Vector10 second) => ComponentwiseMultiply(second).CoefficientSum;

    public readonly bool IsLinearDependant(in Vector10 other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < 10; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly Vector10 LinearInterpolate(in Vector10 other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly Vector10 Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly Vector10 Clamp(Scalar low, Scalar high) => new(_0.Clamp(low, high), _1.Clamp(low, high), _2.Clamp(low, high), _3.Clamp(low, high), _4.Clamp(low, high), _5.Clamp(low, high), _6.Clamp(low, high), _7.Clamp(low, high), _8.Clamp(low, high), _9.Clamp(low, high));

    public readonly Scalar AngleTo(in Vector10 second) => Dot(second).Acos();

    public readonly Matrix10 OuterProduct(in Vector10 second) => new(
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9,
        _0 * second._0, _1 * second._1, _2 * second._2, _3 * second._3, _4 * second._4, _5 * second._5, _6 * second._6, _7 * second._7, _8 * second._8, _9 * second._9
    );

    /// <summary>
    /// Returns the vector' 9D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns>9D-minor</returns>
    public readonly Vector9 Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector9(f.Take(row).Concat(f.Skip(row + 1)));
    }

    public readonly bool Equals(Vector10 other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is Vector10 v && Equals(v);

    public readonly override string ToString() => $"({_0}, {_1}, {_2}, {_3}, {_4}, {_5}, {_6}, {_7}, {_8}, {_9})";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", _0.ToString(format, prov), ", ", _1.ToString(format, prov), ", ", _2.ToString(format, prov), ", ", _3.ToString(format, prov), ", ", _4.ToString(format, prov), ", ", _5.ToString(format, prov), ", ", _6.ToString(format, prov), ", ", _7.ToString(format, prov), ", ", _8.ToString(format, prov), ", ", _9.ToString(format, prov), ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(Vector10 other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((Vector10)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
        yield return _0;
        yield return _1;
        yield return _2;
        yield return _3;
        yield return _4;
        yield return _5;
        yield return _6;
        yield return _7;
        yield return _8;
        yield return _9;
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new Vector10(this);

    public readonly void Deconstruct(out Scalar x0, out Scalar x1, out Scalar x2, out Scalar x3, out Scalar x4, out Scalar x5, out Scalar x6, out Scalar x7, out Scalar x8, out Scalar x9) => (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) = (_0, _1, _2, _3, _4, _5, _6, _7, _8, _9);

    // public readonly void Deconstruct(out Scalar x0, out Vector9 v1) => (x0, v1) = (_0, (_1, _2, _3, _4, _5, _6, _7, _8, _9));
    //
    // public readonly void Deconstruct(out Vector9 v0, out Scalar x1) => (v0, x1) = ((_0, _1, _2, _3, _4, _5, _6, _7, _8), _9);

    public readonly bool Is(Vector10 o, Scalar tolerance) => _0.Is(o._0, tolerance) && _1.Is(o._1, tolerance) && _2.Is(o._2, tolerance) && _3.Is(o._3, tolerance) && _4.Is(o._4, tolerance) && _5.Is(o._5, tolerance) && _6.Is(o._6, tolerance) && _7.Is(o._7, tolerance) && _8.Is(o._8, tolerance) && _9.Is(o._9, tolerance);

    public readonly bool Is(Vector10 o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(Vector10 o) => !Is(o);

    public readonly bool IsOrthogonal(in Vector10 second) => Dot(second).IsZero;

    public readonly Vector10 Reflect(in Vector10 normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in Vector10 normal, Scalar eta, out Vector10 refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in Vector10 second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in Vector10 second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);

    public readonly Vector9 FromHomogeneousCoordinates() => new(_0 / _9, _1 / _9, _2 / _9, _3 / _9, _4 / _9, _5 / _9, _6 / _9, _7 / _9, _8 / _9);

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly Vector10 SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(10);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly Vector10 SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS

    public static Vector10 FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new Vector10(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9])
    };

    public static Vector10 FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static Vector10 FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);

    public static Vector10 Add(Vector10 m1, Vector10 m2) => m1.Add(m2);

    public static Vector10 Subtract(Vector10 m1, Vector10 m2) => m1.Subtract(m2);

    public static Vector10 Multiply(Vector10 m, Scalar s) => m.Multiply(s);

    public static Vector10 Divide(Vector10 m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in Vector10 v1, in Vector10 v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in Vector10 v1, in Vector10 v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in Vector10 v1, in Vector10 v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static Matrix10 OuterProduct(in Vector10 v1, in Vector10 v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static Vector10 LinearInterpolate(in Vector10 v1, in Vector10 v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(Vector10, out Scalar?)"/>
    public static bool IsLinearDependant(in Vector10 v1, in Vector10 v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static Vector10 GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new Vector10(generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1, generator.NextScalar() * 2 - 1).Normalized;

    public static Vector10 GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static Vector10 GetNthUnitVector(int n)
    {
        if (n < 0 || n >= 10)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and 9.");

        Scalar[] coeff = new Scalar[10];

        coeff[n] = Scalar.One;

        return new Vector10(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(Vector10 first, Vector10 second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(Vector10 first, Vector10 second) => first.IsNot(second);

    public static bool operator true(Vector10 vector) => vector.Length.IsNonZero;

    public static bool operator false(Vector10 vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in Vector10 v1, in Vector10 v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in Vector10 v1, in Vector10 v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in Vector10 v1, in Vector10 v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in Vector10 v1, in Vector10 v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static Vector10 operator ~(in Vector10 v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static Vector10 operator -(in Vector10 v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static Vector10 operator +(in Vector10 v) => v;

    public static Vector10 operator ++(in Vector10 v) => v.Increment();

    public static Vector10 operator --(in Vector10 v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static Vector10 operator +(in Vector10 v1, in Vector10 v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector10 operator +(in Vector10 v, Scalar f) => v + new Vector10(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static Vector10 operator +(Scalar f, in Vector10 v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static Vector10 operator -(in Vector10 v1, in Vector10 v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector10 operator -(in Vector10 v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static Vector10 operator -(Scalar f, in Vector10 v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector10 operator *(in Vector10 v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static Vector10 operator *(Scalar f, in Vector10 v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in Vector10 v1, in Vector10 v2) => v1.Dot(in v2);

    public static Vector10 operator ^(in Vector10 m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static Vector10 operator /(in Vector10 v, Scalar f) => v.Divide(f);

    public static Vector10 operator /(Scalar f, in Vector10 v) => new Vector10(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in Vector10 v1, in Vector10 v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static Vector10 operator %(in Vector10 v, Scalar f) => v.Modulus(f);

    public static Vector10 operator %(in Vector10 v1, in Vector10 v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(Vector10 v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(Vector10 v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(Vector10 v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(Vector10 v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(Vector10 v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator Vector10(num.Vector<Scalar> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);

    public static implicit operator Vector10(num.Vector<double> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);

    public static implicit operator Vector10(num.Vector<float> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);

    public static implicit operator Vector10(num.Vector<long> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);

    public static implicit operator Vector10(num.Vector<int> v) => new(v[0], v[1], v[2], v[3], v[4], v[5], v[6], v[7], v[8], v[9]);

    public static implicit operator Scalar[](in Vector10 v) => v.Coefficients;

    public static explicit operator Vector10(Scalar[] arr) => new(arr);

    public static explicit operator Vector10(Scalar s) => new(s);

    public static implicit operator (Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8, Scalar x9) (in Vector10 v) => (v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8, v._9);

    public static implicit operator Vector10((Scalar x0, Scalar x1, Scalar x2, Scalar x3, Scalar x4, Scalar x5, Scalar x6, Scalar x7, Scalar x8, Scalar x9) t) => new(t.x0, t.x1, t.x2, t.x3, t.x4, t.x5, t.x6, t.x7, t.x8, t.x9);

    public static implicit operator (Scalar x0, Vector9 v1)(in Vector10 v) => (v._0, (v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8, v._9));

    public static implicit operator (Vector9 v0, Scalar x1)(in Vector10 v) => ((v._0, v._1, v._2, v._3, v._4, v._5, v._6, v._7, v._8), v._9);

    public static implicit operator Polynomial(in Vector10 v) => v.ToPolynomial();

    public static explicit operator Vector10(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in Vector10 v) => new(v.ToArray());

    public static explicit operator Vector10(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class Vector10EqualityComparer
        : IEqualityComparer<Vector10>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Vector10 x, Vector10 y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(Vector10 obj) => obj.GetHashCode();
    }
}

public static class Vector10Extensions
{
    public static Vector10 Sum(this IEnumerable<Vector10> vectors) => Vector10.Zero.Add(vectors.ToArray());

    public static Vector10 Average(this IEnumerable<Vector10> vectors)
    {
        Vector10 vec = Vector10.Zero;
        long count = 0;

        foreach (Vector10 v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
#region VectorN (Extensions)

public partial class VectorN
{
    public Algebra<Scalar>.IVector Cast() => Size switch
    {
        1 => this[0],
        2 => (Vector2)this,
        3 => (Vector3)this,
        4 => (Vector4)this,
        5 => (Vector5)this,
        6 => (Vector6)this,
        7 => (Vector7)this,
        8 => (Vector8)this,
        9 => (Vector9)this,
        10 => (Vector10)this,
        _ => new VectorN(this) as Algebra<Scalar>.IVector
    };
}

#endregion

public enum VectorNorm
{
    EucledianNorm = 0,
    XCoordinate = 1,
    YCoordinate = 2,
    ZCoordinate = 3,
    WCoordinate = 4,
    VCoordinate = 5,
    UCoordinate = 6,
    // TODO = 7,
    // TODO = 8,
    // TODO = 9,
    // TODO = 10,
    // TODO = 11,
    // TODO = 12,
    TaxicabNorm,
    MaximumNorm,
    ManhattanNorm = TaxicabNorm,
    Linf_Norm = MaximumNorm,
}
