<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

// #define GENERIC_MATH

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.ComponentModel;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System;

using Unknown6656.Mathematics.Analysis;
using Unknown6656.Mathematics.Numerics;
using Unknown6656.Generics;
using Unknown6656.Common;
using Unknown6656.IO;

namespace Unknown6656.Mathematics.LinearAlgebra;

// TODO : fix coefficient naming 'XYZWVU'

<#
    T[][] PowerSet<T>(T[] collection)
    {
        T[][] set = new T[1 << collection.Length][];
        T[] src, dst;
        T elem;

        set[0] = new T[0];

        for (int i = 0, j, count; i < collection.Length; i++)
        {
            elem = collection[i];

            for (j = 0, count = 1 << i; j < count; j++)
            {
                src = set[j];
                dst = set[count + j] = new T[src.Length + 1];

                for (int q = 0; q < src.Length; q++)
                    dst[q] = src[q];

                dst[src.Length] = elem;
            }
        }

        return set;
    }

    string[] Permutations(char[] l)
    {
        IEnumerable<string> rec(char[] list, int k, int m)
        {
            List<string> res = new List<string>();
            void Swap(ref char a, ref char b)
            {
                if (a == b)
                    return;

                var temp = a;

                a = b;
                b = temp;
            }

            if (k == m)
                res.Add(new string(list.ToArray()));
            else
                for (int i = k; i <= m; ++i)
                {
                    Swap(ref list[k], ref list[i]);
                    res.AddRange(rec(list, k + 1, m));
                    Swap(ref list[k], ref list[i]);
                }

            return res;
        }

        return rec(l, 0, l.Length - 1).ToArray();
    }

    const string comp = "XYZWVU";
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim < maxdim; ++dim)
    {
        string[] comps = r(0, dim).Select(i => "_" + i).ToArray();
        string typename = "Vector" + dim;
        string matname = "Matrix" + dim;
        bool crossable = dim == 3 || dim == 7;
#>
#region <#=typename#>

/// <summary>
/// Represents a <#=crossable ? "crossable " : ""#><#=dim#>-dimensional vector.
/// </summary>
/// <inheritdoc cref="IMatrix{M,V,S}"/>
[StructLayout(LayoutKind.Sequential), NativeCppClass, Serializable, CLSCompliant(false)]
public unsafe readonly /* ref */ partial struct <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => "Scalar x" + i))#>)
    : Algebra<Scalar>.IVector<<#=typename#>, <#=matname#>>
<#
        if (crossable)
            WriteLine($"    , Algebra<Scalar>.ICrossableVector<{typename}>");
#>
    , Algebra<Scalar, Polynomial>.IComposite1D
    , INative<<#=typename#>>
    , IEnumerable<Scalar>
    , IComparable<<#=typename#>>
    , IComparable
    , IFormattable
    , ICloneable
#if GENERIC_MATH
// TODO : move generic math operators to the dedicated algebraic interfaces
    , IIncrementOperators<<#=typename#>>
    , IModulusOperators<<#=typename#>, Scalar, <#=typename#>>
    , IMultiplyOperators<<#=typename#>, <#=typename#>, Scalar>
    , IMultiplyOperators<<#=typename#>, Scalar, <#=typename#>>
    , IDivisionOperators<<#=typename#>, Scalar, <#=typename#>>
    , IMultiplyOperators<Scalar, <#=typename#>, <#=typename#>>
    , IDecrementOperators<<#=typename#>>
    , IAdditionOperators<<#=typename#>, <#=typename#>, <#=typename#>>
    , ISubtractionOperators<<#=typename#>, <#=typename#>, <#=typename#>>
    , IUnaryPlusOperators<<#=typename#>, <#=typename#>>
    , IUnaryNegationOperators<<#=typename#>, <#=typename#>>
    , IAdditiveIdentity<<#=typename#>, <#=typename#>>
    , IMultiplicativeIdentity<<#=typename#>, <#=typename#>>
    , IComparisonOperators<<#=typename#>, <#=typename#>>
    , IEqualityOperators<<#=typename#>, <#=typename#>>
#endif
{
    #region PRIVATE FIELDS

<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"    private readonly Scalar {comps[i]} = x{i};");
#>

    #endregion
    #region STATIC PROPERTIES

    /// <inheritdoc cref="Dimension"/>
    public const int Dimension = <#=dim#>;

    /// <summary>
    /// The zero vector
    /// </summary>
    public static <#=typename#> Zero { get; } = new(0);

    public static <#=typename#>[] UnitVectors { get; } = <#=matname#>.Identity.Columns;
<#
        if (dim <= comp.Length)
            for (int i = 0; i < dim; ++i)
            {
                int[] tuple = new int[dim];
                tuple[i] = 1;
#>

    /// <summary>
    /// The unit vector in <#=comp[i]#>-direction
    /// </summary>
    public static <#=typename#> Unit<#=comp[i]#> { get; } = (<#=string.Join(", ", tuple)#>);
<#
            }
#>

    /// <summary>
    /// The raw memory size of the <see cref="<#=typename#>"/>-structure in bytes.
    /// </summary>
    public static int BinarySize { get; } = sizeof(<#=typename#>);

    /// <summary>
    /// The default component-wise equality comparer for  <see cref="<#=typename#>"/>.
    /// </summary>
    public static <#=typename#>EqualityComparer EqualityComparer { get; } = new();

    public static VectorSpace<#=dim#> UnitSpace { get; } = VectorSpace<#=dim#>.FromMatrixColumns(<#=matname#>.Identity);

    #endregion
    #region INDEXERS

    public readonly Scalar this[int index] => index switch
    {
<#=string.Join("\n", r(0, dim).Select(i => $"        {i} => {comps[i]},"))#>
        _ => throw new IndexOutOfRangeException()
    };

    public readonly Scalar this[Index index] => this[index.GetOffset(<#=dim#>)];

    public readonly VectorN this[Range rows] => GetEntries(rows);

    public readonly <#=typename#> this[Range rows, in VectorN values] => SetEntries(rows, values);

    public readonly <#=typename#> this[int index, Scalar new_value]
    {
        get
        {
            Scalar[] arr = this;

            arr[index] = new_value;

            return new(arr);
        }
    }

    #endregion
    #region INSTANCE PROPERTIES
<#
        const bool use_permutations = false;

        if (dim <= comp.Length)
            foreach (char[] comb in PowerSet<char>(comp.Take(dim).ToArray()).Where(a => a.Length > 0).OrderBy(a => a.Length))
                foreach (string p in use_permutations ? Permutations(comb) : new[] { new string(comb) })
                    if (p != comp.Substring(0, dim))
                        if (p.Length == 1)
                        {
#>

    /// <summary>
    /// Returns the vector's <#=p#>-coefficient (Index = <#=comp.IndexOf(p)#>).
    /// </summary>
    public readonly Scalar <#=p#> => <#=comps[comp.IndexOf(p)]#>;
<#
                        }
                        else
                        {
#>

    /// <summary>
    /// Returns the combination of the vector's <#=p#>-coefficients.
    /// </summary>
    [DebuggerHidden, DebuggerNonUserCode, DebuggerBrowsable(DebuggerBrowsableState.Never) /* EditorBrowsable(EditorBrowsableState.Never) */]
    public readonly Vector<#=p.Length + " " + p #> => new(<#=string.Join(", ", p as IEnumerable<char>)#>);
<#
                        }
#>

    /// <inheritdoc cref="Dimension"/>
    public readonly int Size => Dimension;

    readonly int Algebra<Scalar>.IComposite1D.Dimension => Dimension;

    public readonly MatrixNM Transposed => new(<#=dim#>, 1, Coefficients);

    public readonly Scalar[] Coefficients => new[] { <#=string.Join(", ", comps)#> };

    public readonly bool IsZero => Is(Zero);

    public readonly bool IsNonZero => !IsZero;

    public readonly <#=typename#> AdditiveInverse => Negate();

    public readonly bool IsBinary => <#=string.Join(" && ", comps.Select(c => c + ".IsBinary"))#>;

    public readonly bool IsNegative => Coefficients.All(c => c.IsNegative);

    public readonly bool IsPositive => Coefficients.All(c => c.IsPositive);

    public readonly bool HasNegatives => Coefficients.Any(c => c.IsNegative);

    public readonly bool HasPositives => Coefficients.Any(c => c.IsPositive);

    public readonly bool HasNaNs => Coefficients.Any(c => c.IsNaN);

    public readonly Scalar CoefficientSum => <#=string.Join(" + ", comps)#>;

    public readonly Scalar CoefficientAvg => CoefficientSum / Dimension;

    public readonly Scalar CoefficientMin => Coefficients.Min();

    public readonly Scalar CoefficientMax => Coefficients.Max();

    public readonly Scalar MaximumNorm => Coefficients.Select(Scalar.Abs).Max();

    public readonly Scalar TaxicabNorm => Coefficients.Select(Scalar.Abs).Sum();

    public readonly Scalar SquaredNorm => Dot(this);

    public readonly Scalar SquaredLength => SquaredNorm;

    public readonly Scalar Length => SquaredNorm.Sqrt();

    public readonly Scalar EucledianNorm => Length;

    public readonly <#=typename#> Normalized => Length is Scalar l && l.IsZero ? Zero : Divide(l);

    public readonly bool IsNormalized => Length.IsOne;

    public readonly bool IsInsideUnitSphere => Length.IsInsideUnitSphere;

    public readonly <#=matname#> HouseholderMatrix => IsZero ? throw new InvalidOperationException("The Householder matrix is undefined for zero vectors.")
                                                : OuterProduct(this) * 2 / SquaredNorm;

    #endregion
    #region CONSTRUCTORS

    /// <summary>
    /// Creates a new <#=dim#>-dimensional uniform vector
    /// </summary>
    /// <param name="s">The coefficients' value</param>
    public <#=typename#>(Scalar s = default)
        : this(<#=string.Join(", ", Enumerable.Repeat("s", dim))#>)
    {
    }

    public <#=typename#>(Scalar* values)
        : this((<#=typename#>*)values)
    {
    }

    public <#=typename#>(<#=typename#>* vector)
        : this(*vector)
    {
    }
<#
        for (int i = dim; i < maxdim; ++i)
        {
#>

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given <#=i#>-dimensional one
    /// </summary>
    /// <param name="v">The <#=i#>-dimensional vector</param>
    public <#=typename#>(in Vector<#=i#> v)
        : this(<#=string.Join(", ", r(0, dim).Select(j => $"v[{j}]"))#>)
    {
    }
<#
        }

        if (dim > 2)
        {
#>

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given <#=dim-1#>-dimensional one.
    /// </summary>
    /// <param name="v">The <#=dim-1#>-dimensional vector</param>
    public <#=typename#>(in Vector<#=dim-1#> v)
        : this(v, 0)
    {
    }

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given <#=dim-1#>-dimensional one and an additional coefficient.
    /// </summary>
    /// <param name="v">The <#=dim-1#>-dimensional vector</param>
    /// <param name="c">The additional coefficient</param>
    public <#=typename#>(in Vector<#=dim-1#> v, Scalar c)
        : this(<#=string.Join(", ", r(0, dim - 1).Select(j => $"v[{j}]"))#>, c)
    {
    }
<#
        }
#>

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public <#=typename#>(IEnumerable<Scalar> v)
        : this(v?.ToArray() ?? new Scalar[<#=dim#>])
    {
    }

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public <#=typename#>(Scalar[] v)
        : this(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>)
    {
    }

    /// <summary>
    /// Creates a new <#=dim#>-dimensional vector from the given coefficient array
    /// </summary>
    /// <param name="v">The vector's coefficients</param>
    public <#=typename#>(IEnumerable<double>? v)
        : this((v ?? new double[<#=dim#>]).Select(v => (Scalar)v))
    {
    }

    #endregion
    #region INSTANCE METHODS

    public readonly <#=typename#> Negate() => new(<#=string.Join(", ", comps.Select(s => '-' + s))#>);

    public readonly <#=typename#> Add(in <#=typename#> second) => new(<#=string.Join(", ", comps.Select(s => $"{s} + second.{s}"))#>);

    public readonly <#=typename#> Add(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => new(<#=string.Join(", ", comps.Select((s, i) => $"{s} + s{i}"))#>);

    public readonly <#=typename#> Add(params <#=typename#>[] others) => others.Aggregate(this, Add);

    public readonly <#=typename#> MoveBy(in <#=typename#> second) => Add(in second);

    public readonly <#=typename#> MoveBy(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => Add(<#=string.Join(", ", r(0, dim).Select(i => "s" + i))#>);

    public readonly <#=typename#> Subtract(in <#=typename#> second) => Add(second.AdditiveInverse);

    public readonly <#=typename#> Subtract(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => new(<#=string.Join(", ", comps.Select((s, i) => $"{s} - s{i}"))#>);

    public readonly <#=typename#> Subtract(params <#=typename#>[] others) => others.Aggregate(this, Subtract);

    public readonly <#=typename#> Increment() => Add(new <#=typename#>(1));

    public readonly <#=typename#> Decrement() => Subtract(new <#=typename#>(1));

    public readonly <#=typename#> Multiply(Scalar factor) => new(<#=string.Join(", ", comps.Select(s => $"{s} * factor"))#>);

    public readonly <#=typename#> Multiply(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Multiply(f));

    public readonly <#=typename#> Divide(Scalar factor) => Multiply(factor.Inverse);

    public readonly <#=typename#> Divide(params Scalar[] factors) => factors.Aggregate(this, (v, f) => v.Divide(f));

    public readonly <#=typename#> Modulus(Scalar factor) => new(<#=string.Join(", ", comps.Select(s => $"{s} % factor"))#>);

    public readonly Scalar ComputeNorm(VectorNorm norm) => norm switch
    {
        VectorNorm.EucledianNorm => EucledianNorm,
        VectorNorm.TaxicabNorm => TaxicabNorm,
        VectorNorm.MaximumNorm => MaximumNorm,
<#
        for (int i = 0; i < dim; ++i)
            if (i < comp.Length)
                WriteLine($"        VectorNorm.{comp[i]}Coordinate => {comps[i]}.Abs(),");
            else
                WriteLine($"        // VectorNorm.{i + 1} => ,");
#>
        _ => throw new InvalidOperationException($"A vector of the type '<#=typename#>' does not support the vector norm '{norm}'."),
    };

    public readonly Scalar ComputePNorm(Scalar p) => Coefficients.Select(c => c.Abs().Power(p)).Sum().Power(p.MultiplicativeInverse);

    public readonly Scalar ComputeMatrixNorm(<#=matname#> matrix) => Dot(matrix.Multiply(this)).Sqrt();

    public readonly <#=typename#> ComponentwiseMultiply(in <#=typename#> second) => new(<#=string.Join(", ", comps.Select(s => $"{s} * second.{s}"))#>);

    public readonly <#=typename#> ComponentwiseMultiply(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => new(<#=string.Join(", ", comps.Select((s, i) => $"{s} * s{i}"))#>);

    public readonly <#=typename#> ComponentwiseDivide(in <#=typename#> second) => new(<#=string.Join(", ", comps.Select(s => $"{s} / second.{s}"))#>);

    public readonly <#=typename#> ComponentwiseDivide(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => new(<#=string.Join(", ", comps.Select((s, i) => $"{s} / s{i}"))#>);

    public readonly <#=typename#> ComponentwiseModulus(in <#=typename#> second) => new(<#=string.Join(", ", comps.Select(s => $"{s} % second.{s}"))#>);

    public readonly <#=typename#> ComponentwiseModulus(<#=string.Join(", ", r(0, dim).Select(i => $"Scalar s{i}"))#>) => new(<#=string.Join(", ", comps.Select((s, i) => $"{s} % s{i}"))#>);

    readonly <#=typename#> Algebra<Scalar>.IVectorSpace<<#=typename#>>.Modulus(Scalar scalar) => ComponentwiseModulus(<#=string.Join(", ", comps.Select(s => $"scalar"))#>);

    public readonly <#=typename#> ComponentwiseAbsolute() => new(<#=string.Join(", ", comps.Select(s => s + ".Abs()"))#>);

    public readonly <#=typename#> ComponentwiseSqrt() => new(<#=string.Join(", ", comps.Select(s => s + ".Sqrt()"))#>);

    public readonly <#=typename#> ComponentwiseApply(Func<Scalar, Scalar> function) => new(<#=string.Join(", ", comps.Select(s => $"function({s})"))#>);

    public readonly <#=typename#> ComponentwiseApply(<#=typename#> second, Func<Scalar, Scalar, Scalar> function) =>
        new(<#=string.Join(", ", comps.Select(s => $"function({s}, second.{s})"))#>);

    public readonly <#=typename#> ComponentwiseApply(<#=typename#> second, <#=typename#> third, Func<Scalar, Scalar, Scalar, Scalar> function) =>
        new(<#=string.Join(", ", comps.Select(s => $"function({s}, second.{s}, third.{s})"))#>);

    public readonly <#=typename#> Power(int e)
    {
        ArgumentOutOfRangeException.ThrowIfNegative(e, nameof(e));

        <#=typename#> r = (<#=string.Join(", ", Enumerable.Repeat(1, dim))#>);
        <#=typename#> p = this;

        while (e > 0)
            if ((e & 1) == 1)
            {
                --e;
                r = r.ComponentwiseMultiply(p);
            }
            else
            {
                e /= 2;
                p = p.ComponentwiseMultiply(p);
            }

        return r;
    }

    public readonly Scalar Dot(in <#=typename#> second) => ComponentwiseMultiply(second).CoefficientSum;
<#
        if (crossable)
        {
#>

    public readonly <#=typename#> Cross(in <#=typename#> v) => Cross(this, v);

    public readonly Scalar TripleProduct(in <#=typename#> b, in <#=typename#> c) => TripleProduct(this, b, c);
<#
        }
#>

    public readonly bool IsLinearDependant(in <#=typename#> other, out Scalar? factor)
    {
        factor = null;

        if (IsZero || other.IsZero)
            return false;

        Scalar div = Scalar.Zero;

        for (int i = 0; i < <#=dim#>; ++i)
            if (this[i].IsZero ^ other[i].IsZero && !this[i].Is(other[i], Scalar.ComputationalEpsilon ^ 2))
                return false;
            else if (this[i].IsNonZero)
            {
                Scalar f = this[i] / other[i];

                if (div.IsZero)
                    div = f;
                else if (div.IsNot(f))
                    return false;
            }

        factor = div;

        return true;
    }

    public readonly <#=typename#> LinearInterpolate(in <#=typename#> other, Scalar factor) => Multiply(1 - factor) + other.Multiply(factor);

    /// <inheritdoc cref="IVector{V, S}.Clamp(S, S)"/>
    public readonly <#=typename#> Clamp() => Clamp(Scalar.Zero, Scalar.One);

    public readonly <#=typename#> Clamp(Scalar low, Scalar high) => new(<#=string.Join(", ", comps.Select(s => $"{s}.Clamp(low, high)"))#>);

    public readonly Scalar AngleTo(in <#=typename#> second) => Dot(second).Acos();

    public readonly <#=matname#> OuterProduct(in <#=typename#> second) => new(
        <#=string.Join("\n        ", r(0, dim).Select(i => string.Join(", ", comps.Select(s => $"{s} * second.{s}")) + (i < dim - 1 ? "," : "")))#>
    );

    /// <summary>
    /// Returns the vector' <#=dim-1#>D-minor at the given index
    /// </summary>
    /// <param name="row">Zero-based row index</param>
    /// <returns><#=dim-1#>D-minor</returns>
<#
        if (dim == 2)
        {
#>
    public readonly Scalar Minor(int row) => row switch
    {
        0 => _1,
        1 => _0,
        _ => throw new IndexOutOfRangeException()
    };
<#
        }
        else if (dim > 2)
        {
#>
    public readonly Vector<#=dim-1#> Minor(int row)
    {
        Scalar[] f = ToArray();

        return new Vector<#=dim-1#>(f.Take(row).Concat(f.Skip(row + 1)));
    }
<#
        }
#>

    public readonly bool Equals(<#=typename#> other) => Is(other);

    public readonly override bool Equals(object? obj) => obj is <#=typename#> v && Equals(v);

    public readonly override string ToString() => $"(<#=string.Join(", ", comps.Select(s => "{" + s + "}"))#>)";

    public readonly string ToString(string format) => ToString(format, null);

    public readonly string ToString(IFormatProvider prov) => ToString(null, prov);

    public readonly string ToString(string? format, IFormatProvider? prov) =>
        string.Concat("(", <#=string.Join(", \", \", ", comps.Select(s => s + ".ToString(format, prov)"))#>, ")");

    public readonly override int GetHashCode() => LINQ.GetHashCode(Coefficients);

    // TODO : warning
    public readonly int CompareTo(<#=typename#> other) => Length.CompareTo(other.Length);

#pragma warning disable CS8995
    public readonly int CompareTo(object? other) => CompareTo((<#=typename#>)other);
#pragma warning restore CS8995

    public readonly IEnumerator<Scalar> GetEnumerator()
    {
<#
        for (int i = 0; i < dim; ++i)
            WriteLine($"        yield return _{i};");
#>
    }

    readonly IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

    public readonly object Clone() => new <#=typename#>(this);

    public readonly void Deconstruct(<#=string.Join(", ", r(0, dim).Select(i => $"out Scalar x{i}"))#>) => (<#=string.Join(", ", r(0, dim).Select(i => "x" + i))#>) = (<#=string.Join(", ", r(0, dim).Select(i => "_" + i))#>);
<#
        if (dim > 2)
        {
#>

    // public readonly void Deconstruct(out Scalar x0, out Vector<#=dim-1#> v1) => (x0, v1) = (_0, (<#=string.Join(", ", r(1, dim - 1).Select(i => "_" + i))#>));
    //
    // public readonly void Deconstruct(out Vector<#=dim-1#> v0, out Scalar x1) => (v0, x1) = ((<#=string.Join(", ", r(0, dim - 1).Select(i => "_" + i))#>), _<#=dim-1#>);
<#
        }
#>

    public readonly bool Is(<#=typename#> o, Scalar tolerance) => <#=string.Join(" && ", comps.Select(s => $"{s}.Is(o.{s}, tolerance)"))#>;

    public readonly bool Is(<#=typename#> o) => Is(o, Scalar.ComputationalEpsilon);

    public readonly bool IsNot(<#=typename#> o) => !Is(o);

    public readonly bool IsOrthogonal(in <#=typename#> second) => Dot(second).IsZero;

    public readonly <#=typename#> Reflect(in <#=typename#> normal)
    {
        Scalar θ = Dot(normal);

        return (normal * (2 * θ)) - this;
    }

    public readonly bool Refract(in <#=typename#> normal, Scalar eta, out <#=typename#> refracted)
    {
        Scalar θ = Dot(normal);
        Scalar k = 1 - (eta * eta * (1 - (θ * θ)));
        bool res = k.IsNegative;

        refracted = res ? Reflect(-normal) : (this * eta) + normal * ((eta * θ) - k.Sqrt());

        return res;
    }

    public readonly Scalar DistanceTo(in <#=typename#> second) => DistanceTo(in second, VectorNorm.EucledianNorm);

    public readonly Scalar DistanceTo(in <#=typename#> second, VectorNorm norm) => Subtract(in second).ComputeNorm(norm);

    public T[] ToArray<T>() where T : unmanaged => DataStream.FromUnmanaged(this).ToArray<T>();

    public void ToNative<T>(T* dst) where T : unmanaged => DataStream.FromUnmanaged(this).ToPointer(dst);

    public readonly Scalar[] ToArray() => Coefficients;

    public readonly Polynomial ToPolynomial() => new(Coefficients);
<#
        if (dim > 2)
        {
#>

    public readonly Vector<#=dim-1#> FromHomogeneousCoordinates() => new(<#=string.Join(", ", comps.Take(dim - 1).Select(c => $"{c} / {comps.Last()}"))#>);
<#
        }

        if (dim < maxdim - 1)
        {
#>

    public readonly Vector<#=dim+1#> ToHomogeneousCoordinates() => new(<#=string.Join(", ", comps)#>, Scalar.One);
<#
        }
#>

    public readonly VectorN GetEntries(Range rows) => new(Coefficients[rows]); // TODO : range checks

    public readonly <#=typename#> SetEntries(Range rows, VectorN values)
    {
        // TODO : range checks

        int[] idxs = rows.GetOffsets(<#=dim#>);
        Scalar[] v = values;
        Scalar[] t = this;

        for (int i = 0; i < idxs.Length; ++i)
            t[idxs[i]] = v[i];

        return new(t);
    }

    public readonly <#=typename#> SwapEntries(int src_idx, int dst_idx)
    {
        Scalar[] res = ToArray();

        (res[src_idx], res[dst_idx]) = (res[dst_idx], res[src_idx]);

        return FromArray(res);
    }

    #endregion
    #region STATIC METHODS
<#
        if (crossable)
        {
#>

    /// <inheritdoc cref="ICrossableVector{V, S}.Cross(V)"/>
    public static <#=typename#> Cross(in <#=typename#> x, in <#=typename#> y)
<#
        if (dim == 3)
        {
#> => (
        x.Y * y.Z - y.Y * x.Z,
        x.Z * y.X - y.Z * x.X,
        x.X * y.Y - y.X * x.Y
    );
<#
        }
        else if (dim == 7)
        {
#>
    {
        var (a, b, c, d, e, f, g) = x;
        Matrix7 T = (
            0, -d, -g, b, -f, e, c,
            d, 0, -e, -a, c, -g, f,
            g, e, 0, -f, -b, d, -a,
            -b, a, f, 0, -g, -c, e,
            f, -c, b, g, 0, -a, -d,
            -e, g, -d, c, a, 0, -b,
            -c, -f, a, -e, d, b, 0
        );

        return T * y;
    }
<#
        }
#>

    /// <inheritdoc cref="ICrossableVector{V, S}.TripleProduct(V, V)"/>
    public static Scalar TripleProduct(in <#=typename#> a, in <#=typename#> b, in <#=typename#> c) => Dot(a, Cross(b, c));
<#
        }
#>

    public static <#=typename #> FromArray(params Scalar[] v) => v switch
    {
        null => throw new ArgumentNullException(nameof(v)),
        _ when v.Length < Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension}.", nameof(v)),
        _ => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>)
    };

    public static <#=typename#> FromArray<T>(params T[] array)
        where T : unmanaged
    {
        fixed (T* ptr = array)
            return FromNative(ptr);
    }

    public static <#=typename#> FromNative<T>(T* src) where T : unmanaged => new((Scalar*)src);
<#
        if (dim < maxdim - 1)
        {
#>
    public readonly <#=typename#> FromHomogeneousCoordinates(Vector<#=dim+1#> homogeneous) => homogeneous.FromHomogeneousCoordinates();
<#
        }
#>

    public static <#=typename#> Add(<#=typename#> m1, <#=typename#> m2) => m1.Add(m2);

    public static <#=typename#> Subtract(<#=typename#> m1, <#=typename#> m2) => m1.Subtract(m2);

    public static <#=typename#> Multiply(<#=typename#> m, Scalar s) => m.Multiply(s);

    public static <#=typename#> Divide(<#=typename#> m, Scalar s) => m.Divide(s);

    /// <inheritdoc cref="Algebra{S}.IEucledianVectorSpace{V}.Dot(V)"/>
    public static Scalar Dot(in <#=typename#> v1, in <#=typename#> v2) => v1.Dot(v2);

    /// <inheritdoc cref="AngleTo"/>
    public static Scalar AngleBetween(in <#=typename#> v1, in <#=typename#> v2) => v1.AngleTo(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.IsLinearDependant(V, out S?)"/>
    public static bool IsLinearDependant(in <#=typename#> v1, in <#=typename#> v2) => v1.IsLinearDependant(v2, out _);

    /// <inheritdoc cref="Algebra{S}.IVector{V, M}.OuterProduct"/>
    public static <#=matname#> OuterProduct(in <#=typename#> v1, in <#=typename#> v2) => v1.OuterProduct(v2);

    /// <inheritdoc cref="Algebra{S}.IVectorSpace{V}.LinearInterpolate(V, S)"/>
    public static <#=typename#> LinearInterpolate(in <#=typename#> v1, in <#=typename#> v2, Scalar factor) => v1.LinearInterpolate(v2, factor);

    /// <inheritdoc cref="IsLinearDependant(<#=typename#>, out Scalar?)"/>
    public static bool IsLinearDependant(in <#=typename#> v1, in <#=typename#> v2, out Scalar? factor) => v1.IsLinearDependant(v2, out factor);

    public static <#=typename#> GetRandomCartesianUnitVector<T>(T generator) where T : Numerics.Random => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(_ => "generator.NextScalar() * 2 - 1"))#>).Normalized;

    public static <#=typename#> GetRandomCartesianUnitVector() => GetRandomCartesianUnitVector(new XorShift());

    public static <#=typename#> GetNthUnitVector(int n)
    {
        if (n < 0 || n >= <#=dim#>)
            throw new ArgumentOutOfRangeException(nameof(n), "The parameter must be an integer between (inclusive) 0 and <#=dim - 1#>.");

        Scalar[] coeff = new Scalar[<#=dim#>];

        coeff[n] = Scalar.One;

        return new <#=typename#>(coeff);
    }

    // TODO : parse

    #endregion
    #region OPERATORS

    /// <summary>
    /// Compares whether the two given vectors are equal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator ==(<#=typename#> first, <#=typename#> second) => first.Is(second);

    /// <summary>
    /// Compares whether the two given vectors are unequal regarding their coefficients.
    /// </summary>
    /// <param name="first">First Vector</param>
    /// <param name="second">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator !=(<#=typename#> first, <#=typename#> second) => first.IsNot(second);

    public static bool operator true(<#=typename#> vector) => vector.Length.IsNonZero;

    public static bool operator false(<#=typename#> vector) => vector.Length.IsZero;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <(in <#=typename#> v1, in <#=typename#> v2) => v1.Length < v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer than the second one.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >(in <#=typename#> v1, in <#=typename#> v2) => v1.Length > v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is shorter or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator <=(in <#=typename#> v1, in <#=typename#> v2) => v1.Length <= v2.Length;

    /// <summary>
    /// Compares the lengths of the two given vectors and returns whether the first is longer or equally long to the second vector.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Comparison result</returns>
    public static bool operator >=(in <#=typename#> v1, in <#=typename#> v2) => v1.Length >= v2.Length;

    /// <summary>
    /// Normalizes the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Normalized vector</returns>
    public static <#=typename#> operator ~(in <#=typename#> v) => v.Normalized;

    /// <summary>
    /// Negates the given vector
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Negated vector</returns>
    public static <#=typename#> operator -(in <#=typename#> v) => v * -1;

    /// <summary>
    /// Identity function (returns the given vector unchanged)
    /// </summary>
    /// <param name="v">Original vector</param>
    /// <returns>Unchanged vector</returns>
    public static <#=typename#> operator +(in <#=typename#> v) => v;

    public static <#=typename#> operator ++(in <#=typename#> v) => v.Increment();

    public static <#=typename#> operator --(in <#=typename#> v) => v.Decrement();

    /// <summary>
    /// Performs the addition of two vectors by adding their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Addition result</returns>
    public static <#=typename#> operator +(in <#=typename#> v1, in <#=typename#> v2) => v1.Add(v2);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static <#=typename#> operator +(in <#=typename#> v, Scalar f) => v + new <#=typename#>(f);

    /// <summary>
    /// Performs the addition of a vector with the given Scalar by adding the Scalar to each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Addition result</returns>
    public static <#=typename#> operator +(Scalar f, in <#=typename#> v) => v + f;

    /// <summary>
    /// Performs the subtraction of two vectors by subtracting their respective coefficients.
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Subtraction result</returns>
    public static <#=typename#> operator -(in <#=typename#> v1, in <#=typename#> v2) => v1 + -v2;

    /// <summary>
    /// Performs the subtraction of a Scalar from vector by subtracting the Scalar from each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static <#=typename#> operator -(in <#=typename#> v, Scalar f) => v + -f;

    /// <summary>
    /// Performs the subtraction of a vector from a Scalar value.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Subtraction result</returns>
    public static <#=typename#> operator -(Scalar f, in <#=typename#> v) => -v + f;

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static <#=typename#> operator *(in <#=typename#> v, Scalar f) => v.Multiply(f);

    /// <summary>
    /// Performs the multiplication of a vector with the given Scalar by mulitplying the Scalar with each of the vector's coefficents.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Multiplication result</returns>
    public static <#=typename#> operator *(Scalar f, in <#=typename#> v) => v.Multiply(f);

    /// <summary>
    /// Calculates the dot product of two vectors by multiplying their respective coefficients and summing them. THIS IS NOT TO BE CONFUSED WITH THE COMPONENT-WISE PRODUCT!
    /// </summary>
    /// <param name="v1">First vector</param>
    /// <param name="v2">Second vector</param>
    /// <returns>Dot product</returns>
    public static Scalar operator *(in <#=typename#> v1, in <#=typename#> v2) => v1.Dot(in v2);

    public static <#=typename#> operator ^(in <#=typename#> m, int c) => m.Power(c);

    /// <summary>
    /// Performs the division of a vector by the given Scalar by dividing each of the vector's coefficents by the Scalar.
    /// </summary>
    /// <param name="v">Vector</param>
    /// <param name="f">Scalar value</param>
    /// <returns>Division result</returns>
    public static <#=typename#> operator /(in <#=typename#> v, Scalar f) => v.Divide(f);

    public static <#=typename#> operator /(Scalar f, in <#=typename#> v) => new <#=typename#>(f).ComponentwiseDivide(in v);

    /// <summary>
    /// Performs the division of two vectors by dividing each of the vector's respective coefficents by each other.
    /// </summary>
    /// <param name="v1">First Vector</param>
    /// <param name="v2">Second Vector</param>
    /// <returns>Division result</returns>
    public static Scalar operator /(in <#=typename#> v1, in <#=typename#> v2)
    {
        Scalar[] components = v1.ToArray().Zip(v2.ToArray(), (x1, x2) => x1 / x2).Distinct().ToArray();

        return components.Length == 1 ? components[0] : Scalar.NaN;
    }

    public static <#=typename#> operator %(in <#=typename#> v, Scalar f) => v.Modulus(f);

    public static <#=typename#> operator %(in <#=typename#> v1, in <#=typename#> v2) => v1.ComponentwiseModulus(in v2);

    public static implicit operator num.Vector<Scalar>(<#=typename#> v) => new(v.Coefficients.Cast<Scalar>().ToArray());

    public static implicit operator num.Vector<double>(<#=typename#> v) => new(v.Coefficients.Cast<double>().ToArray());

    public static implicit operator num.Vector<float>(<#=typename#> v) => new(v.Coefficients.Cast<float>().ToArray());

    public static implicit operator num.Vector<long>(<#=typename#> v) => new(v.Coefficients.Cast<long>().ToArray());

    public static implicit operator num.Vector<int>(<#=typename#> v) => new(v.Coefficients.Cast<int>().ToArray());

    public static implicit operator <#=typename#>(num.Vector<Scalar> v) => new(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>);

    public static implicit operator <#=typename#>(num.Vector<double> v) => new(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>);

    public static implicit operator <#=typename#>(num.Vector<float> v) => new(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>);

    public static implicit operator <#=typename#>(num.Vector<long> v) => new(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>);

    public static implicit operator <#=typename#>(num.Vector<int> v) => new(<#=string.Join(", ", r(0, dim).Select(i => $"v[{i}]"))#>);

    public static implicit operator Scalar[](in <#=typename#> v) => v.Coefficients;

    public static explicit operator <#=typename#>(Scalar[] arr) => new(arr);

    public static explicit operator <#=typename#>(Scalar s) => new(s);

    public static implicit operator (<#=string.Join(", ", r(0, dim).Select(i => "Scalar x" + i))#>) (in <#=typename#> v) => (<#=string.Join(", ", comps.Select(s => "v." + s))#>);

    public static implicit operator <#=typename#>((<#=string.Join(", ", r(0, dim).Select(i => "Scalar x" + i))#>) t) => new(<#=string.Join(", ", r(0, dim).Select(i => "t.x" + i))#>);
<#
        if (dim > 2)
        {
#>

    public static implicit operator (Scalar x0, Vector<#=dim-1#> v1)(in <#=typename#> v) => (v._0, (<#=string.Join(", ", r(1, dim - 1).Select(i => "v._" + i))#>));

    public static implicit operator (Vector<#=dim-1#> v0, Scalar x1)(in <#=typename#> v) => ((<#=string.Join(", ", r(0, dim - 1).Select(i => "v._" + i))#>), v._<#=dim-1#>);
<#
        }
#>

    public static implicit operator Polynomial(in <#=typename#> v) => v.ToPolynomial();

    public static explicit operator <#=typename#>(in Polynomial p) => new(p.Coefficients);

    public static implicit operator VectorN(in <#=typename#> v) => new(v.ToArray());

    public static explicit operator <#=typename#>(in VectorN v) => new(v.Coefficients);

    #endregion

    public sealed class <#=typename#>EqualityComparer
        : IEqualityComparer<<#=typename#>>
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=typename#> x, <#=typename#> y) => x.Is(y);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public int GetHashCode(<#=typename#> obj) => obj.GetHashCode();
    }
}

public static class <#=typename#>Extensions
{
    public static <#=typename#> Sum(this IEnumerable<<#=typename#>> vectors) => <#=typename#>.Zero.Add(vectors.ToArray());

    public static <#=typename#> Average(this IEnumerable<<#=typename#>> vectors)
    {
        <#=typename#> vec = <#=typename#>.Zero;
        long count = 0;

        foreach (<#=typename#> v in vectors)
        {
            vec = vec.Add(in v);
            ++count;
        }

        return vec.Divide(count);
    }
}

#endregion
<#
    }
#>
#region VectorN (Extensions)

public partial class VectorN
{
    public Algebra<Scalar>.IVector Cast() => Size switch
    {
        1 => this[0],
<#
    for (int i = 2; i < maxdim; ++i)
        WriteLine($"        {i} => (Vector{i})this,");
#>
        _ => new VectorN(this) as Algebra<Scalar>.IVector
    };
}

#endregion

public enum VectorNorm
{
    EucledianNorm = 0,
<#
    for (int i = 0; i <= maxdim; ++i)
        if (i < comp.Length)
            WriteLine($"    {comp[i]}Coordinate = {i + 1},");
        else
            WriteLine($"    // TODO = {i + 1},");
#>
    TaxicabNorm,
    MaximumNorm,
    ManhattanNorm = TaxicabNorm,
    Linf_Norm = MaximumNorm,
}
