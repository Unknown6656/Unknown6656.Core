<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
///////////////////////////////////////////////////////////////////////
//             AUTOGENERATED <#=DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss.ffffff")#>              //
//   All your changes to this file will be lost upon re-generation.  //
///////////////////////////////////////////////////////////////////////

#define READONLY

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using System.Collections;
using System.Diagnostics;
using System.Linq;
using System;

using MathLibrary.Analysis;

using static System.Math;


namespace MathLibrary.LinearAlgebra
{
<#
    int maxdim = 4;

    try
    {
        string path = Host.ResolvePath("../maxdim.txt");

        maxdim = int.Parse(File.ReadAllText(path).Trim()) + 1;
    }
    catch { }

    IEnumerable<int> r(int f, int t) => Enumerable.Range(f, t);

    for (int dim = 2; dim < maxdim; ++dim)
    {
        string[] cols = r(0, dim).Select(i => "_c" + i).ToArray();
        string typename = "Matrix" + dim;
        string vecname = "Vector" + dim;
#>
    #region <#=typename#>

    /// <summary>
    /// Represents a square <#=dim#>x<#=dim#> matrix.
    /// </summary>
    /// <inheritdoc cref="IMatrix{M,V,S}"/>
    [StructLayout(LayoutKind.Sequential), NativeCppClass]
#if READONLY
    readonly
#endif
    public unsafe partial struct <#=typename#>
        : IMatrix<<#=typename#>, <#=vecname#>, Scalar>
        , IEnumerable<<#=vecname#>>
        , IEnumerable<Scalar>
#if READONLY
    {
<#
        foreach (string col in cols)
        {
#>
        private readonly <#=vecname#> <#=col#>;
<#
        }
#>
#else
        , INative
    {
<#
        foreach (string col in cols)
        {
#>
        private <#=vecname#> <#=col#>;
<#
        }
#>
#endif


        /// <inheritdoc cref="IMatrix.Size"/>
        public const int Dimension = <#=dim#>;

        /// <summary>
        /// The <#=dim#>x<#=dim#> zero matrix
        /// </summary>
        public static <#=typename#> Zero { get; } = new <#=typename#>(0);

        /// <summary>
        /// The <#=dim#>x<#=dim#> identity (unit) matrix
        /// </summary>
        public static <#=typename#> Identity { get; } = new <#=typename#>(1);

        /// <summary>
        /// The raw memory size of the <see cref="<#=typename#>"/>-structure in bytes.
        /// </summary>
        public int BinarySize { get; } = sizeof(<#=typename#>);


        /// <inheritdoc/>
        public <#=vecname#> this[int column]
        {
            get => column switch
            {
<#=string.Join("\n", r(0, dim).Select(i => $"\t\t\t\t{i} => {cols[i]},"))#>
                _ => throw new IndexOutOfRangeException()
            };
#if !READONLY
            set
            {
<#
        for (int i = 0; i < dim; ++i)
        {
#>
                <#=i > 0 ? "else " : ""#>if (column == <#=i#>) <#=cols[i]#> = value;
<#
        }
#>
                else throw new IndexOutOfRangeException();
            }
#else
        }
        
        /// <inheritdoc/>
        public <#=typename#> this[int column, <#=vecname#> vector]
        {
            get
            {
                <#=vecname#>[] arr = (<#=vecname#>[])this;

                arr[column] = vector;

                return arr;
            }
#endif
        }

        /// <inheritdoc/>
        public Scalar this[int column, int row]
        {
            get => this[column][row];
#if !READONLY
            set
            {
                <#=vecname#> v = this[column];

                v[row] = value;
                this[column] = v;
            }
#else
        }
        
        /// <inheritdoc/>
        public <#=typename#> this[int column, int row, Scalar new_value]
        {
            get
            {
                Scalar[] arr = (Scalar[])this;

                arr[row * Dimension + column] = new_value;

                return arr;
            }
#endif
        }

        /// <inheritdoc/>
        public Scalar Sum => ToArray().Sum();

        /// <inheritdoc/>
        public Scalar Avg => ToArray().Avg();

        /// <inheritdoc/>
        public Scalar Min => ToArray().Min();

        /// <inheritdoc/>
        public Scalar Max => ToArray().Max();

        /// <inheritdoc/>
        public bool IsInvertible => Abs(Determinant) >= Scalar.Epsilon;

        /// <inheritdoc/>
        public bool IsSymmetric => this == Transposed;

        /// <inheritdoc/>
        public bool IsProjection => this == this * this;

        /// <inheritdoc/>
        public bool IsInvolutory => this * Inverse == Identity;

        /// <inheritdoc/>
        public bool IsHollow => MainDiagonal == <#=vecname#>.Zero;

        /// <inheritdoc/>
        public bool IsPositive => ToArray().All(c => c > 0);

        /// <inheritdoc/>
        public bool IsNegative => ToArray().All(c => c < 0);
        
        /// <inheritdoc/>
        public bool HasNaNs => <#=string.Join(" || ", r(0, dim).Select(i => $"_c{i}.HasNaNs"))#>;

        /// <inheritdoc/>
        

        /// <inheritdoc/>
<#
        if (dim == 2)
        {
#>
        public bool IsHurwitzStable => this[0, 0] > 0 && Determinant > 0;
<#
        }
        else
        {
#>
        public bool IsHurwitzStable => GetPrincipalSubmatrices().Aggregate(true, (b, m) => b && m.Determinant > 0) && this[0, 0] > 0;
<#
        }
#>

        /// <inheritdoc/>
        public bool IsOrthogonal => Inverse == Transposed;

        /// <inheritdoc/>
        public bool IsSkewSymmetric => this == -Transposed;

        /// <inheritdoc/>
        public bool IsSignMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 0 || e == 1);

        /// <inheritdoc/>
        public bool IsSignatureMatrix => IsDiagonal && MainDiagonal.All(e => e == -1 || e == 1);
        
        /// <inheritdoc/>
        public bool IsConferenceMatrix
        {
            get
            {
                <#=typename#> ctc = Transposed * this;

                return (ctc - new <#=typename#>(ctc[0, 0])).IsZero;
            }
        }

        /// <inheritdoc/>
        public int Size => Dimension;

        /// <inheritdoc/>
        public <#=vecname#> MainDiagonal => (<#=string.Join(", ", r(0, dim).Select(i => $"this[{i}, {i}]"))#>);

        /// <inheritdoc/>
        public <#=vecname#>[] Columns => new[] { <#=string.Join(", ", cols)#> };

        /// <inheritdoc/>
        public <#=vecname#>[] Rows => Transposed.Columns;

        /// <inheritdoc/>
        public Scalar Trace => <#=string.Join(" + ", r(0, dim).Select(i => $"this[{i}, {i}]"))#>;
        
        /// <inheritdoc/>
        public <#=typename#> GaussianReduced => GetLinearIndependentForm();

        /// <inheritdoc/>
        public <#=typename#> Transposed => (
            <#=string.Join(",\n            ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"this[{y}, {x}]"))))#>
        );

        /// <inheritdoc/>
        [DebuggerHidden, DebuggerBrowsable(DebuggerBrowsableState.Never), Obsolete("Use the member 'Scalar <#=typename#>::Inverse' instead.")]
        public <#=typename#> MultiplicativeInverse => Inverse;

        /// <inheritdoc/>
        public <#=typename#> Inverse
        {
            get
            {
                Scalar det = Determinant;

                if (det.IsZero)
                    throw new InvalidOperationException("This matrix is not invertible, as its determinant is zero.");

<#
        if (dim == 2)
        {
#>
                det = 1 / det;

                return new Matrix2(
                    +this[1, 1] * det,
                    -this[0, 1] * det,
                    -this[1, 0] * det,
                    +this[0, 0] * det
                );
            }
        }

        /// <inheritdoc/>
        public Scalar Determinant => this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1];

        /// <inheritdoc/>
        public Polynomial CharacteristicPolynomial => new Polynomial(Determinant, - this[0, 0] - this[1, 1], 1);
<#
        }
        else if (dim == 3)
        {
#>
                det = 1 / det;

                return (
                    +(this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2]) * det,
                    -(this[1, 0] * this[2, 2] - this[2, 0] * this[1, 2]) * det,
                    +(this[1, 0] * this[2, 1] - this[2, 0] * this[1, 1]) * det,
                    -(this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2]) * det,
                    +(this[0, 0] * this[2, 2] - this[2, 0] * this[0, 2]) * det,
                    -(this[0, 0] * this[2, 1] - this[2, 0] * this[0, 1]) * det,
                    +(this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]) * det,
                    -(this[0, 0] * this[1, 2] - this[1, 0] * this[0, 2]) * det,
                    +(this[0, 0] * this[1, 1] - this[1, 0] * this[0, 1]) * det
                );
            }
        }

        /// <inheritdoc/>
        public Scalar Determinant => this[0, 0] * (this[1, 1] * this[2, 2] - this[2, 1] * this[1, 2])
                                   - this[1, 0] * (this[0, 1] * this[2, 2] - this[2, 1] * this[0, 2])
                                   + this[2, 0] * (this[0, 1] * this[1, 2] - this[1, 1] * this[0, 2]);

        /*
                 | a b c |                    | a-λ  b   c  |
            φ := | d e f |       CP_φ(λ) = det|  d  e-λ  f  | = (a-λ)[MINOR @ 0,0] - λ(gc + db) - gbf - gce - dbi + dhc
                 | g h i |                    |  g   h  i-λ |
                                                              = - λ³
                                                                + λ²(a + e + i)
                                                                + λ(fh + cg + bd - ae - ai - ei)
                                                                + (-afh - ecg - ibd + aei + cdh + bfg)
        */
        /// <inheritdoc/>
        public Polynomial CharacteristicPolynomial
        {
            get
            {
                var (a, b, c,
                     d, e, f,
                     g, h, i) = this;

                return new Polynomial(
                    - a * f * h
                    - e * c * g
                    - i * b * d
                    + a * e * i
                    + c * d * h
                    + b * f * g,
                    + f * h
                    + c * g
                    + b * d
                    - a * e
                    - a * i
                    - e * i,
                    a + e + i,
                    -1
                );
            }
        }
<#
        }
        else
        {
            if (dim == 4)
            {
#>
                var (m00, m01, m02, m03,
                     m10, m11, m12, m13,
                     m20, m21, m22, m23,
                     m30, m31, m32, m33) = this;

                m00 = (m12 * m23 * m31) - (m13 * m22 * m31) + (m13 * m21 * m32) - (m11 * m23 * m32) - (m12 * m21 * m33) + (m11 * m22 * m33);
                m01 = (m03 * m22 * m31) - (m02 * m23 * m31) - (m03 * m21 * m32) + (m01 * m23 * m32) + (m02 * m21 * m33) - (m01 * m22 * m33);
                m02 = (m02 * m13 * m31) - (m03 * m12 * m31) + (m03 * m11 * m32) - (m01 * m13 * m32) - (m02 * m11 * m33) + (m01 * m12 * m33);
                m03 = (m03 * m12 * m21) - (m02 * m13 * m21) - (m03 * m11 * m22) + (m01 * m13 * m22) + (m02 * m11 * m23) - (m01 * m12 * m23);
                m10 = (m13 * m22 * m30) - (m12 * m23 * m30) - (m13 * m20 * m32) + (m10 * m23 * m32) + (m12 * m20 * m33) - (m10 * m22 * m33);
                m11 = (m02 * m23 * m30) - (m03 * m22 * m30) + (m03 * m20 * m32) - (m00 * m23 * m32) - (m02 * m20 * m33) + (m00 * m22 * m33);
                m12 = (m03 * m12 * m30) - (m02 * m13 * m30) - (m03 * m10 * m32) + (m00 * m13 * m32) + (m02 * m10 * m33) - (m00 * m12 * m33);
                m13 = (m02 * m13 * m20) - (m03 * m12 * m20) + (m03 * m10 * m22) - (m00 * m13 * m22) - (m02 * m10 * m23) + (m00 * m12 * m23);
                m20 = (m11 * m23 * m30) - (m13 * m21 * m30) + (m13 * m20 * m31) - (m10 * m23 * m31) - (m11 * m20 * m33) + (m10 * m21 * m33);
                m21 = (m03 * m21 * m30) - (m01 * m23 * m30) - (m03 * m20 * m31) + (m00 * m23 * m31) + (m01 * m20 * m33) - (m00 * m21 * m33);
                m22 = (m01 * m13 * m30) - (m03 * m11 * m30) + (m03 * m10 * m31) - (m00 * m13 * m31) - (m01 * m10 * m33) + (m00 * m11 * m33);
                m23 = (m03 * m11 * m20) - (m01 * m13 * m20) - (m03 * m10 * m21) + (m00 * m13 * m21) + (m01 * m10 * m23) - (m00 * m11 * m23);
                m30 = (m12 * m21 * m30) - (m11 * m22 * m30) - (m12 * m20 * m31) + (m10 * m22 * m31) + (m11 * m20 * m32) - (m10 * m21 * m32);
                m31 = (m01 * m22 * m30) - (m02 * m21 * m30) + (m02 * m20 * m31) - (m00 * m22 * m31) - (m01 * m20 * m32) + (m00 * m21 * m32);
                m32 = (m02 * m11 * m30) - (m01 * m12 * m30) - (m02 * m10 * m31) + (m00 * m12 * m31) + (m01 * m10 * m32) - (m00 * m11 * m32);
                m33 = (m01 * m12 * m20) - (m02 * m11 * m20) + (m02 * m10 * m21) - (m00 * m12 * m21) - (m01 * m10 * m22) + (m00 * m11 * m22);

                return new Matrix4(
                    m00, m01, m02, m03,
                    m10, m11, m12, m13,
                    m20, m21, m22, m23,
                    m30, m31, m32, m33
                ) / det;
<#
            }
            else
            {
#>
                <#=typename#> m = this;
                <#=typename#> u = Identity;

                for (int i = 0; i < Dimension; ++i)
                {
                    int max = i;

                    for (int j = i + 1; j < Dimension; j++)
                        if (Abs(m[i, j]) > Abs(m[i, max]))
                            max = j;

                    m = m.SwapRows(i, max);
                    u = u.SwapRows(i, max);

                    Scalar top = 1 / m[i, i];

                    if (top.IsInfinity)
                        continue;

                    u = u.MultiplyRow(i, top);
                    m = m.MultiplyRow(i, top)[i, i, 1];

                    for (int j = i + 1; j < Dimension; ++j)
                    {
                        Scalar f = m[i, j];

                        m = m.AddRows(i, j, -f);
                        u = u.AddRows(i, j, -f);
                    }
                }

                for (int i = Dimension - 1; i > 0; --i)
                    if (!m[i, i].IsZero)
                        for (int row = 0; row < i; ++row)
                        {
                            Scalar f = m[i, row];

                            m = m.AddRows(i, row, -f);
                            u = u.AddRows(i, row, -f);
                        }

                return u;
<#
            }
#>
            }
        }

        /// <inheritdoc/>
        public Scalar Determinant => <#=string.Join("\n\t\t\t\t\t\t\t\t\t ", r(0, dim).Select(i => $"{((i % 2) == 0 ? '+' : '-')} Minor(0, {i}).Determinant"))#>;

        /// <inheritdoc/>
        public Polynomial CharacteristicPolynomial
        {
            get
            {
                if (IsUpperTriangular || IsLowerTriangular || IsDiagonal)
                    ; // TODO: CP is linear product of the main diagonal and -λ

                throw new NotImplementedException();
            }
        }
<#
        }
#>

        /// <inheritdoc/>
        public Scalar[] Eigenvalues => (IsUpperTriangular || IsLowerTriangular || IsDiagonal ? MainDiagonal.ToArray().Distinct() : CharacteristicPolynomial.Roots.Select(r => (Scalar)r)).ToArray();

        /// <inheritdoc/>
        public <#=typename#> OrthonormalBasis
        {
            get
            {
                <#=vecname#>[] vs = new <#=vecname#>[<#=dim#>];

                for (int i = 0; i < Dimension; ++i)
                {
                    vs[i] = this[i];

                    for (int j = 0; j < i; ++ j)
                        vs[i] -= this[i].Dot(vs[j]) * vs[j];

                    vs[i] = vs[i].Normalized;
                }

                return vs;
            }
        }

        /// <inheritdoc/>
        public bool IsZero => this == Zero;

        /// <inheritdoc/>
        public bool IsIdentity => this == Identity;

        /// <inheritdoc/>
        public bool IsDiagonal
        {
            get
            {
                for (int c = 0; c < <#=dim#>; ++c)
                    for (int r = 0; r < <#=dim#>; ++r)
                        if ((r != c) && !this[c, r].IsZero)
                            return false;

                return true;
            }
        }

        /// <inheritdoc/>
        public bool IsUpperTriangular
        {
            get
            {
                for (int c = 0; c < <#=dim#>; ++c)
                    for (int r = c + 1; r < <#=dim#>; ++r)
                        if (!this[c, r].IsZero)
                            return false;

                return true;
            }
        }

        /// <inheritdoc/>
        public bool IsLowerTriangular => Transposed.IsUpperTriangular;

        /// <inheritdoc/>
        public int Rank => GetLinearIndependentForm().Rows.Count(c => c != <#=vecname#>.Zero);

<#
        if (dim > 3)
        {
            string tstr = string.Join(", ", r(2, dim - 2).Select(i => $"Matrix{i} Sub{i}"));
#>
        /// <summary>
        /// A set of the first <#=dim-2#> principal submatrices
        /// </summary>
        public (<#=tstr#>) PrincipalSubmatrices =>
            (<#=string.Join(", ", r(2, dim - 2).Select(i => $"ToMatrix{i}()"))#>);

<#
        }
#>


        public <#=typename#>(Scalar scale)
            : this(<#=string.Join(",\n\t\t\t\t   ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => j == i ? "scale" : "0"))})"))#>)
        {
        }

        public <#=typename#>(IEnumerable<<#=vecname#>> cols)
            : this() => FromArray(cols.Take(Dimension).ToArray());

        public <#=typename#>(params Scalar[] values)
            : this() => FromArray(values.Take(Dimension * Dimension).ToArray());

        public <#=typename#>(<#=typename#>* ptr)
            : this(ptr->Columns)
        {
        }

        public <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"{vecname} v{i}"))#>)
        {
<#
        for (int i = 0; i < dim; ++i)
        {
#>
            <#=cols[i]#> = v<#=i#>;
<#
        }
#>
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Add(<#=typename#> second) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"_c{i} + second._c{i}"))#>);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Add(Scalar Scalar) => Add(new <#=typename#>(Scalar));

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Negate() => Multiply(-1f);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Subtract(Scalar Scalar) => Add(-Scalar);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Multiply(<#=typename#> second)
        {
            int[] range = { <#=string.Join(", ", Enumerable.Range(0, dim))#> };

            fixed (<#=typename#>* ptr = &this)
            {
                <#=vecname#>* vptr = (<#=vecname#>*)ptr;

                return new <#=typename#>(range.Select(j => new <#=vecname#>(range.Select(i => range.Sum(k => vptr[k][j] * second[i, k])))));
            }
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=vecname#> Multiply(<#=vecname#> vector) => new <#=vecname#>(
            <#=string.Join(",\n            ", Enumerable.Range(0, dim).Select(i => string.Join(" + ", Enumerable.Range(0, dim).Select(j => $"_c{i}[{j}] * vector[{j}]"))))#>
        );

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Multiply(Scalar factor) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"this[{i}] * factor"))#>);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Divide(Scalar factor) => Multiply(1 / factor);

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> ComponentwiseDivide(<#=typename#> second) => new <#=typename#>(
            <#=string.Join(",\n            ", Enumerable.Range(0, dim).Select(i => string.Join(", ", Enumerable.Range(0, dim).Select(j => $"_c{j}[{i}] / second._c{j}[{i}]"))))#>
        );

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> Power(int e)
        {
            if (e < 0)
                return Power(-e).Inverse;
                // throw new ArgumentOutOfRangeException(nameof(e));
                
            <#=typename#> r = Identity;

            for (int i = 0; i < e; ++i)
                r = r.Multiply(this);

            return r;
        }

        /// <inheritdoc />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=vecname#> Solve(<#=vecname#> v)
        {
            <#=typename#> m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);
                v = v.SwapEntries(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                v = v[i, v[i] * top];
                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < Dimension; ++j)
                {
                    Scalar f = m[i, j];

                    m = m.AddRows(i, j, -f);
                    v = v[j, v[j] - v[i] * f];
                }
            }

            for (int i = Dimension - 1; i > 0; --i)
                if (!m[i, i].IsZero)
                    for (int row = 0; row < i; ++row)
                    {
                        Scalar f = m[i, row];

                        m = m.AddRows(i, row, -f);
                        v = v[row, v[row] - v[i] * f];
                    }

            return v;
        }

        internal <#=typename#> GetLinearIndependentForm()
        {
            <#=typename#> m = this;

            for (int i = 0; i < Dimension; ++i)
            {
                int max = i;

                for (int j = i + 1; j < Dimension; j++)
                    if (Abs(m[i, j]) > Abs(m[i, max]))
                        max = j;

                m = m.SwapRows(i, max);

                Scalar top = 1 / m[i, i];

                if (top.IsInfinity)
                    continue;

                m = m.MultiplyRow(i, top)[i, i, 1];

                for (int j = i + 1; j < Dimension; ++j)
                    m = m.AddRows(i, j, -m[i, j]);
            }

            return m;
        }


        /* TODO : fix
        public (Matrix3 L, Matrix3 U) LUDecompose()
        {
            mat3 U = (Matrix3)Clone();
            Scalar k21 = U[0, 1] / U[0, 0];
            Scalar k31 = U[0, 2] / U[0, 0];

            U = U.Transform(new MatrixRowAdd<Matrix3, Vector3>(0, 1, -k21));
            U = U.Transform(new MatrixRowAdd<Matrix3, Vector3>(0, 2, -k31));

            Scalar k32 = U[1, 2] / U[1, 1];

            U = U.Transform(new MatrixRowAdd<Matrix3, Vector3>(1, 2, -k32));

            return ((
                        (1, 0, 0),
                        (k21, 1, 0),
                        (k31, k32, 1)
                    ), U);
        }
        */

        /// <inheritdoc/>
        public (<#=typename#> U, <#=typename#> D) IwasawaDecompose()
        {
            <#=typename#> ONB = OrthonormalBasis;
            <#=typename#> D = ONB.Transposed * this;

            return (ONB, D);
        }

        /// <inheritdoc/>
        public IMatrix<Scalar>[] GetPrincipalSubmatrices()
<#
        if (dim > 3)
        {
#>
        {
            (<#=string.Join(", ", r(2, dim - 2).Select(i => $"Matrix{i} Sub{i}"))#>) = PrincipalSubmatrices;

            return new IMatrix<Scalar>[] { <#=string.Join(", ", r(2, dim - 2).Select(i => $"Sub{i}"))#> };
        }
<#
        }
        else if (dim == 3)
        {
#>
            => new IMatrix<Scalar>[] { ToMatrix2() };
<#
        }
        else
        {
#>
            => new IMatrix<Scalar>[0];
<#
        }
#>

        /// <inheritdoc/>
        public static <#=typename#> FromArray(Scalar[] arr) => arr switch {
            null => throw new ArgumentNullException(nameof(arr)),
            _ when arr.Length < Dimension * Dimension => throw new ArgumentException($"The array must have a minimum length of {Dimension * Dimension}.", nameof(arr)),
            _ => new <#=typename#>(
                <#=string.Join(",\n                ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"arr[{y * dim + x,2}]"))))#>
            )
        };

        /// <inheritdoc/>
        public static <#=typename#> FromArray(<#=vecname#>[] arr) => arr switch {
            null => throw new ArgumentNullException(nameof(arr)),
            _ when arr.Length != Dimension => throw new ArgumentException($"The array must have an exact length of {Dimension}.", nameof(arr)),
            _ => new <#=typename#>(
                <#=string.Join(",\n                ", r(0, dim).Select(y => string.Join(", ", r(0, dim).Select(x => $"arr[{x}][{y}]"))))#>
            )
        };

        /// <inheritdoc/>
        public Scalar[] ToArray() => Columns.SelectMany(v => v.ToArray()).ToArray();
        
        /// <inheritdoc/>
        public T[] ToArray<T>() where T : unmanaged => new[] { this }.BinaryCopy<<#=typename#>, T>(BinarySize);
<#
        for (int i = 2; i <= dim - 1; ++i)
        {
#>

        /// <summary>
        /// Returns the upper-left <#=i#>x<#=i#> sub-matrix by copying all respective coefficients
        /// </summary>
        /// <returns><#=i#>x<#=i#> sub-matrix</returns>
        public Matrix<#=i#> ToMatrix<#=i#>() => (
<#
            for (int j = 0; j < i; ++j)
            {
#>
            (<#=string.Join(", ", r(0, i).Select(k => $"{cols[j]}[{k}]"))#>)<#=j < i - 1 ? "," : ""#>
<#
            }
#>
        );
<#
        }
#>

        /// <summary>
        /// Returns the matrix' <#=dim-1#>x<#=dim-1#>-minor at the given indices
        /// </summary>
        /// <param name="column">Zero-based column index</param>
        /// <param name="row">Zero-based row index</param>
        /// <returns><#=dim-1#>x<#=dim-1#>-minor</returns>
<#
        if (dim == 2)
        {
#>
        public Scalar Minor(int column, int row) => (column, row) switch
        {
            (0, 0) => this[1, 1],
            (0, 1) => this[1, 0],
            (1, 0) => this[0, 1],
            (1, 1) => this[0, 0],
            _ => throw new IndexOutOfRangeException()
        };
<#
        }
        else if (dim > 2)
        {
#>
        public Matrix<#=dim-1#> Minor(int column, int row) => new Matrix<#=dim-1#>(
            Columns.Take(column).Concat(Columns.Skip(column + 1)).Select(v =>
            {
                Scalar[] f = v.ToArray();

                return new Vector<#=dim-1#>(f.Take(row).Concat(f.Skip(row + 1)));
            }));
<#
        }
#>

        /// <inheritdoc/>
        public <#=typename#> AddColumns(int src_col, int dst_col) => AddColumns(src_col, dst_col, 1);

        /// <inheritdoc/>
        public <#=typename#> AddColumns(int src_col, int dst_col, Scalar factor)
        {
            <#=vecname#>[] res = Columns;

            res[dst_col] += res[src_col] * factor;

            return FromArray(res);
        }

        /// <inheritdoc/>
        public <#=typename#> AddRows(int src_row, int dst_row) => AddRows(src_row, dst_row, 1);

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> AddRows(int src_row, int dst_row, Scalar factor) => Transposed.AddColumns(src_row, dst_row, factor).Transposed;

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> SwapColumns(int src_col, int dst_col)
        {
            <#=vecname#>[] cols = Columns;
            <#=vecname#> tmp = cols[dst_col];

            cols[dst_col] = cols[src_col];
            cols[src_col] = tmp;

            return new <#=typename#>(cols);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> SwapRows(int src_row, int dst_row) => Transposed.SwapColumns(src_row, dst_row).Transposed;

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> MultiplyColumn(int col, Scalar factor)
        {
            <#=vecname#>[] cols = Columns;

            cols[col] *= factor;

            return new <#=typename#>(cols);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public <#=typename#> MultiplyRow(int row, Scalar factor) => Transposed.MultiplyColumn(row, factor).Transposed;

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object obj) => obj is <#=typename#> v && Equals(v);

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(<#=typename#> other) => <#=string.Join(" && ", r(0, dim).Select(i => $"this[{i}] == other[{i}]"))#>;

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => <#=string.Join(" ^ ", cols.Select(c => c + ".GetHashCode()"))#>;
        
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(bool @short) => @short ? ToShortString() : ToString();

        /// <summary>
        /// The <#=dim#>x<#=dim#>-matrix' string representation
        /// </summary>
        /// <returns>String representation</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => string.Join("\n", Transposed.Columns.Select(c => $"| {string.Join(", ", c.ToArray().Select(f => $"{f,22:F16}"))} |"));

        /// <summary>
        /// The <#=dim#>x<#=dim#>-matrix' short string representation
        /// </summary>
        /// <returns>Short string representation</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToShortString() => string.Join("\n", (from col in Columns
                                                            let strings = (from entry in col.ToArray().Select(f => $"{f,22:F16}")
                                                                           let end = entry.Reverse().TakeWhile(c => c == '0').Count()
                                                                           select new
                                                                           {
                                                                               entry,
                                                                               front = entry.TakeWhile(c => c == ' ').Count(),
                                                                               back = entry[entry.Length - 1 - end] == '.' ? end + 1 : end
                                                                           }).ToArray()
                                                            let f = strings.Min(c => c.front)
                                                            let b = strings.Min(c => c.back)
                                                            select strings.Select(e => e.entry!.Substring(f, e.entry.Length - f - b)).ToArray()).Transpose().Select(r => $"| {string.Join(", ", r)} |"));

        public IEnumerator<<#=vecname#>> GetEnumerator() => ((IEnumerable<<#=vecname#>>)Columns).GetEnumerator();

        IEnumerator<Scalar> IEnumerable<Scalar>.GetEnumerator() => Columns.SelectMany(v => v.AsEnumerable()).GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

        public void Deconstruct(<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"out Scalar x{i}{j}")))#>) =>
            (<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"x{i}{j}")))#>) = (<#=string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"this[{j}, {i}]")))#>);
            
        public void Deconstruct(<#=string.Join(", ", r(0, dim).Select(i => $"out {vecname} v{i}"))#>) =>
            (<#=string.Join(", ", r(0, dim).Select(i => "v" + i))#>) = (<#=string.Join(", ", r(0, dim).Select(i => "_c" + i))#>);
            
        /// <inheritdoc/>
        public int CompareTo(<#=typename#> other) => other == this ? 0 : throw new NotImplementedException();

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ToNative<T>(T* dst) where T : unmanaged => ToArray().BinaryCopy(dst, BinarySize);

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void FromNative<T>(T* src)
            where T : unmanaged
        {
            byte* psrc = (byte*)src;

            fixed (<#=typename#>* ptr = &this)
                for (int i = 0; i < BinarySize; ++i)
                    *((byte*)ptr + i) = psrc[i];
        }

        /// <inheritdoc cref="FromNative{T}"/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> FromPointer<T>(T* src)
            where T : unmanaged
        {
            <#=typename#> m = default;

            m.FromNative(src);

            return m;
        }

        public static <#=typename#> SingleEntryMatrix(int row, int column) => SingleEntryMatrix(row, column, 1);

        public static <#=typename#> SingleEntryMatrix(int row, int column, Scalar value)
        {
            Scalar[] m = new Scalar[<#=dim * dim#>];

            m[column + row * Dimension] = value;

            return m;
        }

        public static <#=typename#> DiagonalMatrix(Scalar scalar) => Identity * scalar;

        public static <#=typename#> DiagonalMatrix(<#=vecname#> diagonal) => DiagonalMatrix(<#=string.Join(", ", r(0, dim).Select(i => $"diagonal[{i}]"))#>);

        public static <#=typename#> DiagonalMatrix(<#=string.Join(", ", r(0, dim).Select(i => "Scalar d" + i))#>) => (
<#
            for (int i = 0; i < dim; ++i)
            {
#>
            <#=string.Join(", ", r(0, dim).Select(j => i == j ? $"d{j}" : "0")) + (i < dim - 1 ? "," : "")#>
<#
            }
#>
        );


        /// <summary>
        /// Compares whether the two given matrices are equal regarding their coefficients.
        /// </summary>
        /// <param name="v1">First matrix</param>
        /// <param name="v2">Second matrix</param>
        /// <returns>Comparison result</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(<#=typename#> m1, <#=typename#> m2) => m1.Equals(m2);

        /// <summary>
        /// Compares whether the two given matrices are unequal regarding their coefficients.
        /// </summary>
        /// <param name="v1">First matrix</param>
        /// <param name="v2">Second matrix</param>
        /// <returns>Comparison result</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(<#=typename#> m1, <#=typename#> m2) => !(m1 == m2);

        /// <summary>
        /// Identity function (returns the given matrix unchanged)
        /// </summary>
        /// <param name="v">Original matrix</param>
        /// <returns>Unchanged matrix</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator +(<#=typename#> m) => m;

        /// <summary>
        /// Negates the given matrix
        /// </summary>
        /// <param name="v">Original matrix</param>
        /// <returns>Negated matrix</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator -(<#=typename#> m) => m.Negate();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator -(Scalar f, <#=typename#> m) => new <#=typename#>(f).Subtract(m);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator -(<#=typename#> m, Scalar f) => m.Subtract(f);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator +(Scalar f, <#=typename#> m) => m.Add(f);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator +(<#=typename#> m, Scalar f) => m.Add(f);

        /// <summary>
        /// Performs the subtraction of two matrices by subtracting their respective coefficients.
        /// </summary>
        /// <param name="v1">First matrix</param>
        /// <param name="v2">Second matrix</param>
        /// <returns>Subtraction result</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator -(<#=typename#> m1, <#=typename#> m2) => m1.Subtract(m2);

        /// <summary>
        /// Performs the addition of two matrices by adding their respective coefficients.
        /// </summary>
        /// <param name="v1">First matrix</param>
        /// <param name="v2">Second matrix</param>
        /// <returns>Addition result</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator +(<#=typename#> m1, <#=typename#> m2) => m1.Add(m2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=vecname#> operator *(<#=typename#> m, <#=vecname#> v) => m.Multiply(v);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator *(<#=typename#> m1, <#=typename#> m2) => m1.Multiply(m2);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator *(<#=typename#> m, Scalar f) => m.Multiply(f);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator *(Scalar f, <#=typename#> m) => m.Multiply(f);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator ^(<#=typename#> m, int c) => m.Power(c);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=typename#> operator /(<#=typename#> m, Scalar f) => m.Divide(f);

<#
        string _vecs = string.Join(", ", r(0, dim).Select(i => $"Vector{dim} x{i}"));
        string _scals = string.Join(", ", r(0, dim).Select(i => $"({string.Join(", ", r(0, dim).Select(j => $"Scalar r{j}"))}) c{i}"));
        string _flats = string.Join(", ", r(0, dim).SelectMany(i => r(0, dim).Select(j => $"Scalar x{i}{j}")));
#>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator (<#=_vecs#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator <#=typename#>((<#=_vecs#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.x{i}"))#>);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator (<#=_scals#>) (<#=typename#> m) => (<#=string.Join(", ", r(0, dim).Select(i => $"m[{i}]"))#>);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator <#=typename#>((<#=_scals#>) t) => new <#=typename#>(<#=string.Join(", ", r(0, dim).Select(i => $"t.c{i}"))#>);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator (<#=_flats#>) (<#=typename#> m) => (
<#
        for (int i = 0; i < dim; ++i)
        {
#>
            <#=string.Join(", ", r(0, dim).Select(j => $"m[{j}, {i}]"))#><#=i < dim - 1 ? "," : ""#>
<#
        }
#>
        );

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator <#=typename#>((<#=_flats#>) t) => (
<#
        for (int i = 0; i < dim; ++i)
        {
#>
            (<#=string.Join(", ", r(0, dim).Select(j => $"t.x{j}{i}"))#>)<#=i < dim - 1 ? "," : ""#>
<#
        }
#>
        );

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator <#=vecname#>[](<#=typename#> m) => m.Columns;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static explicit operator Scalar[](<#=typename#> m) => m.ToArray();

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator <#=typename#>(<#=vecname#>[] arr) => new <#=typename#>(arr);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static implicit operator <#=typename#>(Scalar[] arr) => new <#=typename#>(arr);
    }

    #endregion
<#
    }
#>
}
